---
id: "reactive-state-management-with-rxjs"
title: Reactive State Management with RxJS
section: Framework-Agnostic Core
---

# Chapter 6: State Management Patterns in Framework-Agnostic ViewModels

State management often becomes the most contentious architectural decision in frontend applications—not because developers lack opinions, but because they have too many. React teams debate Redux versus Zustand, Vue developers choose between Vuex and Pinia, and Angular projects wrestle with NgRx's complexity. Meanwhile, the actual business logic drowns in framework-specific boilerplate.

We're going to cut through this noise by establishing state management patterns that work _regardless_ of your view layer. This isn't about avoiding state libraries—it's about building ViewModels where state management emerges naturally from your domain model rather than being imposed by framework constraints.

## Understanding State Through the MVVM Lens

Before we dive into patterns, let's establish what we mean by "state" in a ViewModel context. State isn't just data that changes—it's the materialized representation of your application's current condition that the view needs to render accurately.

In our GreenWatch system, consider the `EnvironmentalMonitoringViewModel`. Its state includes:

- **Current sensor readings** (temperature, humidity, soil moisture)
- **Historical trends** for the past 24 hours
- **Alert thresholds** that determine when warnings appear
- **Loading states** for asynchronous operations
- **Error conditions** when sensor data becomes unavailable

Notice something here? Some of this state comes directly from our domain model (sensor readings, thresholds), while other state exists purely for presentation concerns (loading indicators, error messages). The ViewModel must manage both, but it shouldn't treat them the same way.

Let's define three distinct state categories that every ViewModel deals with:

```typescript
// src/core/viewmodels/base/state-types.ts

/**
 * Domain state: Data that represents actual business entities
 * This comes from your domain models and repositories
 */
export interface DomainState {
  // Real business data
}

/**
 * Presentation state: UI-specific concerns that don't exist in the domain
 * Things like loading indicators, form validation errors, modal visibility
 */
export interface PresentationState {
  isLoading: boolean;
  error: Error | null;
  validationErrors: Map<string, string>;
}

/**
 * Derived state: Values computed from other state
 * These should *never* be stored directly—always calculated on-demand
 */
export interface DerivedState {
  // Computed properties only—no storage
}
```

This distinction matters because each category requires different management strategies. Domain state flows from your model layer through observables. Presentation state lives entirely within the ViewModel. Derived state doesn't exist as storage at all—it's computed properties that recalculate when their dependencies change.

## The Single Source of Truth Principle

Here's where many applications go wrong: they scatter state across multiple locations, creating synchronization nightmares. Your repository holds one version of the data, your ViewModel caches another, and your view components maintain their own copies. When something changes, you're left reconciling three different realities.

The MVVM pattern solves this with a clear hierarchy: **the domain model is the single source of truth, and the ViewModel is the single source of presentation-ready state derived from that truth.**

Let's implement this concretely. Here's how our `EnvironmentalMonitoringViewModel` maintains a single source of truth:

```typescript
// src/features/monitoring/viewmodels/environmental-monitoring.viewmodel.ts

import { Observable, BehaviorSubject, combineLatest, map } from "rxjs";
import { SensorReading } from "../domain/models/sensor-reading";
import { SensorRepository } from "../domain/repositories/sensor.repository";
import { AlertThreshold } from "../domain/models/alert-threshold";

export class EnvironmentalMonitoringViewModel {
  // Private state subjects—the ViewModel owns these
  private readonly _loadingState = new BehaviorSubject<boolean>(false);
  private readonly _errorState = new BehaviorSubject<Error | null>(null);

  // Public observables—views subscribe to these, never modify them
  public readonly isLoading$: Observable<boolean> =
    this._loadingState.asObservable();
  public readonly error$: Observable<Error | null> =
    this._errorState.asObservable();

  // Domain state comes from repositories—we don't cache it
  public readonly currentReadings$: Observable<SensorReading[]>;
  public readonly thresholds$: Observable<AlertThreshold[]>;

  // Derived state is computed, never stored
  public readonly hasActiveAlerts$: Observable<boolean>;
  public readonly alertSummary$: Observable<string>;

  constructor(
    private readonly sensorRepository: SensorRepository,
    private readonly greenhouseId: string
  ) {
    // Domain state flows directly from the repository
    this.currentReadings$ = this.sensorRepository.streamReadings(
      this.greenhouseId
    );
    this.thresholds$ = this.sensorRepository.getThresholds(this.greenhouseId);

    // Derived state is computed from domain state
    this.hasActiveAlerts$ = combineLatest([
      this.currentReadings$,
      this.thresholds$,
    ]).pipe(
      map(([readings, thresholds]) => this.checkForAlerts(readings, thresholds))
    );

    this.alertSummary$ = combineLatest([
      this.currentReadings$,
      this.thresholds$,
    ]).pipe(
      map(([readings, thresholds]) =>
        this.generateAlertSummary(readings, thresholds)
      )
    );
  }

  /**
   * Commands modify state through domain operations, not direct mutations
   */
  public async refreshReadings(): Promise<void> {
    this._loadingState.next(true);
    this._errorState.next(null);

    try {
      await this.sensorRepository.refreshReadings(this.greenhouseId);
      // No need to update currentReadings$—it's already streaming from the repository
    } catch (error) {
      this._errorState.next(error as Error);
    } finally {
      this._loadingState.next(false);
    }
  }

  private checkForAlerts(
    readings: SensorReading[],
    thresholds: AlertThreshold[]
  ): boolean {
    // Implementation details...
    return readings.some((reading) => this.isOutOfRange(reading, thresholds));
  }

  private generateAlertSummary(
    readings: SensorReading[],
    thresholds: AlertThreshold[]
  ): string {
    // Implementation details...
    const violations = readings.filter((r) => this.isOutOfRange(r, thresholds));
    return violations.length > 0
      ? `${violations.length} sensor(s) out of range`
      : "All sensors nominal";
  }

  private isOutOfRange(
    reading: SensorReading,
    thresholds: AlertThreshold[]
  ): boolean {
    const threshold = thresholds.find((t) => t.sensorId === reading.sensorId);
    if (!threshold) return false;

    return reading.value < threshold.min || reading.value > threshold.max;
  }
}
```

Notice what we're _not_ doing here: we're not caching sensor readings in a private property. We're not manually updating a local copy when data changes. The repository is the source of truth, and we expose it through observables that views can subscribe to. This eliminates an entire class of synchronization bugs.

## State Composition Through Observable Streams

One of RxJS's superpowers is composing complex state from simpler streams. Instead of building monolithic state objects that contain everything a view might need, we create focused observables and let RxJS combine them efficiently.

Consider our greenhouse dashboard, which needs to display:

- Current temperature with trend indicator (↑ rising, ↓ falling, → stable)
- Humidity levels with color coding (green safe, yellow warning, red critical)
- Soil moisture with irrigation recommendations

Each of these requires combining multiple data sources. Let's build this compositionally:

```typescript
// src/features/monitoring/viewmodels/dashboard.viewmodel.ts

import { Observable, combineLatest, map, distinctUntilChanged } from "rxjs";

export interface TemperatureDisplay {
  current: number;
  unit: "C" | "F";
  trend: "rising" | "falling" | "stable";
  trendPercentage: number;
}

export interface HumidityDisplay {
  current: number;
  status: "safe" | "warning" | "critical";
  recommendation: string;
}

export class DashboardViewModel {
  // Raw domain streams
  private readonly currentReadings$: Observable<SensorReading[]>;
  private readonly historicalReadings$: Observable<SensorReading[]>;
  private readonly thresholds$: Observable<AlertThreshold[]>;
  private readonly userPreferences$: Observable<UserPreferences>;

  // Composed presentation streams
  public readonly temperatureDisplay$: Observable<TemperatureDisplay>;
  public readonly humidityDisplay$: Observable<HumidityDisplay>;
  public readonly soilMoistureDisplay$: Observable<SoilMoistureDisplay>;

  constructor(
    sensorRepository: SensorRepository,
    preferencesRepository: PreferencesRepository,
    greenhouseId: string
  ) {
    this.currentReadings$ = sensorRepository.streamReadings(greenhouseId);
    this.historicalReadings$ = sensorRepository.getHistoricalReadings(
      greenhouseId,
      { hours: 1 }
    );
    this.thresholds$ = sensorRepository.getThresholds(greenhouseId);
    this.userPreferences$ = preferencesRepository.getUserPreferences();

    // Temperature display composes current + historical + preferences
    this.temperatureDisplay$ = combineLatest([
      this.currentReadings$,
      this.historicalReadings$,
      this.userPreferences$,
    ]).pipe(
      map(([current, historical, prefs]) =>
        this.buildTemperatureDisplay(current, historical, prefs)
      ),
      distinctUntilChanged((a, b) => this.temperatureEquals(a, b))
    );

    // Humidity display composes current + thresholds
    this.humidityDisplay$ = combineLatest([
      this.currentReadings$,
      this.thresholds$,
    ]).pipe(
      map(([readings, thresholds]) =>
        this.buildHumidityDisplay(readings, thresholds)
      ),
      distinctUntilChanged(
        (a, b) => a.current === b.current && a.status === b.status
      )
    );

    // Additional displays follow the same pattern...
  }

  private buildTemperatureDisplay(
    currentReadings: SensorReading[],
    historicalReadings: SensorReading[],
    preferences: UserPreferences
  ): TemperatureDisplay {
    const tempSensor = currentReadings.find((r) => r.type === "temperature");
    if (!tempSensor) {
      return this.getDefaultTemperatureDisplay();
    }

    const historicalTemps = historicalReadings
      .filter((r) => r.type === "temperature")
      .map((r) => r.value);

    const trend = this.calculateTrend(tempSensor.value, historicalTemps);
    const trendPercentage = this.calculateTrendPercentage(
      tempSensor.value,
      historicalTemps
    );

    return {
      current: this.convertTemperature(
        tempSensor.value,
        preferences.temperatureUnit
      ),
      unit: preferences.temperatureUnit,
      trend,
      trendPercentage,
    };
  }

  private calculateTrend(
    current: number,
    historical: number[]
  ): "rising" | "falling" | "stable" {
    if (historical.length === 0) return "stable";

    const recentAverage =
      historical.slice(-10).reduce((sum, val) => sum + val, 0) / 10;
    const difference = current - recentAverage;

    // We use a threshold to avoid jittery trend changes
    const THRESHOLD = 0.5;
    if (difference > THRESHOLD) return "rising";
    if (difference < -THRESHOLD) return "falling";
    return "stable";
  }

  private temperatureEquals(
    a: TemperatureDisplay,
    b: TemperatureDisplay
  ): boolean {
    // Custom equality check prevents unnecessary re-renders
    return (
      a.current === b.current &&
      a.trend === b.trend &&
      a.unit === b.unit &&
      Math.abs(a.trendPercentage - b.trendPercentage) < 0.1
    );
  }

  // Additional helper methods...
}
```

This compositional approach gives us several advantages:

**Automatic updates**: When sensor readings change, all dependent displays recalculate automatically. There's no manual synchronization logic.

**Selective reactivity**: The `distinctUntilChanged` operators prevent unnecessary updates. If temperature changes by 0.01 degrees but the trend stays the same, dependent views don't re-render.

**Testability**: Each display builder is a pure function that's trivial to test. You don't need to mock observables—just pass in test data and verify the output.

**Composability**: Need to add a new display? Create a new stream that composes existing ones. The pattern scales without increasing complexity.

## Handling Transient State

Not all state belongs in observables. Some state is so short-lived or isolated that managing it through reactive streams adds unnecessary complexity. Let's be pragmatic about this.

Consider form validation in our greenhouse configuration screen. When a user types an alert threshold, we need to validate it immediately and show inline error messages. This validation state is:

- **Component-local**: No other part of the application cares about it
- **Synchronous**: We validate immediately, not asynchronously
- **Transient**: It only matters while the user is editing

For state like this, simple properties work better than observables:

```typescript
// src/features/configuration/viewmodels/threshold-editor.viewmodel.ts

export interface ThresholdFormData {
  sensorId: string;
  minValue: string; // String because users type in text inputs
  maxValue: string;
  unit: string;
}

export interface ValidationErrors {
  minValue?: string;
  maxValue?: string;
  general?: string;
}

export class ThresholdEditorViewModel {
  // Observable state for domain data
  public readonly existingThresholds$: Observable<AlertThreshold[]>;
  public readonly availableSensors$: Observable<Sensor[]>;

  // Simple properties for transient form state
  private formData: ThresholdFormData = {
    sensorId: "",
    minValue: "",
    maxValue: "",
    unit: "C",
  };

  private validationErrors: ValidationErrors = {};

  constructor(
    private readonly thresholdRepository: ThresholdRepository,
    sensorRepository: SensorRepository,
    private readonly greenhouseId: string
  ) {
    this.existingThresholds$ = thresholdRepository.getThresholds(greenhouseId);
    this.availableSensors$ = sensorRepository.getSensors(greenhouseId);
  }

  /**
   * Update form data and validate synchronously
   * Returns validation errors immediately—no observables needed
   */
  public updateField(
    field: keyof ThresholdFormData,
    value: string
  ): ValidationErrors {
    this.formData[field] = value;
    this.validationErrors = this.validate(this.formData);
    return this.validationErrors;
  }

  /**
   * Get current form state—useful for controlled inputs
   */
  public getFormData(): Readonly<ThresholdFormData> {
    return { ...this.formData };
  }

  /**
   * Get current validation state
   */
  public getValidationErrors(): Readonly<ValidationErrors> {
    return { ...this.validationErrors };
  }

  /**
   * Commands that modify domain state still use async operations
   */
  public async saveThreshold(): Promise<{ success: boolean; error?: string }> {
    // Final validation before save
    this.validationErrors = this.validate(this.formData);

    if (Object.keys(this.validationErrors).length > 0) {
      return { success: false, error: "Please fix validation errors" };
    }

    try {
      const threshold = this.convertToThreshold(this.formData);
      await this.thresholdRepository.saveThreshold(
        this.greenhouseId,
        threshold
      );
      this.resetForm();
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: "Failed to save threshold: " + (error as Error).message,
      };
    }
  }

  private validate(data: ThresholdFormData): ValidationErrors {
    const errors: ValidationErrors = {};

    const min = parseFloat(data.minValue);
    const max = parseFloat(data.maxValue);

    if (isNaN(min)) {
      errors.minValue = "Minimum value must be a number";
    }

    if (isNaN(max)) {
      errors.maxValue = "Maximum value must be a number";
    }

    if (!isNaN(min) && !isNaN(max) && min >= max) {
      errors.general = "Minimum value must be less than maximum value";
    }

    if (!data.sensorId) {
      errors.general = "Please select a sensor";
    }

    return errors;
  }

  private resetForm(): void {
    this.formData = {
      sensorId: "",
      minValue: "",
      maxValue: "",
      unit: "C",
    };
    this.validationErrors = {};
  }

  private convertToThreshold(data: ThresholdFormData): AlertThreshold {
    return {
      sensorId: data.sensorId,
      min: parseFloat(data.minValue),
      max: parseFloat(data.maxValue),
      unit: data.unit as "C" | "F",
    };
  }
}
```

This isn't a compromise or a deviation from reactive principles—it's using the right tool for the job. Observables excel at modeling asynchronous, multi-source state that changes over time. Simple properties excel at modeling synchronous, localized state that exists briefly.

The key insight: **your ViewModel can mix both approaches.** Use observables for state that flows through your system, and use properties for state that lives and dies within a single interaction.

## State Derivation and Memoization

Derived state is tricky. It's tempting to compute values once and cache them, but that creates synchronization problems. It's equally tempting to recompute everything on every change, but that wastes CPU cycles and causes unnecessary re-renders.

RxJS gives us the best of both worlds through operators that memoize intelligently. Let's explore this with a complex derived state example: our greenhouse dashboard needs to show irrigation recommendations based on soil moisture, weather forecast, and plant types.

```typescript
// src/features/monitoring/viewmodels/irrigation-recommendation.viewmodel.ts

import {
  Observable,
  combineLatest,
  map,
  shareReplay,
  distinctUntilChanged,
} from "rxjs";

export interface IrrigationRecommendation {
  shouldIrrigate: boolean;
  urgency: "low" | "medium" | "high";
  estimatedWaterNeeded: number; // liters
  reasoning: string[];
  nextCheckTime: Date;
}

export class IrrigationRecommendationViewModel {
  // Source observables
  private readonly soilMoisture$: Observable<number>;
  private readonly weatherForecast$: Observable<WeatherForecast>;
  private readonly plantTypes$: Observable<PlantType[]>;
  private readonly historicalIrrigation$: Observable<IrrigationEvent[]>;

  // Derived state with intelligent caching
  public readonly recommendation$: Observable<IrrigationRecommendation>;

  constructor(
    sensorRepository: SensorRepository,
    weatherRepository: WeatherRepository,
    plantRepository: PlantRepository,
    irrigationRepository: IrrigationRepository,
    greenhouseId: string
  ) {
    // Source data streams
    this.soilMoisture$ = sensorRepository.streamReadings(greenhouseId).pipe(
      map(
        (readings) =>
          readings.find((r) => r.type === "soil_moisture")?.value ?? 0
      ),
      distinctUntilChanged()
    );

    this.weatherForecast$ = weatherRepository.getForecast(greenhouseId).pipe(
      shareReplay(1) // Cache the latest forecast for multiple subscribers
    );

    this.plantTypes$ = plantRepository
      .getPlantTypes(greenhouseId)
      .pipe(shareReplay(1));

    this.historicalIrrigation$ = irrigationRepository
      .getRecentEvents(greenhouseId, { days: 7 })
      .pipe(shareReplay(1));

    // Derived recommendation—only recalculates when inputs change
    this.recommendation$ = combineLatest([
      this.soilMoisture$,
      this.weatherForecast$,
      this.plantTypes$,
      this.historicalIrrigation$,
    ]).pipe(
      map(([moisture, forecast, plants, history]) =>
        this.calculateRecommendation(moisture, forecast, plants, history)
      ),
      // Only emit when the recommendation actually changes
      distinctUntilChanged(
        (a, b) =>
          a.shouldIrrigate === b.shouldIrrigate &&
          a.urgency === b.urgency &&
          a.estimatedWaterNeeded === b.estimatedWaterNeeded
      ),
      // Cache for multiple subscribers—one calculation, many consumers
      shareReplay(1)
    );
  }

  private calculateRecommendation(
    moisture: number,
    forecast: WeatherForecast,
    plants: PlantType[],
    history: IrrigationEvent[]
  ): IrrigationRecommendation {
    const reasoning: string[] = [];

    // Calculate ideal moisture range based on plant types
    const idealMoisture = this.calculateIdealMoisture(plants);
    const moistureDeficit = idealMoisture - moisture;

    if (moistureDeficit <= 0) {
      reasoning.push("Soil moisture is adequate");
      return {
        shouldIrrigate: false,
        urgency: "low",
        estimatedWaterNeeded: 0,
        reasoning,
        nextCheckTime: this.calculateNextCheck(moisture, forecast),
      };
    }

    reasoning.push(
      `Soil moisture ${moisture.toFixed(1)}% is below ideal ${idealMoisture}%`
    );

    // Factor in weather forecast
    const upcomingRain = forecast.events.some(
      (e) => e.type === "rain" && e.probability > 0.7
    );

    if (upcomingRain) {
      reasoning.push("Rain expected within 24 hours");
      return {
        shouldIrrigate: false,
        urgency: "low",
        estimatedWaterNeeded: 0,
        reasoning,
        nextCheckTime: forecast.events.find((e) => e.type === "rain")!.time,
      };
    }

    // Check irrigation history to avoid over-watering
    const recentIrrigation = history.find(
      (e) => Date.now() - e.timestamp.getTime() < 12 * 60 * 60 * 1000 // 12 hours
    );

    if (recentIrrigation) {
      reasoning.push("Recently irrigated—allowing time for absorption");
      return {
        shouldIrrigate: false,
        urgency: "low",
        estimatedWaterNeeded: 0,
        reasoning,
        nextCheckTime: new Date(
          recentIrrigation.timestamp.getTime() + 12 * 60 * 60 * 1000
        ),
      };
    }

    // Determine urgency based on deficit
    const urgency = this.calculateUrgency(moistureDeficit, plants);
    const waterNeeded = this.calculateWaterVolume(moistureDeficit, plants);

    reasoning.push(`Estimated water needed: ${waterNeeded} liters`);
    reasoning.push(`Urgency level: ${urgency}`);

    return {
      shouldIrrigate: true,
      urgency,
      estimatedWaterNeeded: waterNeeded,
      reasoning,
      nextCheckTime: new Date(Date.now() + 4 * 60 * 60 * 1000), // Check in 4 hours
    };
  }

  private calculateIdealMoisture(plants: PlantType[]): number {
    // Different plants have different moisture requirements
    const moistureRequirements = plants.map((p) => p.idealMoisture);
    // Return the average—in reality, you might use a weighted average
    return (
      moistureRequirements.reduce((sum, val) => sum + val, 0) / plants.length
    );
  }

  private calculateUrgency(
    deficit: number,
    plants: PlantType[]
  ): "low" | "medium" | "high" {
    // Plants have different drought tolerance
    const minTolerance = Math.min(...plants.map((p) => p.droughtTolerance));

    if (deficit > 20 || minTolerance < 0.3) return "high";
    if (deficit > 10 || minTolerance < 0.6) return "medium";
    return "low";
  }

  private calculateWaterVolume(deficit: number, plants: PlantType[]): number {
    // Simplified calculation—real implementation would factor in soil type,
    // greenhouse size, etc.
    const totalArea = plants.reduce((sum, p) => sum + p.plantedArea, 0);
    return (deficit / 100) * totalArea * 10; // 10 liters per m² per 10% deficit
  }

  private calculateNextCheck(
    moisture: number,
    forecast: WeatherForecast
  ): Date {
    // Implementation details...
    return new Date(Date.now() + 6 * 60 * 60 * 1000); // Check in 6 hours
  }
}
```

Let's break down what makes this derivation efficient:

**shareReplay(1)** on source streams means we fetch weather forecasts and plant data once, even if multiple parts of the ViewModel (or multiple ViewModels) subscribe. This is critical for expensive operations.

**distinctUntilChanged** with custom equality prevents recalculation when inputs change in irrelevant ways. If soil moisture fluctuates between 45.1% and 45.2%, but both values produce the same recommendation, we don't recalculate.

**Pure calculation functions** like `calculateRecommendation` make testing straightforward. You can verify the logic without setting up observables or subscriptions.

The key principle: **derived state should be lazy but cached.** Don't compute it until someone subscribes, but once you've computed it, share the result with all subscribers. RxJS handles this automatically with `shareReplay`.

## Commands and State Mutations

ViewModels expose state through observables, but how do we modify that state? The answer is **commands**—methods that encapsulate state-changing operations with clear boundaries and error handling.

A well-designed command method:

1. **Validates preconditions** before attempting the operation
2. **Updates presentation state** (loading, error) to reflect the operation's progress
3. **Delegates to domain services** or repositories for the actual work
4. **Handles errors** gracefully and updates error state
5. **Returns a result** that views can react to

Let's implement commands for our irrigation system:

```typescript
// src/features/irrigation/viewmodels/irrigation-control.viewmodel.ts

import { BehaviorSubject, Observable, firstValueFrom } from "rxjs";

export interface IrrigationCommandResult {
  success: boolean;
  message: string;
  error?: Error;
}

export class IrrigationControlViewModel {
  // State subjects
  private readonly _isIrrigating = new BehaviorSubject<boolean>(false);
  private readonly _lastIrrigationTime = new BehaviorSubject<Date | null>(null);
  private readonly _commandInProgress = new BehaviorSubject<boolean>(false);
  private readonly _lastError = new BehaviorSubject<Error | null>(null);

  // Public observables
  public readonly isIrrigating$ = this._isIrrigating.asObservable();
  public readonly lastIrrigationTime$ = this._lastIrrigationTime.asObservable();
  public readonly commandInProgress$ = this._commandInProgress.asObservable();
  public readonly lastError$ = this._lastError.asObservable();

  constructor(
    private readonly irrigationService: IrrigationService,
    private readonly greenhouseId: string
  ) {
    // Initialize state from the service
    this.initializeState();
  }

  /**
   * Start irrigation with specified parameters
   * This is a command that modifies state through the domain layer
   */
  public async startIrrigation(
    durationMinutes: number,
    zones: string[]
  ): Promise<IrrigationCommandResult> {
    // Precondition checks
    if (durationMinutes <= 0 || durationMinutes > 120) {
      return {
        success: false,
        message: "Duration must be between 1 and 120 minutes",
        error: new Error("Invalid duration"),
      };
    }

    if (zones.length === 0) {
      return {
        success: false,
        message: "At least one zone must be selected",
        error: new Error("No zones selected"),
      };
    }

    // Check if already irrigating
    if (this._isIrrigating.value) {
      return {
        success: false,
        message: "Irrigation is already in progress",
        error: new Error("Already irrigating"),
      };
    }

    // Update presentation state to show operation in progress
    this._commandInProgress.next(true);
    this._lastError.next(null);

    try {
      // Delegate to domain service
      await this.irrigationService.startIrrigation(
        this.greenhouseId,
        durationMinutes,
        zones
      );

      // Update state to reflect successful start
      this._isIrrigating.next(true);
      this._lastIrrigationTime.next(new Date());

      return {
        success: true,
        message: `Irrigation started for ${durationMinutes} minutes`,
      };
    } catch (error) {
      // Handle errors and update error state
      const err = error as Error;
      this._lastError.next(err);

      return {
        success: false,
        message: "Failed to start irrigation",
        error: err,
      };
    } finally {
      // Always clear the in-progress flag
      this._commandInProgress.next(false);
    }
  }

  /**
   * Stop irrigation immediately
   */
  public async stopIrrigation(): Promise<IrrigationCommandResult> {
    // Precondition check
    if (!this._isIrrigating.value) {
      return {
        success: false,
        message: "Irrigation is not currently running",
        error: new Error("Not irrigating"),
      };
    }

    this._commandInProgress.next(true);
    this._lastError.next(null);

    try {
      await this.irrigationService.stopIrrigation(this.greenhouseId);
      this._isIrrigating.next(false);

      return {
        success: true,
        message: "Irrigation stopped",
      };
    } catch (error) {
      const err = error as Error;
      this._lastError.next(err);

      return {
        success: false,
        message: "Failed to stop irrigation",
        error: err,
      };
    } finally {
      this._commandInProgress.next(false);
    }
  }

  /**
   * Schedule irrigation for a future time
   */
  public async scheduleIrrigation(
    startTime: Date,
    durationMinutes: number,
    zones: string[]
  ): Promise<IrrigationCommandResult> {
    // Precondition checks
    if (startTime < new Date()) {
      return {
        success: false,
        message: "Cannot schedule irrigation in the past",
        error: new Error("Invalid start time"),
      };
    }

    this._commandInProgress.next(true);
    this._lastError.next(null);

    try {
      await this.irrigationService.scheduleIrrigation(
        this.greenhouseId,
        startTime,
        durationMinutes,
        zones
      );

      return {
        success: true,
        message: `Irrigation scheduled for ${startTime.toLocaleString()}`,
      };
    } catch (error) {
      const err = error as Error;
      this._lastError.next(err);

      return {
        success: false,
        message: "Failed to schedule irrigation",
        error: err,
      };
    } finally {
      this._commandInProgress.next(false);
    }
  }

  private async initializeState(): Promise<void> {
    try {
      const status = await this.irrigationService.getStatus(this.greenhouseId);
      this._isIrrigating.next(status.isActive);
      this._lastIrrigationTime.next(status.lastIrrigationTime);
    } catch (error) {
      this._lastError.next(error as Error);
    }
  }

  /**
   * Clean up resources when the ViewModel is destroyed
   */
  public dispose(): void {
    // Complete all subjects to release memory
    this._isIrrigating.complete();
    this._lastIrrigationTime.complete();
    this._commandInProgress.complete();
    this._lastError.complete();
  }
}
```

Notice the pattern here: commands are async methods that return results. They don't throw exceptions—they catch errors and return them in the result object. This makes error handling explicit and forces views to deal with failures.

The `commandInProgress$` observable is particularly useful. Views can subscribe to it to disable buttons during operations, show loading spinners, or prevent double-submission. This presentation state lives in the ViewModel where it belongs, not scattered across multiple components.

## State Persistence and Hydration

Applications don't exist in isolation—users expect their state to persist across sessions. Maybe they've configured alert thresholds, or they've customized their dashboard layout. That state needs to survive page refreshes and app restarts.

We handle persistence at the repository layer, but the ViewModel coordinates it. Let's implement this for our user preferences:

```typescript
// src/features/preferences/viewmodels/preferences.viewmodel.ts

import {
  BehaviorSubject,
  Observable,
  debounceTime,
  distinctUntilChanged,
} from "rxjs";

export interface UserPreferences {
  temperatureUnit: "C" | "F";
  theme: "light" | "dark" | "auto";
  notificationsEnabled: boolean;
  dashboardLayout: DashboardLayout;
  autoRefreshInterval: number; // seconds
}

export class PreferencesViewModel {
  // State subject with initial default values
  private readonly _preferences = new BehaviorSubject<UserPreferences>(
    this.getDefaultPreferences()
  );

  // Public observable for views to subscribe
  public readonly preferences$: Observable<UserPreferences> =
    this._preferences.asObservable();

  // Save state subjects
  private readonly _isSaving = new BehaviorSubject<boolean>(false);
  private readonly _lastSaved = new BehaviorSubject<Date | null>(null);
  private readonly _saveError = new BehaviorSubject<Error | null>(null);

  public readonly isSaving$ = this._isSaving.asObservable();
  public readonly lastSaved$ = this._lastSaved.asObservable();
  public readonly saveError$ = this._saveError.asObservable();

  constructor(
    private readonly preferencesRepository: PreferencesRepository,
    private readonly userId: string
  ) {
    // Load preferences on initialization
    this.loadPreferences();

    // Auto-save preferences when they change (debounced)
    this._preferences
      .pipe(
        debounceTime(1000), // Wait 1 second after last change
        distinctUntilChanged((a, b) => this.preferencesEqual(a, b))
      )
      .subscribe((prefs) => this.savePreferences(prefs));
  }

  /**
   * Load preferences from storage
   * This runs once during ViewModel initialization
   */
  private async loadPreferences(): Promise<void> {
    try {
      const stored = await this.preferencesRepository.getPreferences(
        this.userId
      );

      if (stored) {
        // Merge stored preferences with defaults to handle new preference keys
        const merged = { ...this.getDefaultPreferences(), ...stored };
        this._preferences.next(merged);
      }
    } catch (error) {
      console.error("Failed to load preferences:", error);
      // Don't update error state here—loading failures aren't critical
      // Just use default preferences
    }
  }

  /**
   * Save preferences to storage
   * This runs automatically when preferences change, but can also be called manually
   */
  private async savePreferences(preferences: UserPreferences): Promise<void> {
    this._isSaving.next(true);
    this._saveError.next(null);

    try {
      await this.preferencesRepository.savePreferences(
        this.userId,
        preferences
      );
      this._lastSaved.next(new Date());
    } catch (error) {
      this._saveError.next(error as Error);
      console.error("Failed to save preferences:", error);
    } finally {
      this._isSaving.next(false);
    }
  }

  /**
   * Update a single preference field
   * The auto-save subscription will handle persistence
   */
  public updatePreference<K extends keyof UserPreferences>(
    key: K,
    value: UserPreferences[K]
  ): void {
    const current = this._preferences.value;
    this._preferences.next({ ...current, [key]: value });
  }

  /**
   * Update multiple preferences at once
   */
  public updatePreferences(partial: Partial<UserPreferences>): void {
    const current = this._preferences.value;
    this._preferences.next({ ...current, ...partial });
  }

  /**
   * Reset preferences to defaults
   */
  public async resetToDefaults(): Promise<void> {
    const defaults = this.getDefaultPreferences();
    this._preferences.next(defaults);

    // Force an immediate save for resets
    await this.savePreferences(defaults);
  }

  /**
   * Export preferences as JSON for backup or sharing
   */
  public exportPreferences(): string {
    return JSON.stringify(this._preferences.value, null, 2);
  }

  /**
   * Import preferences from JSON
   */
  public async importPreferences(
    json: string
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const imported = JSON.parse(json) as UserPreferences;

      // Validate imported preferences
      if (!this.isValidPreferences(imported)) {
        return {
          success: false,
          error: "Invalid preferences format",
        };
      }

      // Merge with defaults to handle missing keys
      const merged = { ...this.getDefaultPreferences(), ...imported };
      this._preferences.next(merged);

      await this.savePreferences(merged);

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: (error as Error).message,
      };
    }
  }

  private getDefaultPreferences(): UserPreferences {
    return {
      temperatureUnit: "C",
      theme: "auto",
      notificationsEnabled: true,
      dashboardLayout: {
        /* default layout */
      } as DashboardLayout,
      autoRefreshInterval: 30,
    };
  }

  private preferencesEqual(a: UserPreferences, b: UserPreferences): boolean {
    // Deep equality check to prevent unnecessary saves
    return JSON.stringify(a) === JSON.stringify(b);
  }

  private isValidPreferences(obj: any): obj is UserPreferences {
    // Basic validation—extend this based on your needs
    return (
      obj &&
      typeof obj === "object" &&
      (obj.temperatureUnit === "C" || obj.temperatureUnit === "F") &&
      ["light", "dark", "auto"].includes(obj.theme)
    );
  }

  public dispose(): void {
    this._preferences.complete();
    this._isSaving.complete();
    this._lastSaved.complete();
    this._saveError.complete();
  }
}
```

The auto-save pattern is particularly elegant. Instead of requiring views to call a save method after every change, we observe the preferences stream and automatically persist changes after they stabilize. The `debounceTime(1000)` operator ensures we don't hammer the storage layer with writes—we wait until the user stops making changes for a second.

This pattern works for any state that needs persistence: user settings, draft forms, session data, anything. The ViewModel coordinates it all without views needing to know anything about storage mechanisms.

## Handling Optimistic Updates

In real-time applications, waiting for server confirmation before updating the UI feels sluggish. When a user adjusts an alert threshold, they expect immediate feedback—but what if the save fails?

Optimistic updates require careful state management. Let's implement this for our threshold editor:

```typescript
// src/features/configuration/viewmodels/optimistic-threshold.viewmodel.ts

import { BehaviorSubject, Observable, merge } from "rxjs";
import { map, scan } from "rxjs/operators";

interface PendingUpdate {
  id: string;
  threshold: AlertThreshold;
  timestamp: number;
}

interface FailedUpdate {
  id: string;
  error: Error;
  originalThreshold: AlertThreshold;
}

export class OptimisticThresholdViewModel {
  // Server state—the source of truth
  private readonly serverThresholds$: Observable<AlertThreshold[]>;

  // Local modifications that haven't been confirmed
  private readonly _pendingUpdates = new BehaviorSubject<PendingUpdate[]>([]);

  // Failed updates that need to be reverted or retried
  private readonly _failedUpdates = new BehaviorSubject<FailedUpdate[]>([]);

  // Combined view of server state + pending updates
  public readonly thresholds$: Observable<AlertThreshold[]>;
  public readonly hasPendingChanges$: Observable<boolean>;
  public readonly failedUpdates$: Observable<FailedUpdate[]>;

  constructor(
    private readonly thresholdRepository: ThresholdRepository,
    private readonly greenhouseId: string
  ) {
    // Server state comes from the repository
    this.serverThresholds$ = thresholdRepository.getThresholds(greenhouseId);

    // Combine server state with pending updates
    this.thresholds$ = merge(
      this.serverThresholds$,
      this._pendingUpdates.asObservable()
    ).pipe(
      scan((acc, update) => {
        if (Array.isArray(update)) {
          // Server update—this is the base state
          return this.applyPendingUpdates(update, this._pendingUpdates.value);
        } else {
          // Pending updates changed—recompute
          return this.applyPendingUpdates(acc, update);
        }
      }, [] as AlertThreshold[])
    );

    this.hasPendingChanges$ = this._pendingUpdates.pipe(
      map((updates) => updates.length > 0)
    );

    this.failedUpdates$ = this._failedUpdates.asObservable();
  }

  /**
   * Update a threshold optimistically
   * The UI updates immediately, but we track the update as pending
   */
  public async updateThreshold(threshold: AlertThreshold): Promise<void> {
    const updateId = this.generateUpdateId();

    // Add to pending updates immediately
    const pendingUpdate: PendingUpdate = {
      id: updateId,
      threshold,
      timestamp: Date.now(),
    };

    this._pendingUpdates.next([...this._pendingUpdates.value, pendingUpdate]);

    try {
      // Attempt to save to server
      await this.thresholdRepository.updateThreshold(
        this.greenhouseId,
        threshold
      );

      // Success—remove from pending
      this.removePendingUpdate(updateId);
    } catch (error) {
      // Failure—move to failed updates
      this.handleFailedUpdate(updateId, error as Error, threshold);
    }
  }

  /**
   * Retry a failed update
   */
  public async retryFailedUpdate(updateId: string): Promise<void> {
    const failed = this._failedUpdates.value.find((u) => u.id === updateId);
    if (!failed) return;

    // Remove from failed list
    this._failedUpdates.next(
      this._failedUpdates.value.filter((u) => u.id !== updateId)
    );

    // Try the update again
    await this.updateThreshold(failed.originalThreshold);
  }

  /**
   * Discard a failed update and revert to server state
   */
  public discardFailedUpdate(updateId: string): void {
    this._failedUpdates.next(
      this._failedUpdates.value.filter((u) => u.id !== updateId)
    );
  }

  /**
   * Apply pending updates to server state to get the optimistic view
   */
  private applyPendingUpdates(
    serverState: AlertThreshold[],
    pending: PendingUpdate[]
  ): AlertThreshold[] {
    // Start with server state
    const result = [...serverState];

    // Apply each pending update
    for (const update of pending) {
      const index = result.findIndex((t) => t.id === update.threshold.id);
      if (index >= 0) {
        result[index] = update.threshold;
      } else {
        result.push(update.threshold);
      }
    }

    return result;
  }

  private removePendingUpdate(updateId: string): void {
    this._pendingUpdates.next(
      this._pendingUpdates.value.filter((u) => u.id !== updateId)
    );
  }

  private handleFailedUpdate(
    updateId: string,
    error: Error,
    originalThreshold: AlertThreshold
  ): void {
    // Remove from pending
    this.removePendingUpdate(updateId);

    // Add to failed
    this._failedUpdates.next([
      ...this._failedUpdates.value,
      {
        id: updateId,
        error,
        originalThreshold,
      },
    ]);
  }

  private generateUpdateId(): string {
    return `update-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  public dispose(): void {
    this._pendingUpdates.complete();
    this._failedUpdates.complete();
  }
}
```

This pattern gives users immediate feedback while maintaining consistency. If the save succeeds, the pending update disappears silently. If it fails, we expose the failure through `failedUpdates$` and let the view handle it—maybe showing a notification with retry and discard buttons.

The key insight: **optimistic state is layered on top of server state, not replacing it.** We always maintain the server state as our source of truth and compute the optimistic view by applying pending changes.

---

## Testing State Management

State management patterns are only valuable if they're testable. Let's verify that our ViewModels behave correctly with focused unit tests.

Testing observables requires patience—you need to wait for async operations and verify emissions. But the patterns we've established make this straightforward. Here's how we test our `DashboardViewModel`:

```typescript
// src/features/monitoring/viewmodels/__tests__/dashboard.viewmodel.spec.ts

import { TestScheduler } from "rxjs/testing";
import { DashboardViewModel } from "../dashboard.viewmodel";
import { MockSensorRepository } from "../../domain/repositories/__mocks__/sensor.repository.mock";

describe("DashboardViewModel", () => {
  let testScheduler: TestScheduler;
  let mockSensorRepository: MockSensorRepository;
  let viewModel: DashboardViewModel;

  beforeEach(() => {
    // TestScheduler lets us control time in tests
    testScheduler = new TestScheduler((actual, expected) => {
      expect(actual).toEqual(expected);
    });

    mockSensorRepository = new MockSensorRepository();
    // We'll inject the mock during ViewModel creation
  });

  it("should compute temperature trend from historical data", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      // Setup: emit sensor readings over time
      const currentReadings = cold("a-b-c", {
        a: [{ type: "temperature", value: 20 }],
        b: [{ type: "temperature", value: 22 }],
        c: [{ type: "temperature", value: 24 }],
      });

      const historicalReadings = cold("h", {
        h: Array.from({ length: 10 }, (_, i) => ({
          type: "temperature",
          value: 18 + i * 0.2, // Gradually rising
        })),
      });

      mockSensorRepository.streamReadings.mockReturnValue(currentReadings);
      mockSensorRepository.getHistoricalReadings.mockReturnValue(
        historicalReadings
      );

      viewModel = new DashboardViewModel(
        mockSensorRepository,
        mockPreferencesRepository,
        "greenhouse-1"
      );

      // Verify the temperature display emits the expected trend
      expectObservable(viewModel.temperatureDisplay$).toBe("a-b-c", {
        a: expect.objectContaining({ trend: "rising", current: 20 }),
        b: expect.objectContaining({ trend: "rising", current: 22 }),
        c: expect.objectContaining({ trend: "rising", current: 24 }),
      });
    });
  });

  it("should mark trend as stable when changes are below threshold", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const currentReadings = cold("a-b", {
        a: [{ type: "temperature", value: 20.0 }],
        b: [{ type: "temperature", value: 20.3 }], // Only 0.3° change
      });

      const historicalReadings = cold("h", {
        h: Array.from({ length: 10 }, () => ({
          type: "temperature",
          value: 20.0, // Stable historical data
        })),
      });

      mockSensorRepository.streamReadings.mockReturnValue(currentReadings);
      mockSensorRepository.getHistoricalReadings.mockReturnValue(
        historicalReadings
      );

      viewModel = new DashboardViewModel(
        mockSensorRepository,
        mockPreferencesRepository,
        "greenhouse-1"
      );

      // Both readings should show 'stable' trend
      expectObservable(viewModel.temperatureDisplay$).toBe("a-b", {
        a: expect.objectContaining({ trend: "stable" }),
        b: expect.objectContaining({ trend: "stable" }),
      });
    });
  });

  it("should not emit duplicate displays when trend remains unchanged", () => {
    testScheduler.run(({ cold, expectObservable }) => {
      // Emit three readings with the same effective trend
      const currentReadings = cold("a-b-c", {
        a: [{ type: "temperature", value: 20.0 }],
        b: [{ type: "temperature", value: 20.1 }],
        c: [{ type: "temperature", value: 20.2 }],
      });

      const historicalReadings = cold("h", {
        h: Array.from({ length: 10 }, () => ({
          type: "temperature",
          value: 20.0,
        })),
      });

      mockSensorRepository.streamReadings.mockReturnValue(currentReadings);
      mockSensorRepository.getHistoricalReadings.mockReturnValue(
        historicalReadings
      );

      viewModel = new DashboardViewModel(
        mockSensorRepository,
        mockPreferencesRepository,
        "greenhouse-1"
      );

      // distinctUntilChanged should prevent duplicate emissions
      // We should only get one emission since trend stays 'stable'
      expectObservable(viewModel.temperatureDisplay$).toBe("a--", {
        a: expect.objectContaining({ trend: "stable" }),
      });
    });
  });
});
```

Testing commands follows a similar pattern, but we verify side effects instead of observable emissions:

```typescript
// src/features/irrigation/viewmodels/__tests__/irrigation-control.viewmodel.spec.ts

describe("IrrigationControlViewModel", () => {
  let mockIrrigationService: jest.Mocked<IrrigationService>;
  let viewModel: IrrigationControlViewModel;

  beforeEach(() => {
    mockIrrigationService = {
      startIrrigation: jest.fn(),
      stopIrrigation: jest.fn(),
      getStatus: jest.fn().mockResolvedValue({
        isActive: false,
        lastIrrigationTime: null,
      }),
    } as any;

    viewModel = new IrrigationControlViewModel(
      mockIrrigationService,
      "greenhouse-1"
    );
  });

  describe("startIrrigation", () => {
    it("should reject invalid duration", async () => {
      const result = await viewModel.startIrrigation(0, ["zone-1"]);

      expect(result.success).toBe(false);
      expect(result.message).toContain("Duration must be");
      expect(mockIrrigationService.startIrrigation).not.toHaveBeenCalled();
    });

    it("should reject when no zones selected", async () => {
      const result = await viewModel.startIrrigation(30, []);

      expect(result.success).toBe(false);
      expect(result.message).toContain("At least one zone");
      expect(mockIrrigationService.startIrrigation).not.toHaveBeenCalled();
    });

    it("should update state on successful start", async () => {
      mockIrrigationService.startIrrigation.mockResolvedValue(undefined);

      const result = await viewModel.startIrrigation(30, ["zone-1"]);

      expect(result.success).toBe(true);
      expect(mockIrrigationService.startIrrigation).toHaveBeenCalledWith(
        "greenhouse-1",
        30,
        ["zone-1"]
      );

      // Verify state observables reflect the change
      const isIrrigating = await firstValueFrom(viewModel.isIrrigating$);
      expect(isIrrigating).toBe(true);
    });

    it("should handle service failures gracefully", async () => {
      const error = new Error("Network timeout");
      mockIrrigationService.startIrrigation.mockRejectedValue(error);

      const result = await viewModel.startIrrigation(30, ["zone-1"]);

      expect(result.success).toBe(false);
      expect(result.error).toBe(error);

      // Verify error state is updated
      const lastError = await firstValueFrom(viewModel.lastError$);
      expect(lastError).toBe(error);

      // Verify irrigation state didn't change
      const isIrrigating = await firstValueFrom(viewModel.isIrrigating$);
      expect(isIrrigating).toBe(false);
    });

    it("should prevent concurrent irrigation attempts", async () => {
      // Start first irrigation
      mockIrrigationService.startIrrigation.mockImplementation(
        () => new Promise((resolve) => setTimeout(resolve, 100))
      );

      const first = viewModel.startIrrigation(30, ["zone-1"]);

      // Try to start second irrigation while first is in progress
      const second = await viewModel.startIrrigation(30, ["zone-2"]);

      expect(second.success).toBe(false);
      expect(second.message).toContain("already in progress");

      await first;
    });
  });
});
```

These tests verify behavior, not implementation details. We don't care how the ViewModel structures its internal observables—we care that it exposes the right state and handles commands correctly. This keeps tests resilient to refactoring.

---

## Key Takeaways

State management in framework-agnostic ViewModels isn't about choosing the right library—it's about establishing clear patterns:

**Single source of truth**: Domain state flows from repositories. The ViewModel doesn't cache it—it exposes it through observables that views subscribe to.

**Composed state**: Build complex state by combining simpler streams with RxJS operators. Use `combineLatest`, `map`, and `distinctUntilChanged` to create derived state that updates automatically.

**Transient state**: Not everything needs to be an observable. Use simple properties for short-lived, synchronous state like form validation errors.

**Commands over mutations**: Modify state through command methods that encapsulate preconditions, error handling, and side effects. Never expose state subjects directly to views.

**Optimistic updates**: Layer pending changes on top of server state for responsive UIs. Track failures separately and give users retry and discard options.

**Test behavior**: Verify that your ViewModels expose the right state and handle commands correctly. Don't test implementation details like internal subject structures.

In the next chapter, we'll tackle a different challenge: how to handle navigation and routing in a framework-agnostic way. Navigation state is particularly tricky because it's shared across your entire application, yet different frameworks handle it with completely different APIs. We'll build abstractions that work everywhere.
