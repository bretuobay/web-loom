---
id: "domain-events-and-cross-context-communication"
title: Domain Events & Cross-Context Communication
section: Framework-Agnostic Core
---

# Chapter 5: Domain Events & Cross-Context Communication

When you're building modular applications with clear boundaries between contexts, you'll inevitably face a critical challenge: how do you let different parts of your system talk to each other without creating tight coupling? The answer lies in **domain events**—a pattern that's been around for decades but becomes absolutely essential when you're serious about maintaining architectural boundaries.

In this chapter, we'll explore how domain events enable communication between bounded contexts while preserving the isolation we've worked so hard to achieve. We're not talking about DOM events or simple pub-sub patterns here. We're talking about a structured approach to capturing significant business occurrences and propagating them through your system in a way that respects context boundaries and maintains your application's integrity.

## 5.1 The Communication Problem

Let's revisit our GreenWatch greenhouse monitoring system. We've established six bounded contexts:

- **Device Management** handles sensor registration and lifecycle
- **Environmental Monitoring** tracks real-time readings
- **Alert & Notification** manages threshold violations and user notifications
- **Analytics** processes historical data and trends
- **Greenhouse Configuration** maintains settings and thresholds
- **Identity & Access** controls authentication and permissions

Here's the problem: these contexts need to react to each other's state changes, but they shouldn't depend on each other's implementation details. When a sensor registers in Device Management, Environmental Monitoring needs to know about it. When a temperature reading exceeds a threshold in Environmental Monitoring, the Alert & Notification context must respond. When an alert fires, Analytics should record it for trend analysis.

You might be tempted to solve this by having one context directly call methods on another:

```typescript
// ❌ DON'T DO THIS
class SensorRegistrationService {
  constructor(
    private sensorRepository: SensorRepository,
    private monitoringService: MonitoringService, // Direct dependency
    private analyticsService: AnalyticsService // Another direct dependency
  ) {}

  async registerSensor(data: SensorRegistrationData): Promise<Sensor> {
    const sensor = await this.sensorRepository.save(data);

    // Now we're tightly coupled to other contexts
    await this.monitoringService.startMonitoring(sensor);
    await this.analyticsService.recordSensorActivation(sensor);

    return sensor;
  }
}
```

This approach creates several problems:

1. **Tight Coupling**: Device Management now depends on the internal APIs of Environmental Monitoring and Analytics. If those contexts change their interfaces, Device Management breaks.

2. **Transaction Complexity**: What happens if `startMonitoring` succeeds but `recordSensorActivation` fails? You're now managing distributed transactions across contexts.

3. **Context Bleeding**: Device Management is now making decisions about what should happen in other contexts. That's not its job—it should focus solely on device lifecycle management.

4. **Testing Nightmare**: To test sensor registration, you now need to mock out both monitoring and analytics services. Your unit tests become integration tests by necessity.

5. **Scalability Issues**: As your system grows and more contexts need to react to sensor registration, this method becomes unwieldy. You'd need to inject and call services from every interested context.

We need a better approach—one that lets contexts communicate without knowing about each other.

## 5.2 Domain Events as Integration Points

A **domain event** represents something significant that happened in your business domain. It's past tense: `SensorRegistered`, `ThresholdExceeded`, `AlertAcknowledged`. These aren't requests for action; they're statements of fact about things that have already occurred.

Domain events serve as **integration points** between bounded contexts. Instead of one context calling another directly, it publishes an event describing what happened. Other contexts subscribe to events they care about and react accordingly. The publisher doesn't know or care who's listening—it just states what occurred.

This pattern gives us several crucial benefits:

**Decoupling**: Contexts don't depend on each other's internal APIs. They only depend on shared event contracts, which are far more stable than implementation details.

**Flexibility**: Adding new reactions to an event doesn't require changing the publisher. If a new context needs to react to sensor registration, it just subscribes to the `SensorRegistered` event.

**Auditability**: Events create a natural audit log of everything that's happened in your system. You can replay events to understand system behavior or reconstruct state.

**Temporal Decoupling**: Event subscribers don't need to be available when the event is published. You can queue events and process them asynchronously, which improves resilience and scalability.

Let's see how this works in practice:

```typescript
// Domain event representing a completed business action
interface SensorRegistered {
  readonly type: "SensorRegistered";
  readonly occurredAt: Date;
  readonly sensorId: string;
  readonly greenhouseId: string;
  readonly sensorType: "temperature" | "humidity" | "soil_moisture" | "light";
  readonly location: {
    zone: string;
    position: { x: number; y: number; z: number };
  };
}

// The registration service only cares about its own context
class SensorRegistrationService {
  constructor(
    private sensorRepository: SensorRepository,
    private eventBus: EventBus // Generic event infrastructure
  ) {}

  async registerSensor(data: SensorRegistrationData): Promise<Sensor> {
    const sensor = await this.sensorRepository.save(data);

    // Publish what happened—we don't care who's listening
    await this.eventBus.publish<SensorRegistered>({
      type: "SensorRegistered",
      occurredAt: new Date(),
      sensorId: sensor.id,
      greenhouseId: sensor.greenhouseId,
      sensorType: sensor.type,
      location: sensor.location,
    });

    return sensor;
  }
}
```

Now other contexts can react independently:

```typescript
// Environmental Monitoring context subscribes to sensor events
class MonitoringEventHandler {
  constructor(
    private monitoringCoordinator: MonitoringCoordinator,
    eventBus: EventBus
  ) {
    eventBus.subscribe<SensorRegistered>(
      "SensorRegistered",
      this.handleSensorRegistered.bind(this)
    );
  }

  private async handleSensorRegistered(event: SensorRegistered): Promise<void> {
    // Start monitoring this new sensor
    await this.monitoringCoordinator.initializeMonitoring({
      sensorId: event.sensorId,
      greenhouseId: event.greenhouseId,
      sensorType: event.sensorType,
    });
  }
}

// Analytics context also subscribes independently
class AnalyticsEventHandler {
  constructor(
    private analyticsService: AnalyticsService,
    eventBus: EventBus
  ) {
    eventBus.subscribe<SensorRegistered>(
      "SensorRegistered",
      this.handleSensorRegistered.bind(this)
    );
  }

  private async handleSensorRegistered(event: SensorRegistered): Promise<void> {
    // Record activation in analytics
    await this.analyticsService.recordSensorActivation({
      sensorId: event.sensorId,
      activatedAt: event.occurredAt,
      greenhouseId: event.greenhouseId,
    });
  }
}
```

Notice what we've achieved here. Device Management publishes `SensorRegistered` and moves on—it doesn't wait for responses or manage coordination. Environmental Monitoring and Analytics each handle the event independently. If Analytics fails, it doesn't affect Monitoring. If we add a new Maintenance context that needs to track sensor warranties, we just subscribe it to `SensorRegistered`—no changes to Device Management required.

This is the power of event-driven integration: we've maintained strict context boundaries while enabling necessary cross-context reactions.

## 5.3 Designing Effective Domain Events

Not all events are created equal. A poorly designed event can create just as much coupling as a direct method call—it'll just be harder to detect. Let's establish principles for designing events that actually maintain your architectural boundaries.

### 5.3.1 Events Are Immutable Facts

An event represents something that already happened. Once published, it can't be changed—history doesn't change. This immutability is crucial for system reliability and auditability.

```typescript
// ✅ Immutable event with readonly properties
interface ThresholdExceeded {
  readonly type: "ThresholdExceeded";
  readonly occurredAt: Date;
  readonly sensorId: string;
  readonly measurementType: "temperature" | "humidity" | "soil_moisture";
  readonly value: number;
  readonly threshold: number;
  readonly severity: "warning" | "critical";
}

// ❌ Mutable event—dangerous and confusing
interface ThresholdExceeded {
  type: "ThresholdExceeded";
  occurredAt: Date;
  sensorId: string;
  value: number; // Could be changed after publishing
  threshold: number;
  handled?: boolean; // State that changes over time—doesn't belong here
}
```

If you find yourself wanting to modify an event after it's published, you're probably confusing events with commands or state. Instead, publish a new event that describes what happened next.

### 5.3.2 Include Essential Context, Not Implementation Details

Events should contain enough information for subscribers to react without querying back to the publisher. However, they shouldn't expose internal implementation details of the publishing context.

```typescript
// ✅ Appropriate level of detail
interface AlertAcknowledged {
  readonly type: "AlertAcknowledged";
  readonly occurredAt: Date;
  readonly alertId: string;
  readonly acknowledgedBy: string;
  readonly notes?: string;
  readonly originalAlert: {
    type: string;
    severity: "warning" | "critical";
    triggeredAt: Date;
  };
}

// ❌ Too much internal detail
interface AlertAcknowledged {
  readonly type: "AlertAcknowledged";
  readonly occurredAt: Date;
  readonly alertId: string;
  readonly acknowledgedBy: string;
  readonly notes?: string;
  readonly internalAlertState: AlertState; // Internal domain object leaked
  readonly databaseRow: AlertRow; // Persistence detail leaked
  readonly validationRules: ValidationRule[]; // Business logic leaked
}

// ❌ Too little information
interface AlertAcknowledged {
  readonly type: "AlertAcknowledged";
  readonly alertId: string;
  // Subscribers would need to query back to get any useful information
}
```

The key is to include what subscribers need to make decisions without coupling them to your internal data structures. Think about the **public interface** of your context—events are part of that interface.

### 5.3.3 Use Domain Language, Not Technical Language

Events should be named and structured using your **ubiquitous language**—the shared vocabulary of your business domain. They describe business occurrences, not technical operations.

```typescript
// ✅ Domain-focused events
interface SensorCalibrated {
  readonly type: "SensorCalibrated";
  readonly sensorId: string;
  readonly calibratedAt: Date;
  readonly previousAccuracy: number;
  readonly newAccuracy: number;
}

interface IrrigationScheduleActivated {
  readonly type: "IrrigationScheduleActivated";
  readonly scheduleId: string;
  readonly greenhouseId: string;
  readonly startTime: Date;
  readonly estimatedDuration: number;
  readonly zones: string[];
}

// ❌ Technical implementation events
interface DatabaseRecordUpdated {
  readonly type: "DatabaseRecordUpdated";
  readonly table: string;
  readonly rowId: string;
  readonly changedColumns: string[];
}

interface CacheInvalidated {
  readonly type: "CacheInvalidated";
  readonly cacheKey: string;
  readonly timestamp: Date;
}
```

The business-focused events communicate intent and meaning. The technical events expose implementation details that subscribers shouldn't care about. If you find yourself publishing events like `CacheInvalidated` or `DatabaseRecordUpdated`, you're working at the wrong abstraction level.

### 5.3.4 Granularity Matters

Finding the right level of event granularity is an art. Too fine-grained, and you overwhelm subscribers with noise. Too coarse-grained, and subscribers can't react precisely to what they care about.

```typescript
// ❌ Too fine-grained—too much noise
interface SensorFieldUpdated {
  readonly type: "SensorFieldUpdated";
  readonly sensorId: string;
  readonly fieldName: string;
  readonly oldValue: unknown;
  readonly newValue: unknown;
}
// This would fire dozens of times during a sensor update

// ❌ Too coarse-grained—not enough information
interface SensorChanged {
  readonly type: "SensorChanged";
  readonly sensorId: string;
}
// What changed? Subscribers can't tell.

// ✅ Right level of granularity
interface SensorRelocated {
  readonly type: "SensorRelocated";
  readonly sensorId: string;
  readonly relocatedAt: Date;
  readonly previousLocation: { zone: string; position: Position };
  readonly newLocation: { zone: string; position: Position };
}

interface SensorThresholdsUpdated {
  readonly type: "SensorThresholdsUpdated";
  readonly sensorId: string;
  readonly updatedAt: Date;
  readonly thresholds: {
    warning: number;
    critical: number;
  };
}
```

The right granularity maps to **meaningful business occurrences**. Sensor relocation is a distinct business event that other contexts care about differently than threshold updates. Model events around the decisions subscribers need to make.

## 5.4 Implementing an Event Bus

Now that we understand what domain events are and how to design them, let's build the infrastructure to publish and subscribe to them. We need an **event bus**—a central mechanism for routing events from publishers to subscribers.

Our event bus must handle several concerns:

- **Type Safety**: Subscribers should only receive events they're designed to handle
- **Error Isolation**: A failing subscriber shouldn't crash other subscribers or the publisher
- **Async Execution**: Event handling should be non-blocking
- **Subscription Management**: Clean subscription and unsubscription lifecycle

Here's a robust, TypeScript-based implementation:

```typescript
// Base type all domain events must extend
interface DomainEvent {
  readonly type: string;
  readonly occurredAt: Date;
}

// Handler function signature
type EventHandler<T extends DomainEvent> = (event: T) => Promise<void> | void;

// Subscription token for unsubscribing
interface Subscription {
  unsubscribe(): void;
}

class EventBus {
  private handlers = new Map<string, Set<EventHandler<any>>>();
  private isProcessing = false;
  private eventQueue: Array<{
    event: DomainEvent;
    handlers: Set<EventHandler<any>>;
  }> = [];

  /**
   * Subscribe to events of a specific type.
   * Returns a subscription that can be used to unsubscribe.
   */
  subscribe<T extends DomainEvent>(
    eventType: string,
    handler: EventHandler<T>
  ): Subscription {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, new Set());
    }

    const handlerSet = this.handlers.get(eventType)!;
    handlerSet.add(handler);

    return {
      unsubscribe: () => {
        handlerSet.delete(handler);
        if (handlerSet.size === 0) {
          this.handlers.delete(eventType);
        }
      },
    };
  }

  /**
   * Publish an event to all subscribed handlers.
   * Handlers execute asynchronously and independently—
   * one handler's failure doesn't affect others.
   */
  async publish<T extends DomainEvent>(event: T): Promise<void> {
    const handlers = this.handlers.get(event.type);

    if (!handlers || handlers.size === 0) {
      // No subscribers—this is fine, events can be published even if no one's listening
      return;
    }

    // Queue the event if we're already processing
    if (this.isProcessing) {
      this.eventQueue.push({ event, handlers: new Set(handlers) });
      return;
    }

    await this.processEvent(event, handlers);
    await this.processQueue();
  }

  private async processEvent(
    event: DomainEvent,
    handlers: Set<EventHandler<any>>
  ): Promise<void> {
    this.isProcessing = true;

    // Execute all handlers in parallel—they're independent reactions
    const handlerPromises = Array.from(handlers).map((handler) =>
      this.safeExecute(handler, event)
    );

    await Promise.allSettled(handlerPromises);
  }

  private async processQueue(): Promise<void> {
    while (this.eventQueue.length > 0) {
      const { event, handlers } = this.eventQueue.shift()!;
      await this.processEvent(event, handlers);
    }

    this.isProcessing = false;
  }

  /**
   * Execute handler with error isolation—one handler's
   * failure shouldn't crash others or the publisher.
   */
  private async safeExecute<T extends DomainEvent>(
    handler: EventHandler<T>,
    event: T
  ): Promise<void> {
    try {
      await handler(event);
    } catch (error) {
      // Log the error but don't propagate it
      console.error(`Error handling event ${event.type}:`, error);
      // In production, you'd send this to your error tracking service
    }
  }

  /**
   * Clear all subscriptions—useful for testing and cleanup.
   */
  clear(): void {
    this.handlers.clear();
    this.eventQueue = [];
  }
}
```

Let's break down why this implementation works:

**Type Safety**: The generic `subscribe` and `publish` methods ensure that TypeScript can verify event types at compile time. You can't accidentally subscribe a handler to the wrong event type.

**Error Isolation**: The `safeExecute` method wraps each handler in a try-catch block. If one subscriber throws an error, others still execute. The publisher isn't affected by subscriber failures.

**Queue Management**: The `isProcessing` flag and event queue prevent recursive publishing. If a handler publishes an event while we're processing another event, we queue it and process it after current handlers complete. This prevents stack overflow and makes event flow predictable.

**Parallel Execution**: Handlers execute in parallel via `Promise.allSettled`. Since they're independent reactions, there's no reason to serialize them. This improves throughput when multiple contexts react to the same event.

**Clean Lifecycle**: The `Subscription` return value provides a clean way to unsubscribe. This is essential for avoiding memory leaks in long-running applications.

Here's how you'd use this in practice:

```typescript
// Create a singleton event bus for your application
const eventBus = new EventBus();

// Subscribe in context initialization
class MonitoringContext {
  private subscriptions: Subscription[] = [];

  initialize(): void {
    // Subscribe to relevant events
    this.subscriptions.push(
      eventBus.subscribe<SensorRegistered>(
        "SensorRegistered",
        this.handleSensorRegistered.bind(this)
      )
    );

    this.subscriptions.push(
      eventBus.subscribe<SensorDecommissioned>(
        "SensorDecommissioned",
        this.handleSensorDecommissioned.bind(this)
      )
    );
  }

  private async handleSensorRegistered(event: SensorRegistered): Promise<void> {
    // React to new sensor...
  }

  private async handleSensorDecommissioned(
    event: SensorDecommissioned
  ): Promise<void> {
    // Clean up monitoring...
  }

  dispose(): void {
    // Clean up subscriptions
    this.subscriptions.forEach((sub) => sub.unsubscribe());
    this.subscriptions = [];
  }
}
```

## 5.5 Event-Driven ViewModel Communication

Domain events aren't just for backend service communication—they're equally valuable for coordinating ViewModels in your presentation layer. When you have multiple ViewModels on a page that need to stay synchronized, events provide a clean mechanism without introducing ViewModel-to-ViewModel dependencies.

Consider a typical greenhouse monitoring dashboard with multiple panels:

- **Sensor List Panel**: Displays all sensors and their current status
- **Real-Time Readings Panel**: Shows live data from a selected sensor
- **Alert Panel**: Displays active alerts
- **Control Panel**: Allows threshold adjustments

These panels need to coordinate. When you select a sensor in the list, the readings panel should update. When you modify a threshold in the control panel, the alert panel should reflect potential changes. When an alert fires, the sensor list should highlight the affected sensor.

You could handle this with direct ViewModel references:

```typescript
// ❌ Tight coupling between ViewModels
class SensorListViewModel {
  constructor(
    private readingsViewModel: ReadingsViewModel, // Direct dependency
    private alertViewModel: AlertViewModel // Another dependency
  ) {}

  selectSensor(sensorId: string): void {
    this.selectedSensorId = sensorId;

    // Directly manipulate other ViewModels
    this.readingsViewModel.loadSensor(sensorId);
    this.alertViewModel.filterBySensor(sensorId);
  }
}
```

But this creates the same problems we saw with service-to-service communication. The ViewModels become tightly coupled, testing becomes harder, and adding new panels that need to react requires modifying existing ViewModels.

Instead, let's use events:

```typescript
// UI events represent user actions or view state changes
interface SensorSelected {
  readonly type: "SensorSelected";
  readonly sensorId: string;
  readonly selectedAt: Date;
}

interface ThresholdAdjusted {
  readonly type: "ThresholdAdjusted";
  readonly sensorId: string;
  readonly thresholdType: "warning" | "critical";
  readonly oldValue: number;
  readonly newValue: number;
}

class SensorListViewModel {
  private selectedSensorId$ = new BehaviorSubject<string | null>(null);

  constructor(
    private sensorService: SensorService,
    private eventBus: EventBus
  ) {
    // No dependencies on other ViewModels
  }

  selectSensor(sensorId: string): void {
    this.selectedSensorId$.next(sensorId);

    // Publish the selection—we don't care who's listening
    this.eventBus.publish<SensorSelected>({
      type: "SensorSelected",
      sensorId,
      selectedAt: new Date(),
    });
  }

  get selectedSensor$(): Observable<string | null> {
    return this.selectedSensorId$.asObservable();
  }
}

class ReadingsViewModel {
  private currentSensorId$ = new BehaviorSubject<string | null>(null);
  private readings$ = new BehaviorSubject<SensorReading[]>([]);

  constructor(
    private readingsService: ReadingsService,
    eventBus: EventBus
  ) {
    // Subscribe to sensor selection events
    eventBus.subscribe<SensorSelected>(
      "SensorSelected",
      this.handleSensorSelected.bind(this)
    );

    // Load readings whenever current sensor changes
    this.currentSensorId$
      .pipe(
        filter((id) => id !== null),
        switchMap((id) => this.readingsService.getRealtimeReadings(id!))
      )
      .subscribe((readings) => this.readings$.next(readings));
  }

  private handleSensorSelected(event: SensorSelected): void {
    this.currentSensorId$.next(event.sensorId);
  }

  get readings$(): Observable<SensorReading[]> {
    return this.readings$.asObservable();
  }
}

class AlertViewModel {
  private activeAlerts$ = new BehaviorSubject<Alert[]>([]);
  private filteredAlerts$ = new BehaviorSubject<Alert[]>([]);
  private filterSensorId: string | null = null;

  constructor(
    private alertService: AlertService,
    eventBus: EventBus
  ) {
    eventBus.subscribe<SensorSelected>(
      "SensorSelected",
      this.handleSensorSelected.bind(this)
    );

    eventBus.subscribe<ThresholdAdjusted>(
      "ThresholdAdjusted",
      this.handleThresholdAdjusted.bind(this)
    );

    // Load all active alerts
    this.alertService.getActiveAlerts().subscribe((alerts) => {
      this.activeAlerts$.next(alerts);
      this.updateFilteredAlerts();
    });
  }

  private handleSensorSelected(event: SensorSelected): void {
    this.filterSensorId = event.sensorId;
    this.updateFilteredAlerts();
  }

  private handleThresholdAdjusted(event: ThresholdAdjusted): void {
    // Refresh alerts since thresholds changed
    this.alertService.getActiveAlerts().subscribe((alerts) => {
      this.activeAlerts$.next(alerts);
      this.updateFilteredAlerts();
    });
  }

  private updateFilteredAlerts(): void {
    const alerts = this.activeAlerts$.value;
    const filtered = this.filterSensorId
      ? alerts.filter((a) => a.sensorId === this.filterSensorId)
      : alerts;

    this.filteredAlerts$.next(filtered);
  }

  get filteredAlerts$(): Observable<Alert[]> {
    return this.filteredAlerts$.asObservable();
  }
}
```

Each ViewModel now operates independently. They publish events when their state changes and subscribe to events they care about. Adding a new HistoryViewModel that needs to react to sensor selection doesn't require changing any existing code—it just subscribes to `SensorSelected`.

This event-driven coordination brings the same benefits to your UI layer that it brings to your service layer: loose coupling, independent testability, and easy extensibility.

## 5.6 Event Versioning and Evolution

Your application will evolve. Business requirements change, you'll discover better ways to model your domain, and new features will emerge. When you're using events for integration, you need a strategy for evolving event contracts without breaking existing subscribers.

This isn't a theoretical concern—it's a practical reality you'll face within months of launching your application. Let's look at strategies for managing event evolution.

### 5.6.1 Additive Changes Are Safe

Adding optional fields to an event doesn't break existing subscribers—they'll simply ignore fields they don't know about:

```typescript
// Original version
interface SensorRegistered {
  readonly type: "SensorRegistered";
  readonly occurredAt: Date;
  readonly sensorId: string;
  readonly greenhouseId: string;
  readonly sensorType: "temperature" | "humidity" | "soil_moisture";
}

// Evolved version—added optional warranty field
interface SensorRegistered {
  readonly type: "SensorRegistered";
  readonly occurredAt: Date;
  readonly sensorId: string;
  readonly greenhouseId: string;
  readonly sensorType: "temperature" | "humidity" | "soil_moisture";
  readonly warrantyInfo?: {
    // New optional field
    expiresAt: Date;
    provider: string;
  };
}
```

Old subscribers continue working—they don't reference `warrantyInfo`. New subscribers can access it when needed. This is the safest form of evolution.

### 5.6.2 Breaking Changes Require New Event Types

If you need to make a breaking change—removing a field, changing its type, or restructuring the event—create a new event type:

```typescript
// Old version
interface ThresholdExceeded {
  readonly type: "ThresholdExceeded";
  readonly occurredAt: Date;
  readonly sensorId: string;
  readonly value: number;
  readonly threshold: number;
}

// New version with breaking changes—different structure for thresholds
interface ThresholdExceededV2 {
  readonly type: "ThresholdExceededV2"; // Different type name
  readonly occurredAt: Date;
  readonly sensorId: string;
  readonly measurement: {
    value: number;
    unit: string;
  };
  readonly thresholds: {
    // Structured differently
    warning: number;
    critical: number;
  };
  readonly exceededLevel: "warning" | "critical";
}
```

Now publish both events during a transition period:

```typescript
class EnvironmentalMonitoringService {
  async checkThreshold(reading: SensorReading): Promise<void> {
    if (reading.value > reading.threshold) {
      // Publish old version for backward compatibility
      await this.eventBus.publish<ThresholdExceeded>({
        type: "ThresholdExceeded",
        occurredAt: new Date(),
        sensorId: reading.sensorId,
        value: reading.value,
        threshold: reading.threshold,
      });

      // Publish new version for new subscribers
      await this.eventBus.publish<ThresholdExceededV2>({
        type: "ThresholdExceededV2",
        occurredAt: new Date(),
        sensorId: reading.sensorId,
        measurement: {
          value: reading.value,
          unit: reading.unit,
        },
        thresholds: {
          warning: reading.warningThreshold,
          critical: reading.criticalThreshold,
        },
        exceededLevel:
          reading.value > reading.criticalThreshold ? "critical" : "warning",
      });
    }
  }
}
```

Old subscribers keep working with `ThresholdExceeded`. New subscribers use `ThresholdExceededV2`. You migrate subscribers at your own pace and eventually deprecate the old event.

### 5.6.3 Schema Versioning with Type Discriminators

For complex applications, embed version information directly in events:

```typescript
interface BaseEvent {
  readonly type: string;
  readonly version: number;
  readonly occurredAt: Date;
}

interface SensorRegisteredV1 extends BaseEvent {
  readonly type: "SensorRegistered";
  readonly version: 1;
  readonly sensorId: string;
  readonly greenhouseId: string;
}

interface SensorRegisteredV2 extends BaseEvent {
  readonly type: "SensorRegistered";
  readonly version: 2;
  readonly sensorId: string;
  readonly greenhouseId: string;
  readonly warrantyInfo: {
    expiresAt: Date;
    provider: string;
  };
  readonly installationDetails: {
    installedBy: string;
    installedAt: Date;
  };
}

type SensorRegistered = SensorRegisteredV1 | SensorRegisteredV2;
```

Subscribers can handle multiple versions:

```typescript
class MonitoringEventHandler {
  private async handleSensorRegistered(event: SensorRegistered): Promise<void> {
    // Handle common fields
    const baseInfo = {
      sensorId: event.sensorId,
      greenhouseId: event.greenhouseId,
    };

    // Type-safe version handling
    if (event.version === 2) {
      // Access V2-specific fields
      await this.recordInstallation({
        ...baseInfo,
        installedBy: event.installationDetails.installedBy,
        installedAt: event.installationDetails.installedAt,
      });
    }

    // Continue with monitoring initialization
    await this.monitoringCoordinator.initializeMonitoring(baseInfo);
  }
}
```

TypeScript's discriminated unions ensure type safety. The compiler knows which fields are available based on the version check.

## 5.7 Testing Event-Driven Systems

Event-driven architecture changes how you approach testing. You're no longer testing direct method calls between components—you're testing event publishing and subscription behavior. Let's look at effective testing strategies.

### 5.7.1 Testing Event Publishers

When testing a service that publishes events, you need to verify that:

1. Events are published when expected
2. Events contain correct data
3. Events are published even if no subscribers exist (no exceptions thrown)

```typescript
describe("SensorRegistrationService", () => {
  let service: SensorRegistrationService;
  let mockRepository: jest.Mocked<SensorRepository>;
  let mockEventBus: jest.Mocked<EventBus>;

  beforeEach(() => {
    mockRepository = {
      save: jest.fn(),
    } as any;

    mockEventBus = {
      publish: jest.fn().mockResolvedValue(undefined),
    } as any;

    service = new SensorRegistrationService(mockRepository, mockEventBus);
  });

  it("publishes SensorRegistered event after successful registration", async () => {
    // Arrange
    const registrationData = {
      greenhouseId: "gh-1",
      sensorType: "temperature" as const,
      location: { zone: "A", position: { x: 1, y: 2, z: 3 } },
    };

    const savedSensor = {
      id: "sensor-123",
      ...registrationData,
    };

    mockRepository.save.mockResolvedValue(savedSensor);

    // Act
    await service.registerSensor(registrationData);

    // Assert
    expect(mockEventBus.publish).toHaveBeenCalledTimes(1);
    expect(mockEventBus.publish).toHaveBeenCalledWith({
      type: "SensorRegistered",
      occurredAt: expect.any(Date),
      sensorId: "sensor-123",
      greenhouseId: "gh-1",
      sensorType: "temperature",
      location: registrationData.location,
    });
  });

  it("does not publish event if save fails", async () => {
    // Arrange
    mockRepository.save.mockRejectedValue(new Error("Database error"));

    // Act & Assert
    await expect(service.registerSensor({} as any)).rejects.toThrow(
      "Database error"
    );

    expect(mockEventBus.publish).not.toHaveBeenCalled();
  });
});
```

The key insight here is that we're testing the contract between the service and the event bus, not the actual event propagation. That's the event bus's responsibility.

### 5.7.2 Testing Event Subscribers

When testing subscribers, you need to verify that they handle events correctly without actually going through the event bus:

```typescript
describe("MonitoringEventHandler", () => {
  let handler: MonitoringEventHandler;
  let mockCoordinator: jest.Mocked<MonitoringCoordinator>;

  beforeEach(() => {
    mockCoordinator = {
      initializeMonitoring: jest.fn().mockResolvedValue(undefined),
    } as any;

    // Create handler without connecting to real event bus
    handler = new MonitoringEventHandler(mockCoordinator);
  });

  it("initializes monitoring when SensorRegistered event received", async () => {
    // Arrange
    const event: SensorRegistered = {
      type: "SensorRegistered",
      occurredAt: new Date(),
      sensorId: "sensor-123",
      greenhouseId: "gh-1",
      sensorType: "temperature",
      location: { zone: "A", position: { x: 1, y: 2, z: 3 } },
    };

    // Act—call the handler method directly
    await handler["handleSensorRegistered"](event);

    // Assert
    expect(mockCoordinator.initializeMonitoring).toHaveBeenCalledWith({
      sensorId: "sensor-123",
      greenhouseId: "gh-1",
      sensorType: "temperature",
    });
  });

  it("handles errors gracefully without crashing", async () => {
    // Arrange
    mockCoordinator.initializeMonitoring.mockRejectedValue(
      new Error("Initialization failed")
    );

    const event: SensorRegistered = {
      type: "SensorRegistered",
      occurredAt: new Date(),
      sensorId: "sensor-123",
      greenhouseId: "gh-1",
      sensorType: "temperature",
      location: { zone: "A", position: { x: 1, y: 2, z: 3 } },
    };

    // Act & Assert—should not throw
    await expect(
      handler["handleSensorRegistered"](event)
    ).resolves.not.toThrow();
  });
});
```

We're testing the handler logic in isolation. The event bus's responsibility to route events is tested separately.

### 5.7.3 Integration Testing Event Flow

Unit tests verify individual components, but you also need integration tests that verify the complete event flow from publisher to subscriber:

```typescript
describe("Sensor Registration Event Flow", () => {
  let eventBus: EventBus;
  let registrationService: SensorRegistrationService;
  let monitoringHandler: MonitoringEventHandler;
  let analyticsHandler: AnalyticsEventHandler;

  let receivedEvents: DomainEvent[] = [];

  beforeEach(() => {
    receivedEvents = [];
    eventBus = new EventBus();

    // Set up real services with real event bus
    registrationService = new SensorRegistrationService(
      createMockRepository(),
      eventBus
    );

    monitoringHandler = new MonitoringEventHandler(
      createMockMonitoringCoordinator(),
      eventBus
    );

    analyticsHandler = new AnalyticsEventHandler(
      createMockAnalyticsService(),
      eventBus
    );

    // Spy on all events
    eventBus.subscribe("SensorRegistered", (event) => {
      receivedEvents.push(event);
    });
  });

  it("propagates SensorRegistered event to all subscribers", async () => {
    // Act
    await registrationService.registerSensor({
      greenhouseId: "gh-1",
      sensorType: "temperature",
      location: { zone: "A", position: { x: 1, y: 2, z: 3 } },
    });

    // Wait for async handlers
    await waitForCondition(() => receivedEvents.length > 0);

    // Assert
    expect(receivedEvents).toHaveLength(1);
    expect(receivedEvents[0].type).toBe("SensorRegistered");

    // Verify both handlers were invoked (check their side effects)
    // This depends on your mock implementations
  });

  it("continues even if one subscriber fails", async () => {
    // Arrange—make monitoring handler fail
    const failingHandler = new MonitoringEventHandler(
      createFailingMockCoordinator(),
      eventBus
    );

    // Act
    await registrationService.registerSensor({
      greenhouseId: "gh-1",
      sensorType: "temperature",
      location: { zone: "A", position: { x: 1, y: 2, z: 3 } },
    });

    await waitForCondition(() => receivedEvents.length > 0);

    // Assert—event was still published and received
    expect(receivedEvents).toHaveLength(1);

    // Analytics handler should still have been called successfully
    // (verify its side effects)
  });
});
```

These integration tests verify that the complete event infrastructure works correctly, including error isolation and async execution.

## 5.8 Advanced Patterns: Event Sourcing

We've covered the fundamentals of domain events for cross-context communication. Now let's look at a more advanced pattern: **event sourcing**, where events become your primary source of truth rather than just integration notifications.

In traditional systems, you store current state in a database. If a sensor's current temperature is 22°C, that's what you save. The history of how it got there is lost unless you explicitly build audit logs.

Event sourcing flips this around. Instead of storing current state, you store the **sequence of events** that led to that state. The current state is derived by replaying events.

For GreenWatch's Environmental Monitoring context, this might look like:

```typescript
// Event stream for a specific sensor
const sensorEvents = [
  {
    type: "SensorReadingRecorded",
    sensorId: "sensor-123",
    temperature: 20,
    recordedAt: "2025-11-07T08:00:00Z",
  },
  {
    type: "SensorReadingRecorded",
    sensorId: "sensor-123",
    temperature: 21,
    recordedAt: "2025-11-07T08:15:00Z",
  },
  {
    type: "SensorReadingRecorded",
    sensorId: "sensor-123",
    temperature: 22,
    recordedAt: "2025-11-07T08:30:00Z",
  },
];

// Current state is computed by replaying events
function computeCurrentState(events: SensorEvent[]): SensorState {
  let state: SensorState = { readings: [], currentValue: null };

  for (const event of events) {
    if (event.type === "SensorReadingRecorded") {
      state.readings.push({
        value: event.temperature,
        recordedAt: new Date(event.recordedAt),
      });
      state.currentValue = event.temperature;
    }
  }

  return state;
}
```

This approach offers several compelling advantages:

**Complete Audit Trail**: Every state change is preserved. You can answer questions like "What was the temperature at 8:15 AM on November 5th?" by replaying events up to that point.

**Time Travel Debugging**: When investigating a bug, you can replay events to see exactly how the system arrived at a particular state. No more guessing about what happened.

**Flexible Projections**: You can create multiple views of the same data by replaying events differently. One projection might show hourly averages, another might flag anomalies, another might compute trends.

**Event-Driven Analytics**: Your analytics context can subscribe to events and build its own projections without querying the operational database.

Here's a practical implementation for GreenWatch:

```typescript
interface SensorEvent {
  readonly type: string;
  readonly sensorId: string;
  readonly occurredAt: Date;
  readonly sequence: number; // Event order within this sensor's stream
}

interface SensorReadingRecorded extends SensorEvent {
  readonly type: "SensorReadingRecorded";
  readonly measurementType: "temperature" | "humidity" | "soil_moisture";
  readonly value: number;
  readonly unit: string;
}

interface SensorCalibrated extends SensorEvent {
  readonly type: "SensorCalibrated";
  readonly previousAccuracy: number;
  readonly newAccuracy: number;
  readonly calibratedBy: string;
}

// Event store interface
interface EventStore {
  append(sensorId: string, event: SensorEvent): Promise<void>;
  getEvents(sensorId: string, fromSequence?: number): Promise<SensorEvent[]>;
  getAllEvents(fromSequence?: number): Promise<SensorEvent[]>;
}

// Simple in-memory implementation (in production, use a real event store)
class InMemoryEventStore implements EventStore {
  private events = new Map<string, SensorEvent[]>();
  private globalSequence = 0;

  async append(sensorId: string, event: SensorEvent): Promise<void> {
    if (!this.events.has(sensorId)) {
      this.events.set(sensorId, []);
    }

    const stream = this.events.get(sensorId)!;

    // Ensure event has correct sequence number
    const eventWithSequence = {
      ...event,
      sequence: stream.length,
      globalSequence: this.globalSequence++,
    };

    stream.push(eventWithSequence);
  }

  async getEvents(sensorId: string, fromSequence = 0): Promise<SensorEvent[]> {
    const stream = this.events.get(sensorId) || [];
    return stream.filter((e) => e.sequence >= fromSequence);
  }

  async getAllEvents(fromSequence = 0): Promise<SensorEvent[]> {
    const allEvents: SensorEvent[] = [];

    for (const stream of this.events.values()) {
      allEvents.push(...stream);
    }

    return allEvents
      .sort((a, b) => (a as any).globalSequence - (b as any).globalSequence)
      .filter((e) => (e as any).globalSequence >= fromSequence);
  }
}

// Projection builder—computes current state from events
class SensorStateProjection {
  private state: Map<string, SensorCurrentState> = new Map();

  constructor(private eventStore: EventStore) {}

  async rebuild(): Promise<void> {
    this.state.clear();
    const events = await this.eventStore.getAllEvents();

    for (const event of events) {
      this.apply(event);
    }
  }

  async getCurrentState(sensorId: string): Promise<SensorCurrentState | null> {
    // If we don't have it cached, rebuild from events
    if (!this.state.has(sensorId)) {
      const events = await this.eventStore.getEvents(sensorId);
      for (const event of events) {
        this.apply(event);
      }
    }

    return this.state.get(sensorId) || null;
  }

  private apply(event: SensorEvent): void {
    const currentState = this.state.get(event.sensorId) || {
      sensorId: event.sensorId,
      lastReading: null,
      accuracy: 100,
      totalReadings: 0,
      lastUpdated: event.occurredAt,
    };

    switch (event.type) {
      case "SensorReadingRecorded":
        const reading = event as SensorReadingRecorded;
        this.state.set(event.sensorId, {
          ...currentState,
          lastReading: {
            value: reading.value,
            unit: reading.unit,
            type: reading.measurementType,
            recordedAt: reading.occurredAt,
          },
          totalReadings: currentState.totalReadings + 1,
          lastUpdated: reading.occurredAt,
        });
        break;

      case "SensorCalibrated":
        const calibration = event as SensorCalibrated;
        this.state.set(event.sensorId, {
          ...currentState,
          accuracy: calibration.newAccuracy,
          lastUpdated: calibration.occurredAt,
        });
        break;
    }
  }
}
```

The beauty of this approach is that you can create multiple projections from the same event stream. Want hourly averages? Create an `HourlyAverageProjection`. Want to flag anomalies? Create an `AnomalyDetectionProjection`. Each projection rebuilds its view independently by replaying events.

**When to Use Event Sourcing**: Event sourcing isn't appropriate for every context. It adds complexity and requires careful thought about event design. Use it when:

- Audit requirements are strict (regulatory compliance, financial transactions)
- Historical analysis is a core requirement
- You need multiple views of the same data
- Debugging and troubleshooting require time-travel capabilities

For GreenWatch, event sourcing makes sense for Environmental Monitoring (we need historical data for analytics) but probably not for Identity & Access (current user state is sufficient).

## 5.9 Practical Guidelines and Trade-Offs

We've covered a lot of ground in this chapter. Let's consolidate with practical guidelines for applying these patterns effectively.

**Start Simple**: Don't event-source everything from day one. Begin with domain events for cross-context communication. Add event sourcing later if you need it.

**Event Granularity**: Model events around business occurrences, not technical operations. `SensorCalibrated` is a business event; `DatabaseRowUpdated` isn't.

**Error Handling**: Always isolate subscriber failures. One context's problems shouldn't cascade to others. Log errors comprehensively—you'll need those logs when debugging distributed behavior.

**Testing Strategy**: Unit test publishers and subscribers independently. Integration test the complete event flow. Don't over-mock—real event bus behavior matters.

**Event Versioning**: Plan for evolution from the start. Use additive changes when possible. Version-stamp events if you anticipate complex evolution.

**Performance Considerations**: Event-driven systems can have higher latency than direct calls. If you need real-time responses, consider hybrid approaches where critical paths use direct calls and events handle eventual consistency.

**Monitoring**: Instrument your event bus. Track metrics like:

- Events published per type
- Subscriber execution time
- Failed subscriptions
- Event queue depth (if using async processing)

**Documentation**: Maintain a registry of all domain events with their contracts and subscribers. This becomes your **integration map**—essential for understanding system behavior.

The patterns in this chapter give you the tools to build loosely coupled, maintainable systems. But like any architectural pattern, they're not free—they add complexity and require discipline. Use them where they provide clear value: when you need to integrate across context boundaries while maintaining modularity.

In the next chapter, we'll build on these foundations to implement our ViewModel layer, showing how domain events coordinate complex UI behavior while keeping ViewModels focused and testable.

---

**Key Takeaways**

- Domain events represent past-tense business occurrences, not commands or requests
- Events enable cross-context communication without tight coupling
- Design events with appropriate granularity, using domain language, and include essential context
- Event buses provide infrastructure for publish-subscribe patterns with error isolation
- Event-driven ViewModels coordinate UI behavior without direct dependencies
- Plan for event evolution through versioning and backward compatibility
- Event sourcing treats events as the source of truth, enabling time-travel and multiple projections
- Start simple with domain events; add complexity like event sourcing only when justified
