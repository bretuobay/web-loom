---
id: "vue-implementation-proving-framework-independence"
title: Vue Implementation – Proving Framework Independence
section: View Layer Implementations
---

# Chapter 11: Vue Implementation – Proving Framework Independence

We've built our GreenWatch ViewModels in React, demonstrating how MVVM separates business logic from presentation. Now comes the critical test: can we reuse that _exact same_ business logic in Vue? If we've architected correctly, the answer should be yes—with minimal friction.

This chapter isn't about teaching Vue fundamentals. It's about proving that framework-agnostic architecture actually works. We'll implement the same greenhouse monitoring features we built in Chapter 7, but this time using Vue's Composition API. The ViewModels won't change. The domain logic won't change. Only the view layer adapts to Vue's patterns.

If you find yourself rewriting business logic for Vue, something went wrong. Let's prove we didn't make that mistake.

## Why Vue Matters for This Book

You might wonder: why dedicate a chapter to Vue when we've already demonstrated MVVM in React? Because **one framework proves nothing**. Any architectural pattern can _claim_ framework independence. Only implementation across multiple frameworks proves it.

Vue provides an excellent validation case for several reasons:

**Different reactive primitives.** React uses hooks and immutable state updates. Vue uses reactive references and proxies. If our ViewModels work with both, they're truly framework-agnostic.

**Different component lifecycle.** React's lifecycle revolves around render cycles and effects. Vue uses explicit lifecycle hooks like `onMounted` and `onUnmounted`. Our ViewModels shouldn't care about either.

**Different template syntax.** React uses JSX. Vue uses templates with directives. Our ViewModels expose observable state that works with both approaches.

**Different developer expectations.** Vue developers expect `ref` and `reactive`. React developers expect `useState` and `useReducer`. We'll show how to meet these expectations without compromising our ViewModels.

This chapter validates our architectural investment. If the same ViewModel works seamlessly in both frameworks, we've achieved true separation of concerns.

## The Vue Composition API and MVVM

Vue 3's Composition API aligns remarkably well with MVVM principles. Unlike Vue 2's Options API, which encouraged mixing presentation logic with component configuration, the Composition API provides clean hooks for connecting ViewModels to Vue's reactivity system.

Here's what makes the Composition API ideal for MVVM:

**Explicit lifecycle management.** Functions like `onMounted` and `onUnmounted` give us clear points to initialize and dispose ViewModels—exactly what we need for managing RxJS subscriptions.

**Flexible composition.** We can encapsulate ViewModel connection logic in composables (Vue's equivalent to React hooks), making it reusable across components.

**Framework-specific reactivity without framework-dependent logic.** Vue's `ref` and `reactive` handle the presentation layer's reactivity, while our ViewModels continue using RxJS observables for business logic.

**Separation by default.** The Composition API encourages extracting logic into separate functions, which naturally aligns with keeping ViewModels outside components.

Let's see this in practice. Here's the pattern we'll use throughout this chapter:

```typescript
// composables/useViewModel.ts
import { ref, onMounted, onUnmounted } from "vue";
import { Observable } from "rxjs";

export function useViewModel<T>(viewModel: T) {
  onMounted(() => {
    if (
      "initialize" in viewModel &&
      typeof viewModel.initialize === "function"
    ) {
      viewModel.initialize();
    }
  });

  onUnmounted(() => {
    if ("dispose" in viewModel && typeof viewModel.dispose === "function") {
      viewModel.dispose();
    }
  });

  return viewModel;
}

export function useObservable<T>(observable: Observable<T>, initialValue: T) {
  const state = ref<T>(initialValue);
  let subscription: any;

  onMounted(() => {
    subscription = observable.subscribe((value) => {
      state.value = value;
    });
  });

  onUnmounted(() => {
    subscription?.unsubscribe();
  });

  return state;
}
```

This foundation lets us connect any ViewModel to Vue's lifecycle without modifying the ViewModel itself. Notice we're not importing Vue dependencies into our ViewModels—we're adapting Vue to work with our existing architecture.

## Adapting the EnvironmentalMonitorViewModel

Let's start with our core monitoring feature. In Chapter 7, we built the `EnvironmentalMonitorViewModel` to handle real-time sensor data. That ViewModel doesn't know about React. It exposes RxJS observables and command methods. Vue will consume those observables differently than React did, but the ViewModel stays identical.

Here's our ViewModel again (unchanged from Chapter 7):

```typescript
// viewmodels/EnvironmentalMonitorViewModel.ts
export class EnvironmentalMonitorViewModel {
  private readonly environmentalState = new BehaviorSubject<EnvironmentalState>(
    {
      temperature: null,
      humidity: null,
      soilMoisture: null,
      lightLevel: null,
      lastUpdated: null,
      status: "disconnected",
    }
  );

  readonly temperature$ = this.environmentalState.pipe(
    map((state) => state.temperature),
    distinctUntilChanged()
  );

  readonly humidity$ = this.environmentalState.pipe(
    map((state) => state.humidity),
    distinctUntilChanged()
  );

  readonly soilMoisture$ = this.environmentalState.pipe(
    map((state) => state.soilMoisture),
    distinctUntilChanged()
  );

  readonly status$ = this.environmentalState.pipe(
    map((state) => state.status),
    distinctUntilChanged()
  );

  readonly formattedLastUpdate$ = this.environmentalState.pipe(
    map((state) =>
      state.lastUpdated
        ? formatDistanceToNow(state.lastUpdated, { addSuffix: true })
        : "Never"
    )
  );

  constructor(
    private readonly monitoringService: IEnvironmentalMonitoringService,
    private readonly greenhouseId: string
  ) {}

  initialize(): void {
    this.subscriptions.add(
      this.monitoringService.getRealtimeData(this.greenhouseId).subscribe({
        next: (data) => this.handleSensorData(data),
        error: (error) => this.handleConnectionError(error),
      })
    );
  }

  refreshData(): void {
    this.monitoringService.refreshSensorData(this.greenhouseId);
  }

  dispose(): void {
    this.subscriptions.unsubscribe();
  }

  private handleSensorData(data: SensorReading): void {
    this.environmentalState.next({
      temperature: data.temperature,
      humidity: data.humidity,
      soilMoisture: data.soilMoisture,
      lightLevel: data.lightLevel,
      lastUpdated: new Date(),
      status: "connected",
    });
  }
}
```

This ViewModel knows nothing about Vue. It doesn't import `ref` or `reactive`. It doesn't know about Vue's lifecycle. It just exposes observables and commands. Perfect.

Now let's connect it to a Vue component:

```typescript
// components/EnvironmentalMonitor.vue
<template>
  <div class="environmental-monitor">
    <div class="status-badge" :class="statusClass">
      {{ statusText }}
    </div>

    <div class="metrics-grid">
      <MetricCard
        label="Temperature"
        :value="temperature"
        unit="°C"
        :status="getMetricStatus(temperature, 18, 28)"
      />
      <MetricCard
        label="Humidity"
        :value="humidity"
        unit="%"
        :status="getMetricStatus(humidity, 60, 80)"
      />
      <MetricCard
        label="Soil Moisture"
        :value="soilMoisture"
        unit="%"
        :status="getMetricStatus(soilMoisture, 40, 70)"
      />
    </div>

    <div class="last-update">
      Last updated {{ lastUpdate }}
    </div>

    <button @click="handleRefresh" class="refresh-button">
      Refresh Data
    </button>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useViewModel, useObservable } from '@/composables/useViewModel';
import { EnvironmentalMonitorViewModel } from '@/viewmodels/EnvironmentalMonitorViewModel';
import { useEnvironmentalMonitoringService } from '@/composables/useServices';

const props = defineProps<{
  greenhouseId: string;
}>();

// Create ViewModel with service dependency
const monitoringService = useEnvironmentalMonitoringService();
const viewModel = new EnvironmentalMonitorViewModel(
  monitoringService,
  props.greenhouseId
);

// Connect ViewModel lifecycle to Vue component lifecycle
useViewModel(viewModel);

// Subscribe to ViewModel observables
const temperature = useObservable(viewModel.temperature$, null);
const humidity = useObservable(viewModel.humidity$, null);
const soilMoisture = useObservable(viewModel.soilMoisture$, null);
const status = useObservable(viewModel.status$, 'disconnected');
const lastUpdate = useObservable(viewModel.formattedLastUpdate$, 'Never');

// Computed properties for presentation logic
const statusClass = computed(() => ({
  'status-connected': status.value === 'connected',
  'status-disconnected': status.value === 'disconnected',
  'status-error': status.value === 'error'
}));

const statusText = computed(() => {
  switch (status.value) {
    case 'connected': return 'Connected';
    case 'disconnected': return 'Disconnected';
    case 'error': return 'Connection Error';
    default: return 'Unknown';
  }
});

// Command handlers
function handleRefresh() {
  viewModel.refreshData();
}

function getMetricStatus(value: number | null, min: number, max: number): string {
  if (value === null) return 'unknown';
  if (value < min) return 'low';
  if (value > max) return 'high';
  return 'normal';
}
</script>
```

Look at what we achieved here:

✅ **Zero changes to the ViewModel.** We reused the exact class from our React implementation.

✅ **Framework-specific presentation.** Vue's template syntax handles rendering, while our ViewModel provides the data.

✅ **Clean lifecycle management.** `useViewModel` connects the ViewModel's lifecycle to Vue's component lifecycle automatically.

✅ **Type-safe subscriptions.** TypeScript verifies our observable subscriptions at compile time.

✅ **Testable presentation logic.** The `getMetricStatus` function lives in the component because it's pure presentation logic—no business rules, just UI decisions.

Compare this to the React version from Chapter 7. The ViewModel code is identical. The component structure differs—Vue templates versus JSX, `ref` versus `useState`, composables versus hooks—but the business logic remains untouched. That's framework independence.

## Creating Vue-Specific Composables

Vue developers expect composables—reusable composition functions that encapsulate logic. We'll create composables that make working with ViewModels feel natural in Vue, without compromising our architecture.

Here's a more sophisticated version of `useViewModel` that handles common ViewModel patterns:

```typescript
// composables/useViewModel.ts
import { onMounted, onUnmounted, reactive, toRefs } from "vue";
import { Observable, Subscription } from "rxjs";

interface ViewModelWithLifecycle {
  initialize?(): void;
  dispose?(): void;
}

export function useViewModel<T extends ViewModelWithLifecycle>(viewModel: T) {
  onMounted(() => {
    viewModel.initialize?.();
  });

  onUnmounted(() => {
    viewModel.dispose?.();
  });

  return viewModel;
}

export function useObservable<T>(observable: Observable<T>, initialValue: T) {
  const state = reactive({ value: initialValue });
  let subscription: Subscription | undefined;

  onMounted(() => {
    subscription = observable.subscribe((value) => {
      state.value = value;
    });
  });

  onUnmounted(() => {
    subscription?.unsubscribe();
  });

  return toRefs(state).value;
}

export function useObservables<T extends Record<string, Observable<any>>>(
  observables: T,
  initialValues: {
    [K in keyof T]: T[K] extends Observable<infer U> ? U : never;
  }
) {
  const state = reactive({ ...initialValues });
  const subscriptions: Subscription[] = [];

  onMounted(() => {
    Object.entries(observables).forEach(([key, observable]) => {
      const sub = (observable as Observable<any>).subscribe((value) => {
        (state as any)[key] = value;
      });
      subscriptions.push(sub);
    });
  });

  onUnmounted(() => {
    subscriptions.forEach((sub) => sub.unsubscribe());
  });

  return toRefs(state);
}
```

The `useObservables` composable lets us subscribe to multiple observables at once, reducing boilerplate:

```typescript
<script setup lang="ts">
const viewModel = new EnvironmentalMonitorViewModel(
  monitoringService,
  props.greenhouseId
);

useViewModel(viewModel);

const { temperature, humidity, soilMoisture, status, formattedLastUpdate } = useObservables(
  {
    temperature: viewModel.temperature$,
    humidity: viewModel.humidity$,
    soilMoisture: viewModel.soilMoisture$,
    status: viewModel.status$,
    formattedLastUpdate: viewModel.formattedLastUpdate$
  },
  {
    temperature: null,
    humidity: null,
    soilMoisture: null,
    status: 'disconnected',
    formattedLastUpdate: 'Never'
  }
);
</script>
```

This composable handles the subscription lifecycle automatically. When the component mounts, subscriptions start. When it unmounts, they clean up. Our ViewModel doesn't need to know any of this is happening.

## Handling Commands and Two-Way Binding

Vue excels at two-way binding with `v-model`. Let's see how to integrate this with ViewModels that manage form state. We'll implement the irrigation control feature from Chapter 7.

First, our ViewModel (again, unchanged from the React version):

```typescript
// viewmodels/IrrigationControlViewModel.ts
export class IrrigationControlViewModel {
  private readonly stateSubject = new BehaviorSubject<IrrigationState>({
    isActive: false,
    mode: "manual",
    duration: 15,
    scheduledStart: null,
    remainingTime: null,
  });

  readonly isActive$ = this.stateSubject.pipe(
    map((state) => state.isActive),
    distinctUntilChanged()
  );

  readonly mode$ = this.stateSubject.pipe(
    map((state) => state.mode),
    distinctUntilChanged()
  );

  readonly duration$ = this.stateSubject.pipe(
    map((state) => state.duration),
    distinctUntilChanged()
  );

  readonly canStart$ = combineLatest([this.isActive$, this.duration$]).pipe(
    map(([isActive, duration]) => !isActive && duration > 0)
  );

  readonly canStop$ = this.isActive$;

  constructor(
    private readonly irrigationService: IIrrigationService,
    private readonly greenhouseId: string
  ) {}

  setMode(mode: IrrigationMode): void {
    const currentState = this.stateSubject.value;
    this.stateSubject.next({ ...currentState, mode });
  }

  setDuration(duration: number): void {
    const currentState = this.stateSubject.value;
    this.stateSubject.next({ ...currentState, duration });
  }

  async startIrrigation(): Promise<void> {
    const state = this.stateSubject.value;

    try {
      await this.irrigationService.start(
        this.greenhouseId,
        state.mode,
        state.duration
      );

      this.stateSubject.next({
        ...state,
        isActive: true,
        remainingTime: state.duration * 60,
      });
    } catch (error) {
      // Error handling
      throw error;
    }
  }

  async stopIrrigation(): Promise<void> {
    try {
      await this.irrigationService.stop(this.greenhouseId);

      const state = this.stateSubject.value;
      this.stateSubject.next({
        ...state,
        isActive: false,
        remainingTime: null,
      });
    } catch (error) {
      throw error;
    }
  }
}
```

Now let's connect this to Vue with proper two-way binding:

```typescript
// components/IrrigationControl.vue
<template>
  <div class="irrigation-control">
    <div class="status-indicator" :class="{ active: isActive }">
      {{ isActive ? 'Irrigation Active' : 'Irrigation Inactive' }}
    </div>

    <div class="control-form">
      <label>
        Mode:
        <select :value="mode" @change="handleModeChange">
          <option value="manual">Manual</option>
          <option value="scheduled">Scheduled</option>
          <option value="automatic">Automatic</option>
        </select>
      </label>

      <label>
        Duration (minutes):
        <input
          type="number"
          :value="duration"
          @input="handleDurationChange"
          :disabled="isActive"
          min="1"
          max="120"
        />
      </label>
    </div>

    <div class="actions">
      <button
        @click="handleStart"
        :disabled="!canStart"
        class="start-button"
      >
        Start Irrigation
      </button>

      <button
        @click="handleStop"
        :disabled="!canStop"
        class="stop-button"
      >
        Stop Irrigation
      </button>
    </div>

    <div v-if="remainingTime" class="remaining-time">
      Time remaining: {{ formatTime(remainingTime) }}
    </div>
  </div>
</template>

<script setup lang="ts">
import { useViewModel, useObservables } from '@/composables/useViewModel';
import { IrrigationControlViewModel } from '@/viewmodels/IrrigationControlViewModel';
import { useIrrigationService } from '@/composables/useServices';

const props = defineProps<{
  greenhouseId: string;
}>();

const irrigationService = useIrrigationService();
const viewModel = new IrrigationControlViewModel(
  irrigationService,
  props.greenhouseId
);

useViewModel(viewModel);

const {
  isActive,
  mode,
  duration,
  canStart,
  canStop,
  remainingTime
} = useObservables(
  {
    isActive: viewModel.isActive$,
    mode: viewModel.mode$,
    duration: viewModel.duration$,
    canStart: viewModel.canStart$,
    canStop: viewModel.canStop$,
    remainingTime: viewModel.remainingTime$
  },
  {
    isActive: false,
    mode: 'manual' as const,
    duration: 15,
    canStart: false,
    canStop: false,
    remainingTime: null
  }
);

function handleModeChange(event: Event) {
  const target = event.target as HTMLSelectElement;
  viewModel.setMode(target.value as any);
}

function handleDurationChange(event: Event) {
  const target = event.target as HTMLInputElement;
  const value = parseInt(target.value, 10);
  if (!isNaN(value)) {
    viewModel.setDuration(value);
  }
}

async function handleStart() {
  try {
    await viewModel.startIrrigation();
  } catch (error) {
    console.error('Failed to start irrigation:', error);
  }
}

async function handleStop() {
  try {
    await viewModel.stopIrrigation();
  } catch (error) {
    console.error('Failed to stop irrigation:', error);
  }
}

function formatTime(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}
</script>
```

Notice the pattern here:

✅ **One-way data flow from ViewModel to View.** The template binds to reactive values derived from observables.

✅ **Commands flow from View to ViewModel.** User interactions call ViewModel methods, which update internal state and trigger new observable emissions.

✅ **No direct v-model on ViewModel state.** We don't try to make Vue's two-way binding directly mutate ViewModel properties. Instead, we use `:value` bindings and `@input` handlers that call ViewModel command methods.

✅ **Async command handling.** Vue handles async operations naturally, and our ViewModels return promises that components can await.

This approach respects both Vue's patterns and MVVM principles. Vue developers get the reactive experience they expect. Our ViewModels maintain their framework-agnostic design.

## Dependency Injection in Vue

Vue doesn't have built-in dependency injection like Angular, but we can implement a clean DI pattern using Vue's `provide` and `inject` APIs. This lets us register services at the application level and inject them into ViewModels without prop drilling.

Here's how we set up our service container:

```typescript
// services/container.ts
import { InjectionKey } from "vue";
import { IEnvironmentalMonitoringService } from "@/domain/services/IEnvironmentalMonitoringService";
import { IIrrigationService } from "@/domain/services/IIrrigationService";
import { IAlertService } from "@/domain/services/IAlertService";

export const ENVIRONMENTAL_MONITORING_SERVICE =
  Symbol() as InjectionKey<IEnvironmentalMonitoringService>;
export const IRRIGATION_SERVICE = Symbol() as InjectionKey<IIrrigationService>;
export const ALERT_SERVICE = Symbol() as InjectionKey<IAlertService>;

// Service implementations
import { EnvironmentalMonitoringService } from "./EnvironmentalMonitoringService";
import { IrrigationService } from "./IrrigationService";
import { AlertService } from "./AlertService";

export function registerServices(app: any) {
  // Register concrete implementations
  app.provide(
    ENVIRONMENTAL_MONITORING_SERVICE,
    new EnvironmentalMonitoringService()
  );
  app.provide(IRRIGATION_SERVICE, new IrrigationService());
  app.provide(ALERT_SERVICE, new AlertService());
}
```

In our application entry point:

```typescript
// main.ts
import { createApp } from "vue";
import App from "./App.vue";
import { registerServices } from "./services/container";

const app = createApp(App);

registerServices(app);

app.mount("#app");
```

Now we create composables that inject these services:

```typescript
// composables/useServices.ts
import { inject } from "vue";
import {
  ENVIRONMENTAL_MONITORING_SERVICE,
  IRRIGATION_SERVICE,
  ALERT_SERVICE,
} from "@/services/container";

export function useEnvironmentalMonitoringService() {
  const service = inject(ENVIRONMENTAL_MONITORING_SERVICE);
  if (!service) {
    throw new Error("EnvironmentalMonitoringService not provided");
  }
  return service;
}

export function useIrrigationService() {
  const service = inject(IRRIGATION_SERVICE);
  if (!service) {
    throw new Error("IrrigationService not provided");
  }
  return service;
}

export function useAlertService() {
  const service = inject(ALERT_SERVICE);
  if (!service) {
    throw new Error("AlertService not provided");
  }
  return service;
}
```

Components use these composables to get service instances:

```typescript
<script setup lang="ts">
const monitoringService = useEnvironmentalMonitoringService();
const irrigationService = useIrrigationService();

const viewModel = new EnvironmentalMonitorViewModel(
  monitoringService,
  props.greenhouseId
);
</script>
```

This pattern gives us:

✅ **Type-safe dependency injection.** TypeScript verifies service types at compile time.

✅ **Centralized service management.** All service registration happens in one place.

✅ **Easy testing.** We can provide mock services for testing by creating a test utility:

```typescript
// test-utils/mockServices.ts
import { createApp } from "vue";
import {
  ENVIRONMENTAL_MONITORING_SERVICE,
  IRRIGATION_SERVICE,
} from "@/services/container";

export function createTestApp(
  component: any,
  mocks: {
    environmentalMonitoring?: any;
    irrigation?: any;
  } = {}
) {
  const app = createApp(component);

  if (mocks.environmentalMonitoring) {
    app.provide(
      ENVIRONMENTAL_MONITORING_SERVICE,
      mocks.environmentalMonitoring
    );
  }

  if (mocks.irrigation) {
    app.provide(IRRIGATION_SERVICE, mocks.irrigation);
  }

  return app;
}
```

This DI approach works across frameworks. The ViewModels receive their dependencies through constructor injection, regardless of whether we're using Vue's `provide/inject`, React Context, or Angular's DI system.

## Testing Vue Components with ViewModels

Testing Vue components connected to ViewModels follows the same principles we established in Chapter 9: test the ViewModel thoroughly in isolation, then write minimal integration tests for the component's rendering and event handling.

Here's how we test the `EnvironmentalMonitor` component:

```typescript
// components/__tests__/EnvironmentalMonitor.spec.ts
import { mount } from "@vue/test-utils";
import { BehaviorSubject } from "rxjs";
import EnvironmentalMonitor from "../EnvironmentalMonitor.vue";
import { EnvironmentalMonitorViewModel } from "@/viewmodels/EnvironmentalMonitorViewModel";

// Create a test double for the ViewModel
class MockEnvironmentalMonitorViewModel {
  private temperatureSubject = new BehaviorSubject<number | null>(null);
  private humiditySubject = new BehaviorSubject<number | null>(null);
  private statusSubject = new BehaviorSubject<string>("disconnected");

  temperature$ = this.temperatureSubject.asObservable();
  humidity$ = this.humiditySubject.asObservable();
  soilMoisture$ = new BehaviorSubject<number | null>(null).asObservable();
  status$ = this.statusSubject.asObservable();
  formattedLastUpdate$ = new BehaviorSubject<string>("Never").asObservable();

  initialize = vi.fn();
  dispose = vi.fn();
  refreshData = vi.fn();

  // Test helpers
  setTemperature(value: number) {
    this.temperatureSubject.next(value);
  }

  setStatus(status: string) {
    this.statusSubject.next(status);
  }
}

describe("EnvironmentalMonitor", () => {
  it("renders temperature when available", async () => {
    const mockViewModel = new MockEnvironmentalMonitorViewModel();

    const wrapper = mount(EnvironmentalMonitor, {
      props: { greenhouseId: "gh-1" },
      global: {
        provide: {
          viewModel: mockViewModel,
        },
      },
    });

    // Initially null
    expect(wrapper.text()).toContain("--");

    // Update through ViewModel
    mockViewModel.setTemperature(24.5);
    await wrapper.vm.$nextTick();

    expect(wrapper.text()).toContain("24.5");
  });

  it("calls refreshData when refresh button clicked", async () => {
    const mockViewModel = new MockEnvironmentalMonitorViewModel();

    const wrapper = mount(EnvironmentalMonitor, {
      props: { greenhouseId: "gh-1" },
      global: {
        provide: {
          viewModel: mockViewModel,
        },
      },
    });

    await wrapper.find(".refresh-button").trigger("click");

    expect(mockViewModel.refreshData).toHaveBeenCalledOnce();
  });

  it("shows connected status when ViewModel reports connection", async () => {
    const mockViewModel = new MockEnvironmentalMonitorViewModel();

    const wrapper = mount(EnvironmentalMonitor, {
      props: { greenhouseId: "gh-1" },
      global: {
        provide: {
          viewModel: mockViewModel,
        },
      },
    });

    mockViewModel.setStatus("connected");
    await wrapper.vm.$nextTick();

    const statusBadge = wrapper.find(".status-badge");
    expect(statusBadge.classes()).toContain("status-connected");
    expect(statusBadge.text()).toBe("Connected");
  });

  it("initializes ViewModel on mount and disposes on unmount", () => {
    const mockViewModel = new MockEnvironmentalMonitorViewModel();

    const wrapper = mount(EnvironmentalMonitor, {
      props: { greenhouseId: "gh-1" },
      global: {
        provide: {
          viewModel: mockViewModel,
        },
      },
    });

    expect(mockViewModel.initialize).toHaveBeenCalledOnce();

    wrapper.unmount();

    expect(mockViewModel.dispose).toHaveBeenCalledOnce();
  });
});
```

Notice what we're testing:

✅ **Component renders ViewModel state correctly.** We verify that observable values appear in the DOM.

✅ **Component calls ViewModel methods on user interaction.** We check that button clicks invoke the right commands.

✅ **Component handles ViewModel lifecycle.** We ensure `initialize` and `dispose` get called at the right times.

❌ **We don't test business logic in the component.** That logic lives in the ViewModel and has its own tests.

❌ **We don't test ViewModel behavior.** We already tested the ViewModel in isolation. Component tests verify integration, not business rules.

For testing the ViewModel itself, we use the exact same tests from Chapter 9. The ViewModel doesn't know about Vue, so our ViewModel tests don't need Vue Testing Library. They're pure TypeScript tests with RxJS TestScheduler.

## Handling Navigation and Routing

Vue Router provides navigation capabilities, but routing decisions often involve business logic. Should we allow navigation away from a form with unsaved changes? Should we redirect based on authentication state? These decisions belong in ViewModels, not in Vue Router configuration.

Let's implement a navigation guard pattern that works with our ViewModels:

```typescript
// viewmodels/IrrigationControlViewModel.ts (extended)
export class IrrigationControlViewModel {
  // ... previous code ...

  readonly hasUnsavedChanges$ = combineLatest([
    this.mode$,
    this.duration$,
    this.stateSubject.pipe(map((s) => s.savedConfiguration)),
  ]).pipe(
    map(([mode, duration, saved]) => {
      if (!saved) return false;
      return mode !== saved.mode || duration !== saved.duration;
    })
  );

  readonly canNavigateAway$ = combineLatest([
    this.isActive$,
    this.hasUnsavedChanges$,
  ]).pipe(map(([isActive, hasUnsaved]) => !isActive && !hasUnsaved));

  async confirmNavigation(): Promise<boolean> {
    const canNavigate = await firstValueFrom(this.canNavigateAway$);

    if (canNavigate) {
      return true;
    }

    const hasUnsaved = await firstValueFrom(this.hasUnsavedChanges$);
    if (hasUnsaved) {
      return confirm(
        "You have unsaved changes. Are you sure you want to leave?"
      );
    }

    return confirm(
      "Irrigation is currently active. Are you sure you want to leave?"
    );
  }
}
```

Now we integrate this with Vue Router:

```typescript
// composables/useNavigationGuard.ts
import { onBeforeRouteLeave } from "vue-router";
import type { NavigationGuardNext, RouteLocationNormalized } from "vue-router";

interface ViewModelWithNavigation {
  confirmNavigation(): Promise<boolean>;
}

export function useNavigationGuard(viewModel: ViewModelWithNavigation) {
  onBeforeRouteLeave(
    async (
      to: RouteLocationNormalized,
      from: RouteLocationNormalized,
      next: NavigationGuardNext
    ) => {
      const canNavigate = await viewModel.confirmNavigation();
      next(canNavigate);
    }
  );
}
```

Use it in a component:

```typescript
<script setup lang="ts">
import { useNavigationGuard } from '@/composables/useNavigationGuard';

const viewModel = new IrrigationControlViewModel(
  irrigationService,
  props.greenhouseId
);

useViewModel(viewModel);
useNavigationGuard(viewModel);
</script>
```

This pattern keeps routing logic in the ViewModel where it can be tested without Vue Router:

```typescript
// viewmodels/__tests__/IrrigationControlViewModel.spec.ts
describe("IrrigationControlViewModel - Navigation", () => {
  it("allows navigation when no unsaved changes", async () => {
    const viewModel = new IrrigationControlViewModel(mockService, "gh-1");

    const canNavigate = await viewModel.confirmNavigation();

    expect(canNavigate).toBe(true);
  });

  it("prompts user when unsaved changes exist", async () => {
    const confirmSpy = vi.spyOn(window, "confirm").mockReturnValue(true);

    const viewModel = new IrrigationControlViewModel(mockService, "gh-1");

    viewModel.setDuration(30);

    const canNavigate = await viewModel.confirmNavigation();

    expect(confirmSpy).toHaveBeenCalled();
    expect(canNavigate).toBe(true);
  });
});
```

The ViewModel handles the business rule: "Don't navigate if irrigation is active or changes are unsaved." Vue Router handles the framework-specific routing mechanics. Clean separation.

## Optimizing Vue Performance with ViewModels

Vue's reactivity system performs well by default, but large applications need optimization. ViewModels help because they already separate concerns—we can optimize business logic independently from rendering logic.

**Computed state at the ViewModel level.** Instead of computing derived values in Vue computed properties, compute them in the ViewModel:

```typescript
// ❌ Computing in Vue component
const metrics = computed(() => {
  return {
    avgTemperature: calculateAverage(temperatureHistory.value),
    maxHumidity: Math.max(...humidityHistory.value),
    alertCount: alerts.value.filter((a) => !a.acknowledged).length,
  };
});

// ✅ Computing in ViewModel
export class EnvironmentalAnalyticsViewModel {
  readonly metrics$ = combineLatest([
    this.temperatureHistory$,
    this.humidityHistory$,
    this.alerts$,
  ]).pipe(
    map(([temps, humidity, alerts]) => ({
      avgTemperature: this.calculateAverage(temps),
      maxHumidity: Math.max(...humidity),
      alertCount: alerts.filter((a) => !a.acknowledged).length,
    })),
    shareReplay(1)
  );
}
```

This approach caches computed values at the observable level, preventing redundant calculations even if multiple components subscribe.

**Selective subscriptions with distinctUntilChanged.** ViewModels can optimize which updates trigger re-renders:

```typescript
readonly displayTemperature$ = this.temperature$.pipe(
  map(temp => temp !== null ? Math.round(temp * 10) / 10 : null),
  distinctUntilChanged()
);
```

This observable only emits when the rounded temperature changes, reducing unnecessary component updates.

**Background computation with observeOn.** For expensive calculations, offload work to avoid blocking the UI:

```typescript
import { asyncScheduler } from 'rxjs';

readonly expensiveAnalysis$ = this.rawData$.pipe(
  observeOn(asyncScheduler),
  map(data => this.performComplexAnalysis(data)),
  shareReplay(1)
);
```

The ViewModel handles these optimizations transparently. Vue components just subscribe and render—no performance tuning needed at the component level.

## When Vue Patterns Conflict with MVVM

Vue's reactivity system sometimes encourages patterns that conflict with MVVM principles. Let's address the most common conflicts:

**Mutating reactive objects directly.** Vue allows direct mutation of reactive objects:

```typescript
// ❌ Don't do this with ViewModels
const state = reactive(viewModel);
state.temperature = 25; // Direct mutation
```

This breaks MVVM because it bypasses the ViewModel's command methods. Always use ViewModel methods:

```typescript
// ✅ Correct approach
viewModel.setTemperature(25);
```

**Over-using Vue's reactive() with ViewModels.** Don't wrap ViewModels in `reactive()`:

```typescript
// ❌ Don't do this
const viewModel = reactive(new EnvironmentalMonitorViewModel(...));
```

ViewModels use RxJS for reactivity. Wrapping them in Vue's reactive system creates two conflicting reactive layers. Use `useObservable` to bridge RxJS to Vue.

**Computed properties that duplicate ViewModel logic.** If you find yourself writing this:

```typescript
// ❌ Duplicated logic
const canSubmit = computed(() => {
  return (
    temperature.value !== null && humidity.value !== null && !isSubmitting.value
  );
});
```

Move that logic to the ViewModel:

```typescript
// ✅ Logic in ViewModel
readonly canSubmit$ = combineLatest([
  this.temperature$,
  this.humidity$,
  this.isSubmitting$
]).pipe(
  map(([temp, humid, submitting]) =>
    temp !== null && humid !== null && !submitting
  )
);
```

The component just subscribes:

```typescript
const canSubmit = useObservable(viewModel.canSubmit$, false);
```

## Complete Example: Dashboard with Multiple ViewModels

Let's bring everything together with a complex dashboard component that uses multiple ViewModels:

```typescript
// components/GreenhouseDashboard.vue
<template>
  <div class="dashboard">
    <header class="dashboard-header">
      <h1>{{ greenhouseName }}</h1>
      <div class="connection-status" :class="connectionStatusClass">
        {{ connectionStatus }}
      </div>
    </header>

    <div class="dashboard-grid">
      <section class="environmental-section">
        <h2>Environmental Conditions</h2>
        <EnvironmentalMonitor :greenhouse-id="greenhouseId" />
      </section>

      <section class="irrigation-section">
        <h2>Irrigation Control</h2>
        <IrrigationControl :greenhouse-id="greenhouseId" />
      </section>

      <section class="alerts-section">
        <h2>Active Alerts</h2>
        <AlertList :greenhouse-id="greenhouseId" />
      </section>

      <section class="charts-section">
        <h2>Historical Data</h2>
        <EnvironmentalCharts :greenhouse-id="greenhouseId" />
      </section>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useViewModel, useObservable } from '@/composables/useViewModel';
import { GreenhouseDashboardViewModel } from '@/viewmodels/GreenhouseDashboardViewModel';
import { useGreenhouseService } from '@/composables/useServices';

const props = defineProps<{
  greenhouseId: string;
}>();

const greenhouseService = useGreenhouseService();
const viewModel = new GreenhouseDashboardViewModel(
  greenhouseService,
  props.greenhouseId
);

useViewModel(viewModel);

const greenhouseName = useObservable(viewModel.greenhouseName$, 'Loading...');
const connectionStatus = useObservable(viewModel.connectionStatus$, 'Connecting');

const connectionStatusClass = computed(() => ({
  'status-connected': connectionStatus.value === 'Connected',
  'status-disconnected': connectionStatus.value === 'Disconnected',
  'status-error': connectionStatus.value === 'Error'
}));
</script>
```

The dashboard ViewModel coordinates multiple child ViewModels:

```typescript
// viewmodels/GreenhouseDashboardViewModel.ts
export class GreenhouseDashboardViewModel {
  private readonly stateSubject = new BehaviorSubject<DashboardState>({
    greenhouseName: null,
    connectionStatus: "connecting",
  });

  readonly greenhouseName$ = this.stateSubject.pipe(
    map((state) => state.greenhouseName ?? "Unknown Greenhouse"),
    distinctUntilChanged()
  );

  readonly connectionStatus$ = this.stateSubject.pipe(
    map((state) => state.connectionStatus),
    distinctUntilChanged(),
    map((status) => {
      switch (status) {
        case "connected":
          return "Connected";
        case "disconnected":
          return "Disconnected";
        case "error":
          return "Connection Error";
        default:
          return "Connecting";
      }
    })
  );

  constructor(
    private readonly greenhouseService: IGreenhouseService,
    private readonly greenhouseId: string
  ) {}

  initialize(): void {
    this.subscriptions.add(
      this.greenhouseService.getGreenhouseDetails(this.greenhouseId).subscribe({
        next: (details) => {
          const current = this.stateSubject.value;
          this.stateSubject.next({
            ...current,
            greenhouseName: details.name,
            connectionStatus: "connected",
          });
        },
        error: () => {
          const current = this.stateSubject.value;
          this.stateSubject.next({
            ...current,
            connectionStatus: "error",
          });
        },
      })
    );
  }

  dispose(): void {
    this.subscriptions.unsubscribe();
  }
}
```

Each child component manages its own ViewModel. The dashboard doesn't prop-drill or coordinate state between children—each bounded context remains independent. This scales naturally as the application grows.

## Key Takeaways

We've proven that our MVVM architecture works across frameworks. The same ViewModels, services, and domain logic from our React implementation run unchanged in Vue. Only the view layer adapted to Vue's patterns.

This chapter demonstrated:

**Framework-agnostic ViewModels work.** We used the exact same ViewModel classes in Vue that we built for React. No modifications needed.

**Composables bridge frameworks effectively.** `useViewModel` and `useObservable` provide Vue-friendly interfaces to our RxJS-based ViewModels without compromising architecture.

**Testing remains consistent.** ViewModels test the same way regardless of framework. Component tests verify integration without retesting business logic.

**Dependency injection patterns translate.** We implemented DI using Vue's provide/inject, but the ViewModels' constructor injection approach stayed identical.

**Performance optimization happens at the ViewModel level.** Using RxJS operators like `distinctUntilChanged` and `shareReplay`, we optimized reactive updates without framework-specific code.

The investment in framework independence paid off. When your team decides to adopt Vue for a new feature, or migrate an existing React app, your business logic doesn't need a rewrite. That's the power of proper architectural separation.

Next, we'll tackle Angular—a framework with even stronger opinions about architecture. If our ViewModels work there too, we'll have proven framework independence across the three major frameworks.
