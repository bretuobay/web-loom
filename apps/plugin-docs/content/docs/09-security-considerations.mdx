---
title: 'Security Considerations in Plugin Architecture'
summary: 'Address security risks and best practices in plugin-based systems.'
topicTitle: 'Security Considerations'
topicSlug: '09-security-considerations'
nextTitle: 'Testing Strategies for Plugin-Based Systems'
nextSlug: '/docs/10-testing-strategies-for-plugin-based-systems'
---

# Chapter 9: Security Considerations in Plugin Architecture

Security is the **non-negotiable foundation** of any plugin ecosystem.
The moment you allow third-party code to run inside your application, you’re opening the door to:

- Accidental breakage from poorly written code.
- Malicious behavior from compromised or hostile plugins.
- Data leaks and unauthorized access to sensitive APIs.

This chapter focuses on designing a **secure plugin architecture** without sacrificing flexibility.
We’ll cover:

1. **Security threat model** — understanding the risks.
2. **Sandboxing and isolation** — containing plugin code.
3. **Permission system design** — controlling what plugins can do.
4. **Content Security Policy (CSP)** integration.
5. **Code validation and signing** — ensuring plugin integrity.

---

## 9.1 Security Threat Model

Before defending a system, we must identify what we’re defending against.

---

### Common Plugin Vulnerabilities

- **DOM injection** — Plugins injecting malicious scripts or altering sensitive UI elements.
- **Data exfiltration** — Sending sensitive data (tokens, user info) to an external server.
- **Resource abuse** — Overusing CPU, memory, or network bandwidth.
- **Privilege escalation** — Accessing SDK features without authorization.
- **Dependency hijacking** — Malicious updates to third-party libraries used inside plugins.

---

### Attack Vectors and Mitigation Strategies

| Attack Vector              | Mitigation                                         |
| -------------------------- | -------------------------------------------------- |
| Arbitrary DOM manipulation | Use Shadow DOM, block `document` access in sandbox |
| Untrusted network requests | Proxy through host API client with validation      |
| Excessive API calls        | Rate limit in SDK services                         |
| Cross-plugin data leaks    | Namespace all storage keys, enforce isolation      |
| Malicious updates          | Require digital signatures, verify checksums       |

---

### Trust Boundaries

Clearly define **what belongs to the host** and **what belongs to the plugin**. The `PluginSDK` is the _only_ official bridge between them.

---

## 9.1.1 Trust Models in Real-World Plugin Systems

Different plugin architectures employ fundamentally different trust models, each with specific security implications:

---

### Implicit Trust Model (Vendure)

**Vendure's approach**: Plugins are treated as **vetted, first-party code** with unrestricted access to:

- File system and environment variables
- Database connections (full read/write access)
- Network resources
- System configuration

This model assumes plugins come from trusted sources and undergo review before deployment. The primary security mechanism is **compatibility validation** through semantic versioning.

**Security implications**:

- ✅ High performance (no sandboxing overhead)
- ✅ Full framework integration capabilities
- ❌ Single point of failure (plugin crash = system crash)
- ❌ Unsuitable for open marketplaces

---

### Logical Isolation Model (Backstage)

**Backstage's approach**: Provides **logical isolation** without process separation:

- HTTP isolation (scoped routes per plugin)
- Database isolation (prefixed table names)
- Dependency isolation (explicit service declarations)
- Service-to-service authentication with tokens

```typescript
// Service-to-service authentication
const { token } = await auth.getPluginRequestToken({
  onBehalfOf: credentials,
  targetPluginId: 'catalog',
});

const response = await fetch('http://catalog/api/entities', {
  headers: { Authorization: `Bearer ${token}` },
});
```

**Security implications**:

- ✅ Better fault isolation than implicit trust
- ✅ Granular permission checking
- ✅ Audit trails through service tokens
- ⚠️ Still trusts plugins within logical boundaries

---

### Database-Driven Access Control (NocoBase)

**NocoBase's approach**: Combines **ACL-gated plugin management** with runtime permission checks:

- Package name whitelisting (`@nocobase/plugin-*` prefixes)
- Administrative privileges required for plugin operations
- Access Control Lists with permission snippets
- Event-driven permission updates

```typescript
// Permission snippet registration
this.app.acl.registerSnippet({
  name: 'pm.acl.roles',
  actions: ['roles:*', 'roles.users:*', 'availableActions:list']
});

// Middleware-based permission checking
{ tag: 'acl', after: 'auth', before: 'core' }
```

**Security implications**:

- ✅ Fine-grained permission control
- ✅ Runtime permission updates
- ✅ Namespace isolation for plugin resources
- ⚠️ Requires comprehensive ACL configuration

---

## 9.2 Sandboxing and Isolation

The safest plugin is one that **cannot** affect anything outside its boundaries unless explicitly allowed.

**Isolation Strategy Comparison**:

| System    | Isolation Level | Trade-offs                                  |
| --------- | --------------- | ------------------------------------------- |
| Vendure   | None            | Max performance, full integration, max risk |
| Backstage | Logical         | Balance of safety and capability            |
| VS Code   | Process         | High isolation, communication overhead      |
| Browser   | IFrame/Worker   | Maximum security, limited capabilities      |

---

### JavaScript Execution Isolation

- **IFrame sandboxing** — Highest isolation; restrict script capabilities using `sandbox` attributes.
- **Web Worker isolation** — Great for background tasks; no DOM access.
- **Virtual Machine contexts** — Node.js `vm` or browser-based interpreters for fully controlled execution.

---

### DOM Access Restrictions

Prevent plugins from querying or modifying host DOM directly:

- Render plugin components into a shadow root.
- Use adapter APIs to handle DOM interactions safely.

---

### Network Request Filtering

Route all network calls through the `sdk.services.apiClient`. This allows:

- Centralized request logging.
- Permission-based URL access.
- Throttling and caching.

---

### File System Access Control

For Electron or Node-enabled environments:

- Disable direct `fs` access.
- Provide a controlled file API inside the SDK.

---

## 9.3 Permission System Design

A **granular permission model** ensures plugins only access what they need.

---

### Granular Permission Model

In the manifest, plugins declare what features they need:

```json
{
  "id": "com.example.analytics",
  "name": "Analytics Plugin",
  "permissions": ["events", "api:read", "storage:global"]
}
```

The host checks these before allowing SDK calls.

**Backstage's Permission-Based Approach**:

```typescript
router.delete('/entities/:id', async (req, res) => {
  const credentials = await httpAuth.credentials(req);

  const decision = await permissions.authorize([{ permission: catalogEntityDeletePermission }], { credentials });

  if (decision[0].result === 'DENY') {
    return res.status(403).json({ error: 'Permission denied' });
  }

  await catalog.deleteEntity(req.params.id);
});
```

**NocoBase's ACL Snippet System**:

```typescript
// Bundle related permissions
this.app.acl.registerSnippet({
  name: 'pm.acl.roles',
  actions: ['roles:*', 'roles.users:*', 'availableActions:list'],
});

// Middleware-based enforcement
app.resourcer.use(async (ctx, next) => {
  const { actionName, resourceName } = ctx.action.params;
  const allowed = await ctx.app.acl.can({
    role: ctx.state.currentRole,
    resource: resourceName,
    action: actionName,
  });

  if (!allowed) {
    ctx.throw(403, 'Forbidden');
  }

  await next();
});
```

---

### Runtime Permission Requests

Some permissions can be requested at runtime (e.g., access to private user data). The host can prompt the user for approval.

---

### User Consent Workflows

Always inform users _why_ a permission is needed and what data will be accessed.

---

### Permission Escalation Prevention

Once loaded, a plugin cannot request higher permissions without reinstallation or admin approval.

---

## 9.4 Content Security Policy Integration

A **Content Security Policy (CSP)** can prevent injection attacks and limit external resource loading.

---

### CSP Configuration for Plugins

- Disallow inline scripts (`script-src 'self'`).
- Whitelist only approved CDN domains.
- Use `object-src 'none'` to block Flash and other binary plugins.

---

### Dynamic Policy Updates

If a plugin needs an external resource, update CSP dynamically after validating the request.

---

### Nonce-Based Script Loading

Attach a random nonce to approved `<script>` tags so injected scripts without the nonce are blocked.

---

### Trusted Types Implementation

Use **Trusted Types** to prevent unsafe DOM injection by enforcing controlled HTML creation.

---

## 9.5 Code Validation and Signing

Verifying the integrity of plugin code before execution is essential for preventing tampering.

---

### Static Code Analysis

Run automated checks for:

- Known vulnerability patterns (e.g., `eval`, direct `innerHTML`).
- Dangerous API usage.
- Excessive resource usage potential.

---

### Digital Signature Verification

Require plugins to be signed by a trusted certificate. The host verifies the signature before loading.

---

### Integrity Checking

Use **Subresource Integrity (SRI)** hashes for remote plugin scripts:

```html
<script src="plugin.js" integrity="sha384-..." crossorigin="anonymous"></script>
```

---

### Malware Detection Strategies

Scan plugin bundles with antivirus/malware detection tools before adding them to the registry.

---

### Real-World Security Validation Patterns

**Compatibility Validation (Vendure)**:

```typescript
@VendurePlugin({
  compatibility: '^3.0.0', // Semantic versioning
})
export class PaymentPlugin {
  // Plugin fails fast if version mismatch
}
```

**Package Whitelisting (NocoBase)**:

- Default: Only `@nocobase/plugin-*` and `@nocobase/preset-*` allowed
- Configurable via `PLUGIN_PACKAGE_PREFIX` environment variable
- Prevents installation of arbitrary packages

**Service Authentication (Backstage)**:

```typescript
// Plugins must authenticate for inter-service calls
const { token } = await auth.getPluginRequestToken({
  onBehalfOf: credentials,
  targetPluginId: 'catalog',
});

// Token includes principal information
type BackstagePrincipal =
  | BackstageUserPrincipal // Authenticated user
  | BackstageServicePrincipal // Backend service
  | BackstageNonePrincipal; // Unauthenticated
```

---

## 9.5.1 Security Best Practices from Production Systems

### Fail-Safe Defaults

**Vendure**: Incompatible plugins abort bootstrap with clear error messages
**NocoBase**: Failed plugin loads don't crash the entire system
**Backstage**: Graceful degradation when modules fail to initialize

### Namespace Isolation

```typescript
// NocoBase: Plugin-scoped database collections
db.collection({
  name: 'myData',
  from: '@nocobase/plugin-myPlugin', // Ownership tracking
});

// Backstage: Plugin-scoped HTTP routes
router.get('/api/catalog/entities'); // Scoped to catalog plugin
router.get('/api/scaffolder/actions'); // Scoped to scaffolder plugin
```

### Event-Driven Security Updates

```typescript
// NocoBase: React to permission changes
this.app.on('acl:writeRoleToACL', (role) => {
  // Update plugin-specific permissions
  this.updatePermissions(role);
});

// Update ACL when users are created
db.on('users.afterCreateWithAssociations', (user) => {
  this.assignDefaultRole(user);
});
```

---

## Key Takeaways

A secure plugin architecture:

1. **Chooses an appropriate trust model** for your use case:
   - Implicit trust for vetted, first-party plugins (Vendure)
   - Logical isolation for enterprise platforms (Backstage)
   - Database-driven ACL for multi-tenant systems (NocoBase)

2. Uses **sandboxing** appropriate to the security requirements and performance constraints.

3. Enforces a **permission model** with granular access control and runtime validation.

4. Integrates **CSP and Trusted Types** to prevent injection attacks.

5. Verifies plugin code integrity through **compatibility checks and package validation**.

6. Implements **fail-safe defaults** and graceful degradation for security failures.

7. Uses **namespace isolation** to prevent plugin conflicts and data leaks.

---

**Next up:**
In **Chapter 10**, we’ll look at **Testing Strategies for Plugin-Based Systems**—how to verify plugin functionality, integration, and performance, while ensuring security measures remain intact during continuous development.
