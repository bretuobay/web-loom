---
title: 'Dynamic Loading and Module Resolution Strategies'
summary: 'Explore techniques for loading plugins at runtime and resolving dependencies.'
topicTitle: 'Dynamic Loading and Module Resolution'
topicSlug: '06-dynamic-loading-and-module-resolution'
nextTitle: 'The Plugin SDK'
nextSlug: '/docs/07-plugin-sdk-design'
---

# Chapter 6: Dynamic Loading and Module Resolution Strategies

In the last chapter, we built the **Plugin Registry**‚Äîthe system that knows _what_ plugins exist, their states, and their dependencies.
Now we need to solve the equally critical question: **how do we actually load plugin code into the application?**

Dynamic loading is the heart of a runtime-extensible system. It lets us:

- Add new features without redeploying the whole app.
- Reduce initial bundle size by loading plugins only when needed.
- Support remote marketplaces and self-updating plugins.

In this chapter, we‚Äôll cover:

1. **Module loading approaches** for different environments.
2. **Bundle splitting and code splitting** to optimize delivery.
3. **Asset management** for plugin CSS, images, and other resources.
4. **Development vs. production loading** strategies.
5. **Error handling and fallbacks** for reliability.

---

## 6.1 Module Loading Approaches

The host must load plugin code that may come in different module formats, from various sources, and possibly built with different toolchains.

### Production Module Loading Patterns

Real-world plugin systems demonstrate diverse loading strategies:

**VS Code: Multi-Environment Module Loading**
Handles ESM and CommonJS across Node.js and browser environments:

```ts
// Node.js extension host
async function loadCommonJS(modulePath: string) {
  return require(modulePath);
}

// Browser/web environment
async function loadESM(url: string) {
  return import(url);
}

// Auto-detect and load
async function loadExtension(manifest: IExtensionManifest) {
  const isWeb = typeof window !== 'undefined';
  const loader = isWeb ? loadESM : loadCommonJS;
  return loader(manifest.main);
}
```

**Vite: Native ESM-First Loading**
Leverages browser native ESM with no bundling in development:

```ts
// Development: direct ESM import
const plugin = await import('/plugins/my-plugin/index.js');

// Production: pre-bundled with rollup
const plugin = await import('/assets/my-plugin-abc123.js');
```

**Babel: Synchronous Plugin Loading**
Build-time plugins loaded synchronously via require:

```ts
function loadPlugin(name: string) {
  // Resolve plugin name
  const resolved = resolvePlugin(name);

  // Synchronous require (build-time only)
  const plugin = require(resolved);

  // Validate structure
  return validatePlugin(plugin);
}
```

**Backstage: Package-Based Loading**
Plugins are regular npm packages imported normally:

```ts
// Static import (bundled together)
import { catalogPlugin } from '@backstage/plugin-catalog';

// Dynamic import for code splitting
const plugin = await import('@backstage/plugin-techdocs');
```

---

### ES Modules vs. CommonJS

Modern browsers support ES modules; Node.js supports both. Production systems handle this carefully:

**Dual Package Hazard (Node.js)**
The same package loaded as ESM and CJS creates two instances:

```ts
// Problem: Two instances of the same plugin!
import plugin1 from 'my-plugin';           // ESM
const plugin2 = require('my-plugin');      // CJS
console.log(plugin1 === plugin2);          // false!
```

**Solution: Conditional Exports (package.json)**
```json
{
  "name": "my-plugin",
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "require": "./dist/cjs/index.js"
    }
  }
}
```

**Comprehensive Module Loader**:
```ts
class UniversalModuleLoader {
  async load<T>(
    path: string,
    options: LoadOptions = {}
  ): Promise<T> {
    const { format = 'auto', timeout = 30000 } = options;

    // Auto-detect module format
    const detectedFormat = format === 'auto'
      ? await this.detectFormat(path)
      : format;

    // Load with timeout
    return withTimeout(async () => {
      switch (detectedFormat) {
        case 'esm':
          return this.loadESM<T>(path);
        case 'cjs':
          return this.loadCommonJS<T>(path);
        case 'umd':
          return this.loadUMD<T>(path);
        case 'systemjs':
          return this.loadSystemJS<T>(path);
        default:
          throw new Error(`Unknown module format: ${detectedFormat}`);
      }
    }, timeout);
  }

  private async loadESM<T>(url: string): Promise<T> {
    // Use native dynamic import
    const module = await import(/* @vite-ignore */ url);
    return module.default || module;
  }

  private loadCommonJS<T>(path: string): T {
    // Node.js only
    if (typeof require === 'undefined') {
      throw new Error('CommonJS not supported in browser');
    }

    // Clear require cache for hot reload
    delete require.cache[require.resolve(path)];
    return require(path);
  }

  private async loadUMD<T>(url: string): Promise<T> {
    // Load via script tag, access via global
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = () => {
        const global = this.extractUMDExport(url);
        resolve(global as T);
      };
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  private async detectFormat(path: string): Promise<ModuleFormat> {
    // Check file extension
    if (path.endsWith('.mjs')) return 'esm';
    if (path.endsWith('.cjs')) return 'cjs';

    // Check package.json type field
    const pkgJson = await this.findPackageJson(path);
    if (pkgJson?.type === 'module') return 'esm';

    // Default to CommonJS for .js files
    return 'cjs';
  }
}
```

---

### SystemJS and Module Federation

**SystemJS (Universal Loader)**
Handles any module format at runtime:

```ts
import SystemJS from 'systemjs';

// Load any module format
const plugin = await SystemJS.import('https://cdn.example.com/plugin.js');

// Configure import maps
SystemJS.addImportMap({
  imports: {
    'react': 'https://esm.sh/react@18',
    'react-dom': 'https://esm.sh/react-dom@18',
  },
});
```

**Webpack Module Federation (Micro-Frontends)**
Share dependencies between host and plugins:

```ts
// Host webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      shared: {
        react: { singleton: true, requiredVersion: '^18.0.0' },
        'react-dom': { singleton: true, requiredVersion: '^18.0.0' },
      },
    }),
  ],
};

// Plugin webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'myPlugin',
      filename: 'remoteEntry.js',
      exposes: {
        './Plugin': './src/Plugin',
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};

// Host loads plugin
const container = await import('https://plugin.example.com/remoteEntry.js');
await container.init(__webpack_share_scopes__.default);
const Plugin = await container.get('./Plugin');
```

**Vite's Approach (No Federation)**
Pre-bundles dependencies, simpler but larger bundles:

```ts
// Vite automatically bundles everything
const plugin = await import('/dist/plugin.js');
// All dependencies included in bundle
```

---

### Web Workers for Plugin Isolation

**VS Code: Extension Host in Worker**
Runs all extensions in a dedicated worker process:

```ts
// Main thread
const extensionHost = new Worker('extensionHost.worker.js');

// Communication via message passing
extensionHost.postMessage({
  type: 'activateExtension',
  extensionId: 'my-extension',
});

extensionHost.onmessage = (event) => {
  if (event.data.type === 'executeCommand') {
    // Handle command from extension
    commands.execute(event.data.command);
  }
};

// Extension host worker
onmessage = async (event) => {
  if (event.data.type === 'activateExtension') {
    const ext = await loadExtension(event.data.extensionId);
    await ext.activate(createExtensionContext());
  }
};
```

**Compute-Heavy Plugin Pattern**:
```ts
// Plugin with expensive operations
class DataProcessingPlugin {
  private worker: Worker;

  async init() {
    // Load worker for heavy computation
    this.worker = new Worker(
      new URL('./dataProcessor.worker.js', import.meta.url),
      { type: 'module' }
    );
  }

  async processLargeDataset(data: unknown[]) {
    return new Promise((resolve, reject) => {
      this.worker.postMessage({ type: 'process', data });

      this.worker.onmessage = (e) => {
        if (e.data.type === 'result') {
          resolve(e.data.result);
        } else if (e.data.type === 'error') {
          reject(new Error(e.data.error));
        }
      };
    });
  }
}
```

---

### Service Workers for Caching

**VS Code Web: Offline Extension Support**
Caches extension files for offline use:

```ts
// service-worker.js
const CACHE_NAME = 'extensions-v1';

self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/extensions/')) {
    event.respondWith(
      caches.match(event.request).then((cached) => {
        if (cached) return cached;

        return fetch(event.request).then((response) => {
          return caches.open(CACHE_NAME).then((cache) => {
            cache.put(event.request, response.clone());
            return response;
          });
        });
      })
    );
  }
});
```

**Predictive Caching**:
```ts
class PluginCacheManager {
  async preCachePopularPlugins() {
    const popular = await this.getPopularPlugins();

    if ('serviceWorker' in navigator) {
      const registration = await navigator.serviceWorker.ready;

      await registration.sync.register('cache-plugins');

      // Service worker handles actual caching
      self.addEventListener('sync', async (event) => {
        if (event.tag === 'cache-plugins') {
          for (const plugin of popular) {
            await caches.open('plugins').then((cache) =>
              cache.add(plugin.url)
            );
          }
        }
      });
    }
  }
}
```

---

## 6.2 Bundle Splitting and Code Splitting

Dynamic plugin loading works best when the core app‚Äôs bundle is **small** and each plugin is its own chunk.

---

### Webpack Module Federation Setup

- Expose plugin entry points via `exposes` in plugin‚Äôs webpack config.
- Host app dynamically loads them using `import()` and `__webpack_init_sharing__`.

---

### Dynamic Import Patterns

To load from a URL:

```ts
const pluginModule = await import(/* webpackIgnore: true */ pluginManifest.entry);
```

The `webpackIgnore: true` comment tells Webpack not to try bundling the plugin into the host build.

---

### Chunk Optimization Strategies

- Group low-priority plugins into a shared ‚Äúlazy‚Äù chunk.
- Use **prefetch** for likely-to-be-used plugins.
- Use **preload** for immediately needed plugins.

---

### Tree Shaking for Plugin Code

If plugins are authored in a tree-shakeable way, unused exports can be removed automatically, reducing size.

---

## 6.3 Asset Management

Plugins often ship with CSS, images, fonts, or JSON files. Without proper isolation, these can leak into the host‚Äôs UI or conflict with other plugins.

---

### CSS and Style Isolation

- **Shadow DOM** ensures styles are scoped to the plugin‚Äôs root element.
- **CSS Modules** prevent class name collisions.
- For global styles, require explicit opt-in via the manifest.

---

### Resource Loading and Caching

Load images and fonts via relative paths in the manifest:

```json
{
  "icon": "./assets/icon.png",
  "styles": ["./styles/plugin.css"]
}
```

The loader can fetch and inject these dynamically.

---

### CDN Integration Strategies

For public plugin marketplaces, serve plugin assets from a CDN with versioned URLs for caching and rollback.

---

### Progressive Loading Techniques

- Load CSS before JavaScript to avoid FOUC (flash of unstyled content).
- Lazy-load heavy assets (e.g., charts, maps) only when needed.

---

## 6.4 Development vs. Production Loading

The way we load plugins in development should **optimize for speed and debugging**, not final performance.

### Production Development Workflows

**Vite: Instant HMR Without Bundling**
Development server serves source files directly, HMR via WebSocket:

```ts
// vite.config.ts
export default {
  plugins: [
    {
      name: 'plugin-hmr',
      handleHotUpdate({ file, server }) {
        if (file.includes('/plugins/')) {
          // Notify all clients to reload plugin
          server.ws.send({
            type: 'custom',
            event: 'plugin-update',
            data: { file },
          });
        }
      },
    },
  ],
};

// Client-side HMR handler
if (import.meta.hot) {
  import.meta.hot.accept((newModule) => {
    // Reload plugin with new code
    pluginRegistry.reload(pluginId, newModule);
  });
}
```

**Babel: Transform-Only Development**
No bundling, just transformation:

```ts
// Development: transform on-the-fly
require('@babel/register')({
  plugins: ['transform-typescript', 'transform-jsx'],
  extensions: ['.ts', '.tsx', '.js', '.jsx'],
});

// Now can require .ts files directly
const plugin = require('./my-plugin.ts');
```

**VS Code: Watch Mode with Incremental Compilation**
TypeScript watch mode for fast recompilation:

```json
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": ".tsbuildinfo"
  },
  "watchOptions": {
    "excludeDirectories": ["node_modules"]
  }
}
```

---

### Hot Module Replacement (HMR)

**Comprehensive HMR Implementation**:
```ts
class PluginHMRManager {
  private activePlugins = new Map<string, PluginInstance>();

  async reload(pluginId: string, newModule: PluginModule): Promise<void> {
    const existing = this.activePlugins.get(pluginId);

    // 1. Call dispose on old module
    await existing?.module.dispose?.();

    // 2. Preserve state if possible
    const preservedState = existing?.getState?.();

    // 3. Load new module
    const instance = this.createInstance(newModule);

    // 4. Restore state
    if (preservedState) {
      instance.setState?.(preservedState);
    }

    // 5. Re-mount
    await instance.mount(this.sdk);

    // 6. Update registry
    this.activePlugins.set(pluginId, instance);

    console.log(`[HMR] Reloaded plugin: ${pluginId}`);
  }

  accept(pluginId: string, callback: (newModule: PluginModule) => void) {
    if (import.meta.hot) {
      import.meta.hot.accept((newModule) => {
        callback(newModule);
        this.reload(pluginId, newModule);
      });
    }
  }
}

// Plugin developer uses it
export const myPlugin = {
  init(sdk) {
    // Plugin logic
  },

  // HMR support
  dispose() {
    // Cleanup before reload
    this.cleanup();
  },

  getState() {
    // Return state to preserve across reloads
    return { counter: this.counter };
  },

  setState(state) {
    // Restore state after reload
    this.counter = state.counter;
  },
};

// Enable HMR in development
if (import.meta.hot) {
  import.meta.hot.accept();
}
```

---

### Source Map Integration

**VS Code: Source Map Support**
Maps compiled code back to source for debugging:

```ts
// Extension loads with source maps
const extension = await import('./extension.js');
//# sourceMappingURL=extension.js.map

// Debugger shows original TypeScript code
// Even though it's running compiled JavaScript
```

**Production Source Maps Strategy**:
```ts
// vite.config.ts
export default {
  build: {
    sourcemap: process.env.NODE_ENV === 'development' ? 'inline' : 'hidden',
    // 'hidden' - generate maps but don't reference them
    // Only load maps when needed (debugging production issues)
  },
};

// Error reporting with source maps
import { SourceMapConsumer } from 'source-map';

async function getOriginalPosition(
  file: string,
  line: number,
  column: number
) {
  const mapResponse = await fetch(`${file}.map`);
  const map = await mapResponse.json();

  const consumer = await new SourceMapConsumer(map);
  const original = consumer.originalPositionFor({ line, column });

  return {
    source: original.source,
    line: original.line,
    column: original.column,
  };
}
```

---

### Debugging Configuration

**VS Code: Extension Development Host**
Dedicated debugging environment for extensions:

```json
{
  "type": "extensionHost",
  "request": "launch",
  "name": "Extension Development",
  "args": ["--extensionDevelopmentPath=${workspaceFolder}"],
  "outFiles": ["${workspaceFolder}/out/**/*.js"],
  "preLaunchTask": "npm: watch"
}
```

**Comprehensive Development Logging**:
```ts
class PluginDevLogger {
  private enabled = process.env.NODE_ENV === 'development';

  logDiscovery(plugins: PluginManifest[]) {
    if (!this.enabled) return;

    console.group('üîç Plugin Discovery');
    plugins.forEach((p, index) => {
      console.log(`${index + 1}. ${p.id} v${p.version}`);
      console.log(`   Dependencies:`, p.requiredPlugins);
    });
    console.groupEnd();
  }

  logLoadTiming(pluginId: string, phase: string, duration: number) {
    if (!this.enabled) return;

    const color = duration > 1000 ? 'üî¥' : duration > 500 ? 'üü°' : 'üü¢';
    console.log(`${color} [${pluginId}] ${phase}: ${duration}ms`);
  }

  logError(pluginId: string, phase: string, error: Error) {
    console.group(`‚ùå Plugin Error: ${pluginId}`);
    console.log('Phase:', phase);
    console.log('Error:', error.message);
    console.log('Stack:', error.stack);
    console.groupEnd();
  }

  logStateTransition(pluginId: string, from: string, to: string) {
    if (!this.enabled) return;
    console.log(`üîÑ [${pluginId}] ${from} ‚Üí ${to}`);
  }
}
```

---

### Production Optimization

**Multi-Stage Build Strategy**:
```ts
// Development build (fast, unoptimized)
const devConfig = {
  mode: 'development',
  devtool: 'eval-source-map',  // Fastest rebuild
  optimization: {
    minimize: false,
    removeAvailableModules: false,
    removeEmptyChunks: false,
    splitChunks: false,
  },
};

// Production build (optimized, slow)
const prodConfig = {
  mode: 'production',
  devtool: 'hidden-source-map',
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,  // Remove console.log
          },
        },
      }),
    ],
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
        },
      },
    },
  },
};
```

**Vite Production Optimizations**:
```ts
// vite.config.ts
export default {
  build: {
    // Code splitting
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom'],
          'ui-vendor': ['@mui/material', '@emotion/react'],
        },
      },
    },

    // Compression
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        pure_funcs: ['console.log', 'console.debug'],
      },
    },

    // Modern vs legacy builds
    target: 'es2020',  // Modern browsers only
    // Or use @vitejs/plugin-legacy for dual builds
  },
};

// Immutable caching
app.use((req, res, next) => {
  if (req.url.match(/\.[a-f0-9]{8}\.(js|css)$/)) {
    // Versioned assets never change
    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
  }
  next();
});
```

**Lazy Loading Strategy**:
```ts
class LazyPluginLoader {
  private loadedPlugins = new Set<string>();

  async loadOnDemand(pluginId: string): Promise<PluginModule> {
    if (this.loadedPlugins.has(pluginId)) {
      return this.registry.get(pluginId).module;
    }

    // Load only when needed
    const manifest = this.registry.get(pluginId).manifest;

    // Use dynamic import for code splitting
    const module = await import(
      /* webpackChunkName: "[request]" */
      /* webpackPrefetch: true */
      manifest.entry
    );

    this.loadedPlugins.add(pluginId);
    return module;
  }

  // Prefetch likely-needed plugins
  prefetch(pluginIds: string[]) {
    pluginIds.forEach(id => {
      const manifest = this.registry.get(id)?.manifest;
      if (manifest) {
        // Create prefetch link
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = manifest.entry;
        document.head.appendChild(link);
      }
    });
  }
}
```

---

## 6.5 Error Handling and Fallbacks

Dynamic loading introduces many new failure modes: network issues, syntax errors, incompatible module formats. The loader must degrade gracefully.

---

### Module Loading Error Recovery

If a plugin fails to load:

1. Log the error with context.
2. Show a **placeholder UI** explaining the problem.
3. Retry if applicable.

---

### Graceful Degradation

If a widget plugin fails, keep the rest of the dashboard functional.

---

### Fallback Plugin Implementation

Have a ‚Äúsafe mode‚Äù version of critical plugins that runs locally if the remote one fails.

---

### User Experience During Failures

Always prefer a visible, friendly error over silent failures.
Example: ‚ÄúThe Reports Plugin could not be loaded. Please refresh or contact support.‚Äù

---

## Key Takeaways

A **dynamic loader** must be:

1. **Flexible** ‚Äî handle multiple module formats (ESM, CommonJS, UMD, SystemJS) and auto-detect when possible.

2. **Efficient** ‚Äî load only what's needed, when it's needed through code splitting, lazy loading, and prefetching strategies.

3. **Safe** ‚Äî isolate styles, sandbox execution in workers, provide fallbacks, and handle errors gracefully.

4. **Developer-friendly** ‚Äî support HMR for instant feedback, source maps for debugging, and verbose logging in development.

5. **Production-optimized** ‚Äî minify bundles, enable immutable caching, split chunks intelligently, and measure performance.

---

### Lessons from Production Systems

**Vite** demonstrates that native ESM in development eliminates bundling overhead, enabling instant startup and sub-100ms HMR. Production builds pre-bundle with Rollup for optimal delivery.

**VS Code** shows how multi-environment support (Node.js, browser, web worker) requires environment-aware loading with fallbacks and graceful degradation.

**Babel** teaches that synchronous loading suffices for build-time plugins, while runtime plugins demand async patterns with timeout handling and error recovery.

**Backstage** proves that treating plugins as regular npm packages simplifies the mental model‚Äîstandard package.json, normal imports, familiar tooling.

**Webpack Module Federation** enables dependency sharing between host and plugins, crucial for micro-frontend architectures where duplicate React instances cause bugs.

### Architecture Principles

**1. Progressive Enhancement**
Start with simple dynamic imports, add complexity (Module Federation, SystemJS) only when needed.

**2. Environment Detection**
Auto-detect browser vs Node.js, ESM vs CommonJS support. Provide appropriate loaders for each environment.

**3. Timeout Everything**
Network requests, module loads, plugin initialization‚Äîall should have timeouts to prevent hung applications.

**4. Fail Visibly**
Silent failures during loading create mysterious bugs. Show errors prominently with actionable messages.

**5. Cache Aggressively**
Use content hashing for immutable caching. Pre-cache popular plugins with service workers for instant activation.

**6. Optimize for Development**
Development speed (HMR, no minification, inline source maps) beats production optimization during iteration.

**7. Measure Everything**
Track load times, bundle sizes, cache hit rates. Performance regressions often creep in during plugin ecosystem growth.

### Performance Considerations

**Bundle Size Impact**:
- Base loader: ~5-10 KB gzipped
- SystemJS: +15 KB
- Module Federation runtime: +10 KB
- Source maps: 2-3x original size (serve separately)

**Load Time Targets** (95th percentile):
- Local plugin (same origin): < 50ms
- CDN plugin (HTTP/2): < 200ms
- With cold cache: < 500ms

**Development HMR Targets**:
- Code change detected: < 50ms
- Plugin reloaded: < 200ms
- UI updated: < 50ms
- Total: < 300ms for instant feedback

---

**Next up:**
In **Chapter 7**, we'll design the **Plugin SDK** itself‚Äîthe developer-facing API that makes building plugins a pleasure, with strong typing, discoverable methods, comprehensive documentation, and a smooth developer experience. This is where we transform our technical foundation into a friendly, productive interface for third-party developers.
