---
title: 'Framework-Agnostic Design Principles and Patterns'
summary: 'Design plugins that work across frameworks and environments.'
---

# Chapter 3: Framework-Agnostic Design Principles and Patterns

Designing a plugin architecture that works across **React**, **Vue**, **Angular**, **Svelte**, and beyond requires more than just keeping component types `unknown`.
It demands **architectural patterns** that respect each framework’s lifecycle, rendering model, and event system—while giving plugin developers a single, coherent API surface.

This chapter explores how to create those abstractions, normalize differences, and enable smooth interoperability without coupling your core to any single framework.

---

## 3.1 The Abstraction Layer Challenge

A framework-agnostic plugin system sits between two very different worlds:

1. **The Host Application** — Usually built in one primary framework.
2. **The Plugin Developer’s Code** — Potentially built in a different framework or compiled to vanilla JS.

The **abstraction layer** is the bridge. It must:

- Isolate framework-specific behavior.
- Normalize UI and lifecycle concepts.
- Allow the host to evolve without breaking plugins.

---

### Virtual DOM Abstraction Strategies

Different frameworks have different VDOMs (or none at all). We can’t standardize on React’s `FC` or Vue’s `Component` type without excluding others.
Instead, we define **renderable component contracts**:

```ts
type RenderableComponent = unknown; // Framework-specific at runtime

interface PluginWidgetDefinition<TComponent = RenderableComponent> {
  id: string;
  title: string;
  render: TComponent;
}
```

The host’s adapter decides how to mount `render` into the DOM.

---

### Event System Normalization

Every framework handles events differently. We use a **centralized event bus** in the `PluginSDK`:

```ts
sdk.events.on('user:login', (user) => {
  console.log('User logged in', user);
});
```

Internally, the host adapts this to React’s synthetic events, Vue’s emitters, or native DOM events.

---

### State Management Abstraction

Avoid exposing the host’s store directly (e.g., Redux or Vuex). Instead, define a generic state service:

```ts
sdk.services.storage.set('myPlugin:data', { value: 42 });
```

This lets plugins store data without caring whether the host uses Redux, Zustand, Pinia, or RxJS.

---

### Component Lifecycle Harmonization

Frameworks differ in how they mount and unmount components. We abstract this with the **`mount`** and **`unmount`** lifecycle hooks in `PluginModule`:

```ts
export interface PluginModule {
  init?: (sdk: PluginSDK) => void | Promise<void>;
  mount?: (sdk: PluginSDK) => void | Promise<void>;
  unmount?: () => void | Promise<void>;
}
```

The host adapts these calls to the underlying framework’s lifecycle.

---

## 3.2 Adapter Pattern Implementation

The **Adapter Pattern** lets us keep a single `PluginSDK` interface but change the underlying behavior depending on the host framework.

---

### Framework Adapter Interface

We define a contract for all adapters:

```ts
interface FrameworkAdapter<TComponent = unknown> {
  mountComponent: (component: TComponent, container: HTMLElement) => void;
  unmountComponent: (container: HTMLElement) => void;
}
```

---

### React Adapter Example

```ts
const ReactAdapter: FrameworkAdapter<React.FC> = {
  mountComponent(component, container) {
    ReactDOM.render(React.createElement(component), container);
  },
  unmountComponent(container) {
    ReactDOM.unmountComponentAtNode(container);
  },
};
```

---

### Vue Adapter Example

```ts
const VueAdapter: FrameworkAdapter<Vue.Component> = {
  mountComponent(component, container) {
    const app = Vue.createApp(component);
    app.mount(container);
  },
  unmountComponent(container) {
    container.innerHTML = '';
  },
};
```

---

### Svelte/Angular Considerations

For **Svelte**, the adapter instantiates a new component with a target DOM node.
For **Angular**, we bootstrap the component into a dynamically created module and view container.

---

## 3.3 Plugin Component Architecture

A plugin’s components must be represented **independently of the host’s framework** so they can be interpreted correctly at runtime.

---

### Framework-neutral Component Representation

At the SDK level, components are just `unknown`. This prevents accidental coupling:

```ts
interface PluginRouteDefinition<TComponent = unknown> {
  path: string;
  component: TComponent;
}
```

---

### Props and Data Flow Abstraction

Instead of passing props directly, we can define a **props injection service**:

```ts
sdk.routes.add({
  path: '/dashboard',
  component: MyWidget,
});
```

The adapter decides how props are bound in React, Vue, etc.

---

### Children and Composition Patterns

If the host supports nested UI, define a **slot-like system** for composition instead of relying on framework-specific children props.

---

### Ref and Imperative Handle Management

Some plugins need direct control over their UI.
We can expose a **ref handler API** in the adapter for frameworks that support refs (React, Vue 3) while falling back to DOM element handles in others.

---

## 3.4 Cross-framework State Management

A plugin system may host plugins from different frameworks that need to share state.

---

### Plugin State Isolation

Each plugin should have **its own isolated state** by default to prevent accidental data leakage:

```ts
sdk.services.storage.set('local', { count: 1 });
```

---

### Global State Sharing Patterns

When needed, expose a controlled global state API with strict namespacing:

```ts
sdk.services.storage.set('global:theme', 'dark');
```

---

### Reactive State Synchronization

For reactive frameworks, the adapter can expose reactive wrappers so state updates propagate naturally in React’s hooks, Vue’s reactive refs, etc.

---

### Performance Optimization Strategies

- **Lazy initialization** of plugin state until first access.
- **Shallow equality checks** to avoid unnecessary re-renders.
- **Event batching** to reduce performance overhead.

---

## Key Takeaways

A framework-agnostic plugin architecture succeeds when:

1. **Framework details are pushed to adapters**, not the core contracts.
2. **The SDK surface remains stable**, even if the host changes frameworks.
3. **State, events, and lifecycle** are unified under a single abstraction layer.

---

**Next up:**
In **Chapter 4**, we’ll define the **core contracts and interfaces**—the `PluginManifest`, `PluginModule`, and `PluginSDK`—in a way that balances stability, flexibility, and forward compatibility, drawing directly from our TypeScript-first architecture. This is where we lock in the rules that every plugin must follow.
