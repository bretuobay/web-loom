---
title: 'Architecture Fundamentals'
summary: 'The core ideas behind Web Loom — why framework-agnostic architecture matters and how the MVVM pattern keeps business logic independent of the UI layer.'
topicTitle: 'Published Packages'
topicSlug: 'packages'
nextTitle: 'Getting Started'
nextSlug: '/docs/getting-started'
---

# Architecture Fundamentals

Web Loom is built on a single conviction: **business logic should survive framework changes**. When you migrate from React to Vue, or add a React Native mobile app alongside your web app, only the View layer — roughly 20% of your codebase — should need rewriting. The remaining 80% (Models, ViewModels, services, and behaviors) lives in framework-agnostic packages and travels unchanged.

This page explains the architectural principles that make that possible.

---

## The MVVM Pattern

Web Loom follows the **Model–View–ViewModel** (MVVM) pattern, a well-established separation of concerns that decouples data, presentation logic, and UI rendering.

```
Model          →   owns data, talks to APIs, holds reactive state
  ↓
ViewModel      →   derives presentation state, exposes commands
  ↓
View           →   framework-specific rendering and subscriptions
```

Each layer has a strict responsibility:

- **Model** — fetches, persists, and owns raw data. Exposes it through reactive observables or signals. Never knows the UI exists.
- **ViewModel** — computes what the View needs (formatted values, loading flags, derived lists) and exposes commands for actions. Orchestrates one or more Models. No framework imports.
- **View** — subscribes to ViewModel state, renders it, and calls ViewModel commands on user interaction. The only framework-specific code.

---

## Why Framework-Agnostic

Frameworks have lifecycles. React 16 → 18, Angular upgrades, Vue 2 → 3 — each migration forces rewrites. When business logic is entangled with framework code, every migration touches the whole codebase.

Web Loom separates concerns at a package boundary:

- `@web-loom/mvvm-core`, `@web-loom/signals-core`, `@web-loom/query-core` — plain TypeScript, zero framework imports
- `@web-loom/ui-core`, `@web-loom/forms-core` — headless behaviors, framework-agnostic
- Framework adapters (`@web-loom/forms-react`, `@web-loom/media-vue`, …) — thin wrappers, typically under 200 lines

When a new framework emerges, you write a new adapter. The Models and ViewModels underneath stay untouched.

---

## The Layered Architecture

```
┌─────────────────────────────────┐
│  View (framework-specific)      │  React / Vue / Angular / Lit / Vanilla
│  subscribes to observables      │
├─────────────────────────────────┤
│  ViewModel (framework-agnostic) │  Commands, derived state, orchestration
│  uses Models, exposes state     │
├─────────────────────────────────┤
│  Model (framework-agnostic)     │  Data, API calls, reactive streams
│  calls infrastructure           │
├─────────────────────────────────┤
│  Infrastructure                 │  HTTP, Storage, i18n, Router, EventBus
└─────────────────────────────────┘
```

**Cross-cutting concerns** used across all layers:

- **Event Bus** — typed pub/sub for cross-feature communication without coupling
- **Store** — UI-only ephemeral state (sidebar open, active tab, theme)
- **Signals / Observables** — reactive primitives that propagate changes through the graph
- **Notifications** — user-facing feedback (toasts, alerts)

---

## Reactive State

Web Loom supports two reactive primitives, which can be used together or independently:

### RxJS Observables (mvvm-core)

`@web-loom/mvvm-core` is built on RxJS. Models expose `BehaviorSubject` streams; ViewModels compose them with operators. Best for complex async pipelines, multicasting, and integration with Angular.

```ts
class TaskModel extends BaseModel {
  readonly tasks$ = new BehaviorSubject<Task[]>([]);
  readonly isLoading$ = new BehaviorSubject(false);

  async fetchAll() {
    this.isLoading$.next(true);
    this.tasks$.next(await api.getTasks());
    this.isLoading$.next(false);
  }
}
```

### Signals (signals-core)

`@web-loom/signals-core` provides synchronous, pull-based reactive values with automatic dependency tracking. Zero dependencies, no scheduler — perfect for ViewModels that don't need RxJS.

```ts
class CounterViewModel {
  private _count = signal(0);
  readonly count   = this._count.asReadonly();
  readonly doubled = computed(() => this._count.get() * 2);

  increment() { this._count.update(v => v + 1); }
}
```

Both work with any framework adapter. Choose based on complexity: Signals for straightforward reactive state, Observables for advanced stream composition.

---

## The Command Pattern

Commands are the primary mechanism for user actions in Web Loom. A Command wraps an async operation and exposes:

- `execute()` — trigger the action
- `isExecuting$` / `isExecuting` — loading state for spinner binding
- `canExecute$` / `canRun` — guards (e.g. disable submit while loading)
- `error$` / `error` — last error, if any

```ts
// In a ViewModel
readonly saveCommand = new Command(async () => {
  await this.model.save(this.form.values);
});

// In the View (React)
<button
  onClick={() => vm.saveCommand.execute()}
  disabled={!vm.saveCommand.canExecute}
>
  {vm.saveCommand.isExecuting ? 'Saving…' : 'Save'}
</button>
```

Commands keep the View dumb — it never contains `try/catch`, loading flags, or validation logic.

---

## Package Ecosystem

Web Loom ships 34 packages across several categories:

### Core architecture
- [`@web-loom/mvvm-core`](/docs/models) — BaseModel, BaseViewModel, Commands, RxJS integration
- [`@web-loom/signals-core`](/docs/signals-core) — Lightweight reactive signals and computed values
- [`@web-loom/store-core`](/docs/store-core) — Minimal UI-state store with persistence adapters

### Data & communication
- [`@web-loom/query-core`](/docs/query-core) — Data fetching with caching and stale-while-revalidate
- [`@web-loom/event-bus-core`](/docs/event-bus-core) — Typed event aggregation for cross-feature messaging
- `@web-loom/http-core` — HTTP client abstraction

### UI behaviors
- [`@web-loom/ui-core`](/docs/ui-core) — Headless dialog, list, form, roving-focus behaviors
- [`@web-loom/ui-patterns`](/docs/ui-patterns) — Wizard, MasterDetail, CommandPalette shells
- `@web-loom/forms-core` — Framework-agnostic form logic and validation

### Design & theming
- [`@web-loom/design-core`](/docs/design-core) — Design tokens, CSS custom properties, theming, component library

### Infrastructure
- `@web-loom/router-core` — Routing state abstraction
- `@web-loom/storage-core` — localStorage / sessionStorage abstraction
- `@web-loom/i18n-core` — Internationalization
- `@web-loom/plugin-core` — Plugin architecture for extensible applications

---

## Key Principles

**Unidirectional data flow** — state flows down (Model → ViewModel → View), actions flow up (View calls ViewModel commands). No two-way data binding at the architecture level.

**Always dispose** — ViewModels subscribe to observables and effects. Call `vm.dispose()` in the component teardown hook to prevent memory leaks.

```ts
// React
useEffect(() => {
  vm.fetchCommand.execute();
  return () => vm.dispose();
}, []);
```

**Business data in Models, UI state in Store** — a filter value that affects API results belongs in the Model. Whether a drawer is open belongs in the Store.

**Test ViewModels independently** — because ViewModels have no framework imports, they can be unit tested with plain Vitest, no DOM or component setup required.

```ts
it('filters tasks correctly', () => {
  const vm = new TaskListViewModel(mockModel);
  vm.setFilter('done');
  expect(vm.visibleTasks.get().every(t => t.done)).toBe(true);
  vm.dispose();
});
```

---

## Where to Go Next

- [Getting Started](/docs/getting-started) — install the packages and build your first ViewModel
- [Models](/docs/models) — deep dive into the Model layer
- [ViewModels](/docs/viewmodels) — commands, derived state, and lifecycle
- [Models](/docs/models) — full documentation for the Model and ViewModel layers
- [Signals Core](/docs/signals-core) — reactive signals as an alternative to RxJS
