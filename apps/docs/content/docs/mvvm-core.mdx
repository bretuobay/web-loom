---
title: 'MVVM Core'
summary: 'A minimal MVVM framework for building reactive web applications.'
topicTitle: 'Published Packages'
topicSlug: 'packages'
---

# MVVM Core

`@web-loom/mvvm-core` is a framework-agnostic MVVM library for building reactive web applications with RxJS and Zod validation. It provides a complete MVVM (Model-View-ViewModel) implementation that works across React, Angular, Vue, and vanilla JavaScript. Built on RxJS for reactive data flow and Zod for type-safe validation, it simplifies state management and API interactions for client-heavy applications.

## Features

- **MVVM Pattern**: BaseModel, BaseViewModel, RestfulApiModel with clear separation of concerns
- **Reactive**: RxJS-powered observables for `data$`, `isLoading$`, `error$`
- **Type-Safe**: Zod schema validation at compile-time and runtime
- **RESTful APIs**: Simplified CRUD with optimistic updates and auto state management
- **Command Pattern**: Encapsulated UI actions with `canExecute` and `isExecuting` states
- **Observable Collections**: Reactive lists with granular change notifications
- **Query Integration**: QueryStateModel for advanced caching with `@web-loom/query-core`
- **Resource Management**: IDisposable pattern for proper cleanup
- **Framework Agnostic**: No UI framework dependencies

## Installation

```bash
npm install @web-loom/mvvm-core rxjs zod
```

## Core Concepts

### BaseModel

Foundation for all models with reactive state management.

```typescript
import { BaseModel } from '@web-loom/mvvm-core';
import { z } from 'zod';

const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(3),
  email: z.string().email(),
  age: z.number().positive().optional(),
});

type User = z.infer<typeof UserSchema>;

class UserModel extends BaseModel<User, typeof UserSchema> {
  constructor(initialData?: User) {
    super({ initialData: initialData || null, schema: UserSchema });
  }
}

const model = new UserModel();
model.data$.subscribe((user) => console.log('User:', user));
model.setData({ id: '123', name: 'Alice', email: 'alice@example.com' });
```

**Key observables**:

- `data$`: Current data state
- `isLoading$`: Loading indicator
- `error$`: Error state
- `isError$`: Boolean error indicator

### RestfulApiModel

Extends BaseModel with CRUD operations and optimistic updates.

```typescript
import { RestfulApiModel, type Fetcher } from '@web-loom/mvvm-core';

const fetcher: Fetcher = async (url, options) => {
  const response = await fetch(url, options);
  if (!response.ok) throw new Error(`HTTP ${response.status}`);
  return response;
};

class UserApiModel extends RestfulApiModel<User[], typeof UserSchema> {
  constructor() {
    super({
      baseUrl: 'https://api.example.com',
      endpoint: 'users',
      fetcher,
      schema: z.array(UserSchema),
      initialData: null,
    });
  }
}

const api = new UserApiModel();

// Fetch all users
await api.fetch();

// Create user (optimistic update)
const newUser = await api.create({ name: 'Bob', email: 'bob@example.com' });

// Update user
await api.update('user-id', { name: 'Robert' });

// Delete user
await api.delete('user-id');
```

### BaseViewModel

Connects Models to Views with presentation logic.

```typescript
import { BaseViewModel } from '@web-loom/mvvm-core';
import { map } from 'rxjs/operators';

class UserViewModel extends BaseViewModel<UserModel> {
  constructor(model: UserModel) {
    super(model);
  }

  // Computed observables
  get displayName$() {
    return this.data$.pipe(map((user) => (user ? `${user.name} (${user.email})` : 'No user')));
  }
}
```

### RestfulApiViewModel

Extends BaseViewModel with CRUD commands for RESTful operations.

```typescript
import { RestfulApiViewModel } from '@web-loom/mvvm-core';

class UserListViewModel extends RestfulApiViewModel<User[], typeof UserSchema> {
  constructor() {
    super(new UserApiModel());
  }

  // Additional computed properties
  get activeUsers$() {
    return this.data$.pipe(map((users) => users?.filter((u) => u.active)));
  }
}

const vm = new UserListViewModel();

// Use commands
await vm.fetchCommand.execute();
await vm.createCommand.execute({ name: 'New User', email: 'new@example.com' });
await vm.updateCommand.execute({ id: '123', name: 'Updated' });
await vm.deleteCommand.execute('123');

// Clean up
vm.dispose();
```

### Command Pattern

Encapsulates UI actions with execution control.

```typescript
import { Command } from '@web-loom/mvvm-core';
import { BehaviorSubject } from 'rxjs';
import { map } from 'rxjs/operators';

class AuthViewModel {
  private _isLoggedIn = new BehaviorSubject(false);
  isLoggedIn$ = this._isLoggedIn.asObservable();

  loginCommand: Command<string, boolean>;

  constructor() {
    this.loginCommand = new Command(
      async (password: string) => {
        // Simulate API call
        await new Promise((resolve) => setTimeout(resolve, 1000));
        const success = password === 'secret';
        this._isLoggedIn.next(success);
        return success;
      },
      // canExecute$ - only when not logged in
      this.isLoggedIn$.pipe(map((loggedIn) => !loggedIn)),
    );
  }
}

const auth = new AuthViewModel();

// Subscribe to command state
auth.loginCommand.isExecuting$.subscribe((executing) => console.log('Logging in:', executing));
auth.loginCommand.canExecute$.subscribe((canExecute) => console.log('Can login:', canExecute));

// Execute command
await auth.loginCommand.execute('secret');
```

### ObservableCollection

Reactive collection with granular change notifications.

```typescript
import { ObservableCollection } from '@web-loom/mvvm-core';

interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

const todos = new ObservableCollection<Todo>([
  { id: '1', text: 'Learn MVVM', completed: false },
  { id: '2', text: 'Build app', completed: true },
]);

// Subscribe to changes
todos.items$.subscribe((items) => console.log('Todos:', items));
todos.changes$.subscribe((change) => console.log('Change:', change));

// Manipulate collection
todos.add({ id: '3', text: 'Deploy', completed: false });
todos.update((todo) => todo.id === '1', { ...todo, completed: true });
todos.remove((todo) => todo.completed);
```

### QueryStateModel & QueryStateModelView

Integration with `@web-loom/query-core` for advanced caching.

```typescript
import { QueryStateModel, QueryStateModelView } from '@web-loom/mvvm-core';
import QueryCore from '@web-loom/query-core';

const queryCore = new QueryCore({ defaultRefetchAfter: 5 * 60 * 1000 });

// Define endpoint
queryCore.defineEndpoint<User[]>('users', async () => {
  const res = await fetch('https://api.example.com/users');
  return res.json();
});

// Create model
class UsersQueryModel extends QueryStateModel<User[], typeof UserSchema> {
  constructor() {
    super({
      queryCore,
      endpointKey: 'users',
      schema: z.array(UserSchema),
    });
  }
}

// Create ViewModel
class UsersViewModel extends QueryStateModelView<User[], typeof UserSchema> {
  constructor() {
    super(new UsersQueryModel());
  }
}

const vm = new UsersViewModel();

// Subscribe to data
vm.data$.subscribe((users) => console.log('Users:', users));

// Refetch data
await vm.refetchCommand.execute(true); // Force refetch

// Invalidate cache
await vm.invalidateCommand.execute();
```

## Usage Examples

### Example 1: Simple user management

`RestfulApiModel` and `RestfulApiViewModel` work together to fetch lists, expose computed values, and keep CRUD commands reactive.

```typescript
class UserViewModel extends RestfulApiViewModel<User[], typeof UserSchema> {
  constructor() {
    super(new UserModel());
  }

  get adminUsers$(): Observable<User[]> {
    return this.data$.pipe(map((users) => users?.filter((user) => user.role === 'admin') || []));
  }

  async promoteToAdmin(userId: string): Promise<void> {
    await this.updateCommand.execute({
      id: userId,
      data: { role: 'admin' }
    });
  }
}

const vm = new UserViewModel();
await vm.fetchCommand.execute();
vm.adminUsers$.subscribe((admins) => console.log('Admins:', admins));
await vm.promoteToAdmin('user-123');
```

### Example 2: Validated registration form

Use `FormViewModel` to declare validation rules, capture per-field errors, and run submit logic with a reusable schema.

```typescript
class RegistrationViewModel extends FormViewModel<RegistrationForm> {
  constructor(private authService: AuthService) {
    super({
      initialValues: { username: '', email: '', password: '', confirmPassword: '' },
      validationSchema: RegistrationSchema,
      validateOnChange: true,
      onSubmit: async (values) => {
        await this.authService.register(values);
      }
    });
  }

  async checkUsername(username: string): Promise<void> {
    const available = await this.authService.isUsernameAvailable(username);
    if (!available) {
      this.setFieldError('username', 'Username already taken');
    }
  }
}
```

### Example 3: Paginated, filterable collections

`QueryableCollectionViewModel` layers filtering, sorting, and pagination on top of any item list while keeping all updates observable.

```typescript
class ProductListViewModel {
  private collectionVm = new QueryableCollectionViewModel<Product>({ items: products, pageSize: 10 });

  filterByCategory(category: string) {
    this.collectionVm.setFilter((product) => product.category === category);
  }

  sortByPrice(order: 'asc' | 'desc' = 'asc') {
    this.collectionVm.setSortBy('price', order);
  }
}
```

### Example 4: Master-detail commands

Commands keep user actions reactive by combining `canExecute$`, `isExecuting$`, and async work into a single construct.

```typescript
class OrderDetailViewModel extends BaseViewModel<OrderModel> {
  readonly approveCommand = new Command(async () => this.model.update({ status: 'approved' }), this.data$.pipe(map((order) => order?.status === 'pending')));
  readonly rejectCommand = new Command(async (reason: string) => this.model.update({ status: 'rejected', rejectionReason: reason }), this.data$.pipe(map((order) => order?.status === 'pending')));
  readonly cancelCommand = new Command(async () => this.model.update({ status: 'cancelled' }), this.data$.pipe(map((order) => order?.status === 'approved')));
}
```

## Best Practices

- Dispose ViewModels and collections when components unmount to keep subscriptions from leaking.
  ```tsx
  useEffect(() => {
    const vm = new MyViewModel();
    return () => vm.dispose();
  }, []);
  ```
- Define strict Zod schemas for every public model and reuse them across models, forms, and query state.
- Build derived state with computed observables (`map`, `combineLatest`, etc.) instead of tying logic to a framework.
- Subscribe to `error$` and command error streams to surface issues and wrap fetch calls in `try/catch` for polish.
- Use helpers like `takeUntil` or dedicated destroy streams during Angular/ngOnDestroy lifecycles to enforce cleanup.
- Test ViewModels in isolation (mock fetchers/commands) so business logic stays predictable without rendering UI.
- Keep ViewModels framework-agnostic and prefer `Command` instances over ad-hoc methods for actions.

## Framework Integration

### React

```tsx
import { useState, useEffect, useMemo } from 'react';
import { Observable } from 'rxjs';

// Custom hook for RxJS observables
function useObservable<T>(observable: Observable<T>, initialValue: T): T {
  const [value, setValue] = useState<T>(initialValue);

  useEffect(() => {
    const subscription = observable.subscribe(setValue);
    return () => subscription.unsubscribe();
  }, [observable]);

  return value;
}

// Component
function UserList() {
  const vm = useMemo(() => new UserListViewModel(), []);
  const users = useObservable(vm.data$, null);
  const isLoading = useObservable(vm.isLoading$, false);
  const error = useObservable(vm.error$, null);

  useEffect(() => {
    vm.fetchCommand.execute();
    return () => vm.dispose();
  }, [vm]);

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {users?.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### Angular

```typescript
import { Component, OnInit, OnDestroy } from '@angular/core';
import { UserListViewModel } from './viewmodels/user-list.viewmodel';

@Component({
  selector: 'app-user-list',
  template: `
    <div *ngIf="vm.isLoading$ | async">Loading...</div>
    <div *ngIf="vm.error$ | async as error">Error: {{ error.message }}</div>
    <ul *ngIf="vm.data$ | async as users">
      <li *ngFor="let user of users">{{ user.name }}</li>
    </ul>
  `,
  providers: [UserListViewModel],
})
export class UserListComponent implements OnInit, OnDestroy {
  constructor(public vm: UserListViewModel) {}

  ngOnInit() {
    this.vm.fetchCommand.execute();
  }

  ngOnDestroy() {
    this.vm.dispose();
  }
}
```

### Vue

```vue
<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch } from 'vue';
import { UserListViewModel } from './viewmodels/user-list.viewmodel';

const vm = new UserListViewModel();
const users = ref([]);
const isLoading = ref(false);
const error = ref(null);

watch(
  () => vm.data$,
  (obs) => {
    obs.subscribe((data) => (users.value = data));
  },
);

watch(
  () => vm.isLoading$,
  (obs) => {
    obs.subscribe((loading) => (isLoading.value = loading));
  },
);

watch(
  () => vm.error$,
  (obs) => {
    obs.subscribe((err) => (error.value = err));
  },
);

onMounted(() => {
  vm.fetchCommand.execute();
});

onUnmounted(() => {
  vm.dispose();
});
</script>

<template>
  <div v-if="isLoading">Loading...</div>
  <div v-if="error">Error: {{ error.message }}</div>
  <ul v-if="users">
    <li v-for="user in users" :key="user.id">{{ user.name }}</li>
  </ul>
</template>
```
