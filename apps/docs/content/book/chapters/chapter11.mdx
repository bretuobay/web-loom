# Chapter 10: Vue Implementation — Proving Framework Independence

We've proven MVVM works brilliantly in React. Now let's demonstrate the real power of our architecture: we'll build the exact same GreenWatch features in Vue 3, reusing every single line of business logic. No rewrites. No adaptations. Just different view bindings.

This isn't a theoretical exercise. This is the architectural payoff we've been building toward since Chapter 1. When we separated concerns properly—when we kept ViewModels framework-agnostic and domain logic pure—we earned the ability to port our application to any view layer with minimal friction.

## Why This Chapter Matters

You might be thinking: "We already built GreenWatch in React. Why do it again in Vue?"

Because **framework lock-in is expensive**. Companies pivot. Technologies evolve. That React codebase you're maintaining today? In three years, your team might need to migrate it. If your business logic is tangled with React hooks and component lifecycle, you're facing a complete rewrite. But if you've built with proper separation, you're swapping out view adapters while your core logic stays intact.

We're not advocating for Vue over React or vice versa. We're advocating for **architectural independence**. This chapter proves our architecture delivers on that promise.

## What We'll Build

We'll implement three key GreenWatch features in Vue:

1. **Environmental Monitoring Dashboard** — Real-time sensor data with reactive updates
2. **Greenhouse Management** — CRUD operations with optimistic updates
3. **Alert Configuration** — Complex form handling with validation

These are the same features we built in React (Chapter 8). We'll use the exact same ViewModels. The only changes will be in how Vue components consume and bind to those ViewModels.

## Vue 3's Reactive Paradigm

Before we dive in, let's acknowledge Vue's different reactive model. React uses explicit state updates (`setState`, `useState`). Vue uses proxied reactivity—it detects property access and mutations automatically.

This difference is **purely presentational**. Our ViewModels expose observables. Whether React subscribes with `useEffect` or Vue subscribes with `watchEffect` doesn't matter to the ViewModel. It's publishing state changes through RxJS; the view layer decides how to consume them.

## Setting Up Vue with Our Architecture

First, we need a composable that adapts our ViewModels to Vue's reactivity system. This is our boundary layer—the only Vue-specific code we'll write.

```typescript
// composables/useViewModel.ts
import { ref, onMounted, onUnmounted, type Ref } from 'vue';
import { Observable } from 'rxjs';

/**
 * Bridges RxJS observables to Vue's reactivity system.
 * This is the ONLY framework-specific adapter we need.
 */
export function useObservable<T>(observable: Observable<T>, initialValue: T): Ref<T> {
  const value = ref<T>(initialValue);
  let subscription: any;

  onMounted(() => {
    subscription = observable.subscribe({
      next: (newValue) => {
        value.value = newValue;
      },
      error: (err) => {
        console.error('Observable error:', err);
      },
    });
  });

  onUnmounted(() => {
    subscription?.unsubscribe();
  });

  return value as Ref<T>;
}

/**
 * Creates and manages a ViewModel's lifecycle within a Vue component.
 * Handles dependency injection and cleanup.
 */
export function useViewModel<T>(ViewModelClass: new (...args: any[]) => T, ...dependencies: any[]): T {
  const viewModel = new ViewModelClass(...dependencies);

  onUnmounted(() => {
    // Clean up ViewModel resources if it implements cleanup
    if ('dispose' in viewModel && typeof viewModel.dispose === 'function') {
      (viewModel as any).dispose();
    }
  });

  return viewModel;
}
```

This composable does two critical things:

1. **`useObservable`** — Converts any RxJS observable into a Vue ref. Vue components can now bind to ViewModel state naturally.
2. **`useViewModel`** — Instantiates ViewModels with proper lifecycle management. It's the Vue equivalent of our React hook.

Notice what we're NOT doing: we're not modifying ViewModels to work with Vue. We're building a thin adapter that speaks Vue's language while our ViewModels continue speaking RxJS.

## Environmental Monitoring in Vue

Let's implement our real-time environmental dashboard. This component displays live sensor readings with automatic updates.

```typescript
// viewmodels/EnvironmentalMonitoringViewModel.ts
// This ViewModel is IDENTICAL to what we used in React
import { BehaviorSubject, Observable, combineLatest } from 'rxjs';
import { map } from 'rxjs/operators';
import { SensorReadingService } from '@/domain/services/SensorReadingService';
import { GreenhouseId, SensorReading, EnvironmentalStatus } from '@/domain/types';

export interface EnvironmentalMonitoringState {
  readings: SensorReading[];
  status: EnvironmentalStatus;
  lastUpdated: Date | null;
  isLoading: boolean;
  error: string | null;
}

export class EnvironmentalMonitoringViewModel {
  private readonly readingsSubject = new BehaviorSubject<SensorReading[]>([]);
  private readonly statusSubject = new BehaviorSubject<EnvironmentalStatus>('normal');
  private readonly lastUpdatedSubject = new BehaviorSubject<Date | null>(null);
  private readonly loadingSubject = new BehaviorSubject<boolean>(true);
  private readonly errorSubject = new BehaviorSubject<string | null>(null);

  // Expose state as a single observable for convenient consumption
  readonly state$: Observable<EnvironmentalMonitoringState> = combineLatest([
    this.readingsSubject,
    this.statusSubject,
    this.lastUpdatedSubject,
    this.loadingSubject,
    this.errorSubject,
  ]).pipe(
    map(([readings, status, lastUpdated, isLoading, error]) => ({
      readings,
      status,
      lastUpdated,
      isLoading,
      error,
    })),
  );

  constructor(
    private readonly sensorService: SensorReadingService,
    private readonly greenhouseId: GreenhouseId,
  ) {
    this.initialize();
  }

  private async initialize(): Promise<void> {
    try {
      // Subscribe to real-time sensor updates
      this.sensorService.streamReadings(this.greenhouseId).subscribe({
        next: (reading) => this.handleNewReading(reading),
        error: (err) => this.handleError(err),
      });

      // Load initial data
      const initialReadings = await this.sensorService.getCurrentReadings(this.greenhouseId);
      this.readingsSubject.next(initialReadings);
      this.loadingSubject.next(false);
    } catch (error) {
      this.handleError(error);
    }
  }

  private handleNewReading(reading: SensorReading): void {
    const currentReadings = this.readingsSubject.value;
    const updatedReadings = this.updateReadingsList(currentReadings, reading);

    this.readingsSubject.next(updatedReadings);
    this.lastUpdatedSubject.next(new Date());
    this.statusSubject.next(this.calculateStatus(updatedReadings));
  }

  private updateReadingsList(current: SensorReading[], newReading: SensorReading): SensorReading[] {
    const index = current.findIndex((r) => r.sensorId === newReading.sensorId);
    if (index >= 0) {
      const updated = [...current];
      updated[index] = newReading;
      return updated;
    }
    return [...current, newReading];
  }

  private calculateStatus(readings: SensorReading[]): EnvironmentalStatus {
    const hasWarning = readings.some((r) => r.isOutOfRange);
    const hasCritical = readings.some((r) => r.isCritical);

    if (hasCritical) return 'critical';
    if (hasWarning) return 'warning';
    return 'normal';
  }

  private handleError(error: unknown): void {
    this.errorSubject.next(error instanceof Error ? error.message : 'Unknown error occurred');
    this.loadingSubject.next(false);
  }

  dispose(): void {
    // Clean up subscriptions
    this.readingsSubject.complete();
    this.statusSubject.complete();
    this.lastUpdatedSubject.complete();
    this.loadingSubject.complete();
    this.errorSubject.complete();
  }
}
```

Now let's see how Vue consumes this ViewModel:

```vue
<!-- components/EnvironmentalMonitoring.vue -->
<script setup lang="ts">
import { computed } from 'vue';
import { useViewModel, useObservable } from '@/composables/useViewModel';
import { EnvironmentalMonitoringViewModel } from '@/viewmodels/EnvironmentalMonitoringViewModel';
import { useSensorReadingService } from '@/composables/useServices';
import SensorCard from './SensorCard.vue';
import StatusBadge from './StatusBadge.vue';

interface Props {
  greenhouseId: string;
}

const props = defineProps<Props>();

// Inject dependencies and create ViewModel
const sensorService = useSensorReadingService();
const viewModel = useViewModel(EnvironmentalMonitoringViewModel, sensorService, props.greenhouseId);

// Bind to ViewModel state
const state = useObservable(viewModel.state$, {
  readings: [],
  status: 'normal',
  lastUpdated: null,
  isLoading: true,
  error: null,
});

// Derived state for presentation
const statusColor = computed(() => {
  const colors = {
    normal: 'green',
    warning: 'yellow',
    critical: 'red',
  };
  return colors[state.value.status];
});

const formattedLastUpdate = computed(() => {
  if (!state.value.lastUpdated) return 'Never';
  return new Intl.DateTimeFormat('en-US', {
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric',
  }).format(state.value.lastUpdated);
});
</script>

<template>
  <div class="environmental-monitoring">
    <header class="monitoring-header">
      <h2>Environmental Monitoring</h2>
      <div class="status-info">
        <StatusBadge :status="state.status" :color="statusColor" />
        <span class="last-update"> Last updated: {{ formattedLastUpdate }} </span>
      </div>
    </header>

    <div v-if="state.isLoading" class="loading">Loading sensor data...</div>

    <div v-else-if="state.error" class="error">
      <p>{{ state.error }}</p>
      <button @click="() => location.reload()">Retry</button>
    </div>

    <div v-else class="sensor-grid">
      <SensorCard v-for="reading in state.readings" :key="reading.sensorId" :reading="reading" />
    </div>
  </div>
</template>

<style scoped>
.environmental-monitoring {
  padding: 1.5rem;
}

.monitoring-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
}

.status-info {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.last-update {
  color: var(--text-secondary);
  font-size: 0.875rem;
}

.sensor-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1.5rem;
}

.loading,
.error {
  text-align: center;
  padding: 3rem;
}

.error button {
  margin-top: 1rem;
  padding: 0.5rem 1rem;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
</style>
```

**What just happened?** We took our framework-agnostic ViewModel and bound it to Vue with exactly **three lines of Vue-specific code**:

1. `useSensorReadingService()` — Dependency injection (we'd write this for any framework)
2. `useViewModel()` — ViewModel instantiation with lifecycle management
3. `useObservable()` — Observable-to-ref conversion

Everything else—the business logic, state management, real-time updates—lives in the ViewModel. Vue's template syntax differs from React's JSX, but that's purely presentational. The architectural separation holds.

## Greenhouse Management with Optimistic Updates

Now let's tackle a more complex scenario: CRUD operations with optimistic UI updates. When users create or modify a greenhouse configuration, we want the UI to respond immediately while the API request processes in the background.

```typescript
// viewmodels/GreenhouseManagementViewModel.ts
// Again, IDENTICAL to what we'd use in React
import { BehaviorSubject, Observable, Subject } from 'rxjs';
import { map } from 'rxjs/operators';
import { GreenhouseService } from '@/domain/services/GreenhouseService';
import { Greenhouse, CreateGreenhouseDto, UpdateGreenhouseDto, GreenhouseId } from '@/domain/types';

interface GreenhouseManagementState {
  greenhouses: Greenhouse[];
  selectedGreenhouse: Greenhouse | null;
  isLoading: boolean;
  isSaving: boolean;
  error: string | null;
}

export class GreenhouseManagementViewModel {
  private readonly greenhousesSubject = new BehaviorSubject<Greenhouse[]>([]);
  private readonly selectedSubject = new BehaviorSubject<Greenhouse | null>(null);
  private readonly loadingSubject = new BehaviorSubject<boolean>(true);
  private readonly savingSubject = new BehaviorSubject<boolean>(false);
  private readonly errorSubject = new BehaviorSubject<string | null>(null);

  // Command pattern for user actions
  private readonly createCommand = new Subject<CreateGreenhouseDto>();
  private readonly updateCommand = new Subject<{ id: GreenhouseId; data: UpdateGreenhouseDto }>();
  private readonly deleteCommand = new Subject<GreenhouseId>();

  readonly state$: Observable<GreenhouseManagementState> = this.buildState();

  constructor(private readonly greenhouseService: GreenhouseService) {
    this.initialize();
    this.setupCommandHandlers();
  }

  private buildState(): Observable<GreenhouseManagementState> {
    return this.greenhousesSubject.pipe(
      map((greenhouses) => ({
        greenhouses,
        selectedGreenhouse: this.selectedSubject.value,
        isLoading: this.loadingSubject.value,
        isSaving: this.savingSubject.value,
        error: this.errorSubject.value,
      })),
    );
  }

  private async initialize(): Promise<void> {
    try {
      const greenhouses = await this.greenhouseService.list();
      this.greenhousesSubject.next(greenhouses);
      this.loadingSubject.next(false);
    } catch (error) {
      this.handleError(error);
    }
  }

  private setupCommandHandlers(): void {
    this.createCommand.subscribe((dto) => this.handleCreate(dto));
    this.updateCommand.subscribe(({ id, data }) => this.handleUpdate(id, data));
    this.deleteCommand.subscribe((id) => this.handleDelete(id));
  }

  // Public API for view layer
  createGreenhouse(data: CreateGreenhouseDto): void {
    this.createCommand.next(data);
  }

  updateGreenhouse(id: GreenhouseId, data: UpdateGreenhouseDto): void {
    this.updateCommand.next({ id, data });
  }

  deleteGreenhouse(id: GreenhouseId): void {
    this.deleteCommand.next(id);
  }

  selectGreenhouse(id: GreenhouseId): void {
    const greenhouse = this.greenhousesSubject.value.find((g) => g.id === id);
    this.selectedSubject.next(greenhouse || null);
  }

  private async handleCreate(data: CreateGreenhouseDto): Promise<void> {
    this.savingSubject.next(true);
    this.errorSubject.next(null);

    // Optimistic update: add placeholder immediately
    const optimisticId = `temp-${Date.now()}`;
    const optimisticGreenhouse: Greenhouse = {
      id: optimisticId as GreenhouseId,
      ...data,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.greenhousesSubject.next([...this.greenhousesSubject.value, optimisticGreenhouse]);

    try {
      const created = await this.greenhouseService.create(data);

      // Replace optimistic entry with real data
      const updated = this.greenhousesSubject.value.map((g) => (g.id === optimisticId ? created : g));
      this.greenhousesSubject.next(updated);
    } catch (error) {
      // Rollback optimistic update on failure
      const rolledBack = this.greenhousesSubject.value.filter((g) => g.id !== optimisticId);
      this.greenhousesSubject.next(rolledBack);
      this.handleError(error);
    } finally {
      this.savingSubject.next(false);
    }
  }

  private async handleUpdate(id: GreenhouseId, data: UpdateGreenhouseDto): Promise<void> {
    this.savingSubject.next(true);
    this.errorSubject.next(null);

    // Store original for rollback
    const original = this.greenhousesSubject.value.find((g) => g.id === id);
    if (!original) {
      this.errorSubject.next('Greenhouse not found');
      this.savingSubject.next(false);
      return;
    }

    // Optimistic update
    const optimistic: Greenhouse = {
      ...original,
      ...data,
      updatedAt: new Date(),
    };

    this.greenhousesSubject.next(this.greenhousesSubject.value.map((g) => (g.id === id ? optimistic : g)));

    try {
      const updated = await this.greenhouseService.update(id, data);
      this.greenhousesSubject.next(this.greenhousesSubject.value.map((g) => (g.id === id ? updated : g)));
    } catch (error) {
      // Rollback to original
      this.greenhousesSubject.next(this.greenhousesSubject.value.map((g) => (g.id === id ? original : g)));
      this.handleError(error);
    } finally {
      this.savingSubject.next(false);
    }
  }

  private async handleDelete(id: GreenhouseId): Promise<void> {
    this.savingSubject.next(true);
    this.errorSubject.next(null);

    const original = this.greenhousesSubject.value;

    // Optimistic delete
    this.greenhousesSubject.next(original.filter((g) => g.id !== id));

    try {
      await this.greenhouseService.delete(id);
      // If selected greenhouse was deleted, clear selection
      if (this.selectedSubject.value?.id === id) {
        this.selectedSubject.next(null);
      }
    } catch (error) {
      // Rollback deletion
      this.greenhousesSubject.next(original);
      this.handleError(error);
    } finally {
      this.savingSubject.next(false);
    }
  }

  private handleError(error: unknown): void {
    this.errorSubject.next(error instanceof Error ? error.message : 'Operation failed');
    this.loadingSubject.next(false);
    this.savingSubject.next(false);
  }

  dispose(): void {
    this.greenhousesSubject.complete();
    this.selectedSubject.complete();
    this.loadingSubject.complete();
    this.savingSubject.complete();
    this.errorSubject.complete();
    this.createCommand.complete();
    this.updateCommand.complete();
    this.deleteCommand.complete();
  }
}
```

The Vue component that consumes this ViewModel:

```vue
<!-- components/GreenhouseManagement.vue -->
<script setup lang="ts">
import { ref, computed } from 'vue';
import { useViewModel, useObservable } from '@/composables/useViewModel';
import { GreenhouseManagementViewModel } from '@/viewmodels/GreenhouseManagementViewModel';
import { useGreenhouseService } from '@/composables/useServices';
import GreenhouseCard from './GreenhouseCard.vue';
import GreenhouseForm from './GreenhouseForm.vue';
import type { CreateGreenhouseDto, UpdateGreenhouseDto } from '@/domain/types';

const greenhouseService = useGreenhouseService();
const viewModel = useViewModel(GreenhouseManagementViewModel, greenhouseService);

const state = useObservable(viewModel.state$, {
  greenhouses: [],
  selectedGreenhouse: null,
  isLoading: true,
  isSaving: false,
  error: null,
});

const showCreateForm = ref(false);
const showEditForm = ref(false);

const sortedGreenhouses = computed(() => {
  return [...state.value.greenhouses].sort((a, b) => a.name.localeCompare(b.name));
});

function handleCreate(data: CreateGreenhouseDto) {
  viewModel.createGreenhouse(data);
  showCreateForm.value = false;
}

function handleUpdate(data: UpdateGreenhouseDto) {
  if (state.value.selectedGreenhouse) {
    viewModel.updateGreenhouse(state.value.selectedGreenhouse.id, data);
    showEditForm.value = false;
  }
}

function handleDelete(id: string) {
  if (confirm('Are you sure you want to delete this greenhouse?')) {
    viewModel.deleteGreenhouse(id as any);
  }
}

function handleSelect(id: string) {
  viewModel.selectGreenhouse(id as any);
  showEditForm.value = true;
}
</script>

<template>
  <div class="greenhouse-management">
    <header class="management-header">
      <h2>Greenhouse Management</h2>
      <button @click="showCreateForm = true" :disabled="state.isSaving" class="btn-primary">Add Greenhouse</button>
    </header>

    <div v-if="state.error" class="error-banner">
      {{ state.error }}
    </div>

    <div v-if="state.isLoading" class="loading">Loading greenhouses...</div>

    <div v-else class="greenhouse-grid">
      <GreenhouseCard
        v-for="greenhouse in sortedGreenhouses"
        :key="greenhouse.id"
        :greenhouse="greenhouse"
        :is-saving="state.isSaving"
        @select="handleSelect"
        @delete="handleDelete"
      />
    </div>

    <!-- Create Form Modal -->
    <Teleport to="body">
      <GreenhouseForm
        v-if="showCreateForm"
        mode="create"
        :is-saving="state.isSaving"
        @submit="handleCreate"
        @cancel="showCreateForm = false"
      />
    </Teleport>

    <!-- Edit Form Modal -->
    <Teleport to="body">
      <GreenhouseForm
        v-if="showEditForm && state.selectedGreenhouse"
        mode="edit"
        :greenhouse="state.selectedGreenhouse"
        :is-saving="state.isSaving"
        @submit="handleUpdate"
        @cancel="showEditForm = false"
      />
    </Teleport>
  </div>
</template>

<style scoped>
.greenhouse-management {
  padding: 1.5rem;
}

.management-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
}

.btn-primary {
  padding: 0.75rem 1.5rem;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
}

.btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.error-banner {
  padding: 1rem;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 4px;
  color: #c00;
  margin-bottom: 1rem;
}

.greenhouse-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 1.5rem;
}

.loading {
  text-align: center;
  padding: 3rem;
  color: var(--text-secondary);
}
</style>
```

## Alert Configuration with Complex Validation

Our final example demonstrates form handling with multi-field validation, conditional logic, and proper error messaging. Alert configuration is complex—users define thresholds, notification preferences, and escalation rules. We need validation that's both immediate (as users type) and comprehensive (before submission).

```typescript
// viewmodels/AlertConfigurationViewModel.ts
import { BehaviorSubject, Observable, combineLatest } from 'rxjs';
import { map, debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { AlertService } from '@/domain/services/AlertService';
import { AlertConfiguration, AlertType, ThresholdConfig, NotificationChannel, ValidationError } from '@/domain/types';

interface AlertConfigForm {
  alertType: AlertType;
  enabled: boolean;
  thresholds: ThresholdConfig;
  channels: NotificationChannel[];
  escalationMinutes: number;
}

interface AlertConfigState {
  form: AlertConfigForm;
  validation: ValidationError[];
  isValid: boolean;
  isSaving: boolean;
  isDirty: boolean;
  error: string | null;
}

export class AlertConfigurationViewModel {
  private readonly formSubject = new BehaviorSubject<AlertConfigForm>(this.createDefaultForm());
  private readonly validationSubject = new BehaviorSubject<ValidationError[]>([]);
  private readonly savingSubject = new BehaviorSubject<boolean>(false);
  private readonly dirtySubject = new BehaviorSubject<boolean>(false);
  private readonly errorSubject = new BehaviorSubject<string | null>(null);

  readonly state$: Observable<AlertConfigState> = this.buildState();

  constructor(
    private readonly alertService: AlertService,
    private readonly initialConfig?: AlertConfiguration,
  ) {
    if (initialConfig) {
      this.loadConfiguration(initialConfig);
    }
    this.setupValidation();
  }

  private buildState(): Observable<AlertConfigState> {
    return combineLatest([
      this.formSubject,
      this.validationSubject,
      this.savingSubject,
      this.dirtySubject,
      this.errorSubject,
    ]).pipe(
      map(([form, validation, isSaving, isDirty, error]) => ({
        form,
        validation,
        isValid: validation.length === 0,
        isSaving,
        isDirty,
        error,
      })),
    );
  }

  private createDefaultForm(): AlertConfigForm {
    return {
      alertType: 'temperature',
      enabled: true,
      thresholds: {
        min: 15,
        max: 30,
        warning: 2,
        critical: 5,
      },
      channels: ['email'],
      escalationMinutes: 15,
    };
  }

  private loadConfiguration(config: AlertConfiguration): void {
    this.formSubject.next({
      alertType: config.type,
      enabled: config.enabled,
      thresholds: config.thresholds,
      channels: config.notificationChannels,
      escalationMinutes: config.escalationDelayMinutes,
    });
  }

  private setupValidation(): void {
    // Validate on every form change, with debounce for performance
    this.formSubject
      .pipe(
        debounceTime(300),
        distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)),
      )
      .subscribe((form) => {
        const errors = this.validateForm(form);
        this.validationSubject.next(errors);
      });
  }

  private validateForm(form: AlertConfigForm): ValidationError[] {
    const errors: ValidationError[] = [];

    // Threshold validation
    if (form.thresholds.min >= form.thresholds.max) {
      errors.push({
        field: 'thresholds',
        message: 'Minimum threshold must be less than maximum',
      });
    }

    if (form.thresholds.warning <= 0) {
      errors.push({
        field: 'thresholds.warning',
        message: 'Warning buffer must be positive',
      });
    }

    if (form.thresholds.critical <= form.thresholds.warning) {
      errors.push({
        field: 'thresholds.critical',
        message: 'Critical buffer must be greater than warning buffer',
      });
    }

    // Alert type-specific validation
    if (form.alertType === 'temperature') {
      if (form.thresholds.min < -10 || form.thresholds.max > 50) {
        errors.push({
          field: 'thresholds',
          message: 'Temperature must be between -10°C and 50°C',
        });
      }
    }

    if (form.alertType === 'humidity') {
      if (form.thresholds.min < 0 || form.thresholds.max > 100) {
        errors.push({
          field: 'thresholds',
          message: 'Humidity must be between 0% and 100%',
        });
      }
    }

    // Notification validation
    if (form.channels.length === 0) {
      errors.push({
        field: 'channels',
        message: 'At least one notification channel required',
      });
    }

    // Escalation validation
    if (form.escalationMinutes < 5) {
      errors.push({
        field: 'escalationMinutes',
        message: 'Escalation delay must be at least 5 minutes',
      });
    }

    return errors;
  }

  // Public API for form updates
  updateAlertType(type: AlertType): void {
    this.formSubject.next({
      ...this.formSubject.value,
      alertType: type,
    });
    this.markDirty();
  }

  toggleEnabled(): void {
    this.formSubject.next({
      ...this.formSubject.value,
      enabled: !this.formSubject.value.enabled,
    });
    this.markDirty();
  }

  updateThreshold(key: keyof ThresholdConfig, value: number): void {
    this.formSubject.next({
      ...this.formSubject.value,
      thresholds: {
        ...this.formSubject.value.thresholds,
        [key]: value,
      },
    });
    this.markDirty();
  }

  toggleChannel(channel: NotificationChannel): void {
    const current = this.formSubject.value.channels;
    const updated = current.includes(channel) ? current.filter((c) => c !== channel) : [...current, channel];

    this.formSubject.next({
      ...this.formSubject.value,
      channels: updated,
    });
    this.markDirty();
  }

  updateEscalation(minutes: number): void {
    this.formSubject.next({
      ...this.formSubject.value,
      escalationMinutes: minutes,
    });
    this.markDirty();
  }

  async save(): Promise<void> {
    const errors = this.validateForm(this.formSubject.value);
    if (errors.length > 0) {
      this.validationSubject.next(errors);
      return;
    }

    this.savingSubject.next(true);
    this.errorSubject.next(null);

    try {
      const config = this.formToConfig(this.formSubject.value);
      await this.alertService.saveConfiguration(config);
      this.dirtySubject.next(false);
    } catch (error) {
      this.errorSubject.next(error instanceof Error ? error.message : 'Failed to save configuration');
    } finally {
      this.savingSubject.next(false);
    }
  }

  reset(): void {
    if (this.initialConfig) {
      this.loadConfiguration(this.initialConfig);
    } else {
      this.formSubject.next(this.createDefaultForm());
    }
    this.dirtySubject.next(false);
    this.errorSubject.next(null);
  }

  private formToConfig(form: AlertConfigForm): AlertConfiguration {
    return {
      id: this.initialConfig?.id || (`new-${Date.now()}` as any),
      type: form.alertType,
      enabled: form.enabled,
      thresholds: form.thresholds,
      notificationChannels: form.channels,
      escalationDelayMinutes: form.escalationMinutes,
      createdAt: this.initialConfig?.createdAt || new Date(),
      updatedAt: new Date(),
    };
  }

  private markDirty(): void {
    this.dirtySubject.next(true);
  }

  dispose(): void {
    this.formSubject.complete();
    this.validationSubject.complete();
    this.savingSubject.complete();
    this.dirtySubject.complete();
    this.errorSubject.complete();
  }
}
```

Now the Vue component:

```vue
<!-- components/AlertConfiguration.vue -->
<script setup lang="ts">
import { computed } from 'vue';
import { useViewModel, useObservable } from '@/composables/useViewModel';
import { AlertConfigurationViewModel } from '@/viewmodels/AlertConfigurationViewModel';
import { useAlertService } from '@/composables/useServices';
import type { AlertType, NotificationChannel } from '@/domain/types';

interface Props {
  configId?: string;
}

const props = defineProps<Props>();

const alertService = useAlertService();
const viewModel = useViewModel(AlertConfigurationViewModel, alertService);

const state = useObservable(viewModel.state$, {
  form: viewModel['formSubject'].value,
  validation: [],
  isValid: false,
  isSaving: false,
  isDirty: false,
  error: null,
});

const alertTypes: AlertType[] = ['temperature', 'humidity', 'soilMoisture', 'light'];
const channels: NotificationChannel[] = ['email', 'sms', 'push', 'webhook'];

const hasError = (field: string) => {
  return state.value.validation.some((v) => v.field === field);
};

const getError = (field: string) => {
  return state.value.validation.find((v) => v.field === field)?.message;
};

const canSave = computed(() => {
  return state.value.isValid && state.value.isDirty && !state.value.isSaving;
});

function handleSave() {
  viewModel.save();
}

function handleReset() {
  if (state.value.isDirty) {
    if (confirm('Discard unsaved changes?')) {
      viewModel.reset();
    }
  }
}
</script>

<template>
  <div class="alert-configuration">
    <header class="config-header">
      <h2>Alert Configuration</h2>
      <div class="header-actions">
        <button @click="handleReset" :disabled="!state.isDirty || state.isSaving" class="btn-secondary">Reset</button>
        <button @click="handleSave" :disabled="!canSave" class="btn-primary">
          {{ state.isSaving ? 'Saving...' : 'Save Configuration' }}
        </button>
      </div>
    </header>

    <div v-if="state.error" class="error-banner">
      {{ state.error }}
    </div>

    <form class="config-form" @submit.prevent="handleSave">
      <!-- Alert Type Selection -->
      <section class="form-section">
        <h3>Alert Type</h3>
        <div class="radio-group">
          <label v-for="type in alertTypes" :key="type" class="radio-label">
            <input
              type="radio"
              :value="type"
              :checked="state.form.alertType === type"
              @change="() => viewModel.updateAlertType(type)"
            />
            <span>{{ type.charAt(0).toUpperCase() + type.slice(1) }}</span>
          </label>
        </div>
      </section>

      <!-- Enabled Toggle -->
      <section class="form-section">
        <label class="toggle-label">
          <input type="checkbox" :checked="state.form.enabled" @change="viewModel.toggleEnabled()" />
          <span>Enable Alerts</span>
        </label>
      </section>

      <!-- Threshold Configuration -->
      <section class="form-section">
        <h3>Thresholds</h3>
        <div class="threshold-grid">
          <div class="form-field">
            <label>
              Minimum Value
              <input
                type="number"
                :value="state.form.thresholds.min"
                @input="(e) => viewModel.updateThreshold('min', Number(e.target.value))"
                :class="{ error: hasError('thresholds') }"
              />
            </label>
          </div>

          <div class="form-field">
            <label>
              Maximum Value
              <input
                type="number"
                :value="state.form.thresholds.max"
                @input="(e) => viewModel.updateThreshold('max', Number(e.target.value))"
                :class="{ error: hasError('thresholds') }"
              />
            </label>
          </div>

          <div class="form-field">
            <label>
              Warning Buffer
              <input
                type="number"
                :value="state.form.thresholds.warning"
                @input="(e) => viewModel.updateThreshold('warning', Number(e.target.value))"
                :class="{ error: hasError('thresholds.warning') }"
              />
            </label>
          </div>

          <div class="form-field">
            <label>
              Critical Buffer
              <input
                type="number"
                :value="state.form.thresholds.critical"
                @input="(e) => viewModel.updateThreshold('critical', Number(e.target.value))"
                :class="{ error: hasError('thresholds.critical') }"
              />
            </label>
          </div>
        </div>

        <div v-if="hasError('thresholds')" class="field-error">
          {{ getError('thresholds') }}
        </div>
      </section>

      <!-- Notification Channels -->
      <section class="form-section">
        <h3>Notification Channels</h3>
        <div class="checkbox-group">
          <label v-for="channel in channels" :key="channel" class="checkbox-label">
            <input
              type="checkbox"
              :checked="state.form.channels.includes(channel)"
              @change="() => viewModel.toggleChannel(channel)"
            />
            <span>{{ channel.toUpperCase() }}</span>
          </label>
        </div>
        <div v-if="hasError('channels')" class="field-error">
          {{ getError('channels') }}
        </div>
      </section>

      <!-- Escalation Delay -->
      <section class="form-section">
        <h3>Escalation</h3>
        <div class="form-field">
          <label>
            Delay Before Escalation (minutes)
            <input
              type="number"
              :value="state.form.escalationMinutes"
              @input="(e) => viewModel.updateEscalation(Number(e.target.value))"
              :class="{ error: hasError('escalationMinutes') }"
              min="5"
              step="5"
            />
          </label>
          <div v-if="hasError('escalationMinutes')" class="field-error">
            {{ getError('escalationMinutes') }}
          </div>
        </div>
      </section>
    </form>
  </div>
</template>

<style scoped>
.alert-configuration {
  max-width: 800px;
  margin: 0 auto;
  padding: 2rem;
}

.config-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
}

.header-actions {
  display: flex;
  gap: 1rem;
}

.btn-primary,
.btn-secondary {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 4px;
  font-weight: 500;
  cursor: pointer;
}

.btn-primary {
  background: var(--primary-color);
  color: white;
}

.btn-secondary {
  background: var(--gray-200);
  color: var(--text-primary);
}

.btn-primary:disabled,
.btn-secondary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.error-banner {
  padding: 1rem;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 4px;
  color: #c00;
  margin-bottom: 1.5rem;
}

.config-form {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.form-section {
  padding: 1.5rem;
  background: var(--gray-50);
  border-radius: 8px;
}

.form-section h3 {
  margin: 0 0 1rem 0;
  font-size: 1.125rem;
}

.radio-group,
.checkbox-group {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

.radio-label,
.checkbox-label,
.toggle-label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
}

.threshold-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}

.form-field label {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  font-weight: 500;
}

.form-field input {
  padding: 0.5rem;
  border: 1px solid var(--gray-300);
  border-radius: 4px;
}

.form-field input.error {
  border-color: #c00;
}

.field-error {
  margin-top: 0.5rem;
  color: #c00;
  font-size: 0.875rem;
}
</style>
```

## Comparing React and Vue Implementations

Let's step back and examine what we've accomplished. We built identical features in two different frameworks using the same business logic. Here's what changed and what didn't:

**What Stayed the Same (Framework-Agnostic):**

- All ViewModels — zero modifications required
- Domain services and repositories
- Business logic and validation rules
- State management patterns
- Observable streams and RxJS operators
- Error handling strategies

**What Changed (Framework-Specific):**

- Template syntax (JSX vs Vue templates)
- The adapter composable (`useObservable`, `useViewModel`)
- Component lifecycle hooks
- Binding syntax (`onChange` vs `@input`)
- Conditional rendering (`{condition && <Component />}` vs `v-if`)

The adapter code—`useViewModel` and `useObservable`—is roughly 40 lines of TypeScript. That's the **entire** Vue-specific implementation cost. Everything else is just learning Vue's template syntax and component composition API, which you'd need to learn regardless of your architecture.

## Performance Considerations

You might wonder about performance when bridging RxJS observables to Vue's reactivity. Won't this create unnecessary overhead?

In practice, no. Vue's reactivity is extremely efficient. When we convert an observable to a ref, Vue tracks dependencies just like any other reactive value. The subscription management in `useObservable` ensures we're not creating memory leaks or redundant subscriptions.

That said, there are optimization strategies worth knowing:

**1. Selective Subscription**

Don't subscribe to everything. If your ViewModel exposes five observables but your component only needs three, only convert those three to refs.

```typescript
// ❌ Subscribing to unused state
const allState = useObservable(viewModel.state$, initialState);

// ✅ Subscribe only to what you need
const readings = useObservable(viewModel.readings$, []);
const status = useObservable(viewModel.status$, 'normal');
```

**2. Derived Computations in Vue, Not ViewModels**

ViewModels should expose raw state. Let Vue's computed properties handle presentation-layer derivations. This keeps ViewModels focused on business logic and leverages Vue's memoization.

```typescript
// In ViewModel: expose raw data
readonly readings$: Observable<SensorReading[]>;

// In Vue component: compute display values
const avgTemperature = computed(() => {
  return state.value.readings
    .reduce((sum, r) => sum + r.value, 0) / state.value.readings.length;
});
```

**3. Debouncing User Input**

For forms with live validation, debounce in the ViewModel, not the component. This keeps the debounce logic testable and framework-agnostic.

```typescript
// In ViewModel
private setupValidation(): void {
  this.formSubject.pipe(
    debounceTime(300), // Debounce here, not in Vue
    distinctUntilChanged()
  ).subscribe(form => {
    this.validationSubject.next(this.validateForm(form));
  });
}
```

## Testing Vue Components

Testing Vue components with our architecture is straightforward because we've separated concerns properly. You test ViewModels in isolation (as we covered in Chapter 9), and Vue components become simple binding verification.

Here's a test for our Environmental Monitoring component:

```typescript
// components/__tests__/EnvironmentalMonitoring.spec.ts
import { mount } from '@vue/test-utils';
import { BehaviorSubject } from 'rxjs';
import EnvironmentalMonitoring from '../EnvironmentalMonitoring.vue';
import { EnvironmentalMonitoringViewModel } from '@/viewmodels/EnvironmentalMonitoringViewModel';

// Mock the ViewModel
jest.mock('@/viewmodels/EnvironmentalMonitoringViewModel');

describe('EnvironmentalMonitoring', () => {
  let mockViewModel: jest.Mocked<EnvironmentalMonitoringViewModel>;
  let stateSubject: BehaviorSubject<any>;

  beforeEach(() => {
    stateSubject = new BehaviorSubject({
      readings: [],
      status: 'normal',
      lastUpdated: null,
      isLoading: true,
      error: null,
    });

    mockViewModel = {
      state$: stateSubject.asObservable(),
    } as any;

    (EnvironmentalMonitoringViewModel as jest.Mock).mockImplementation(() => mockViewModel);
  });

  it('displays loading state initially', () => {
    const wrapper = mount(EnvironmentalMonitoring, {
      props: { greenhouseId: 'gh-1' },
    });

    expect(wrapper.text()).toContain('Loading sensor data');
  });

  it('displays sensor readings when loaded', async () => {
    const wrapper = mount(EnvironmentalMonitoring, {
      props: { greenhouseId: 'gh-1' },
    });

    // Simulate ViewModel emitting loaded state
    stateSubject.next({
      readings: [
        { sensorId: 's1', type: 'temperature', value: 22.5, unit: '°C' },
        { sensorId: 's2', type: 'humidity', value: 65, unit: '%' },
      ],
      status: 'normal',
      lastUpdated: new Date(),
      isLoading: false,
      error: null,
    });

    await wrapper.vm.$nextTick();

    expect(wrapper.findAll('.sensor-card')).toHaveLength(2);
  });

  it('displays error state when ViewModel errors', async () => {
    const wrapper = mount(EnvironmentalMonitoring, {
      props: { greenhouseId: 'gh-1' },
    });

    stateSubject.next({
      readings: [],
      status: 'normal',
      lastUpdated: null,
      isLoading: false,
      error: 'Failed to load sensor data',
    });

    await wrapper.vm.$nextTick();

    expect(wrapper.find('.error').text()).toContain('Failed to load sensor data');
  });

  it('updates reactively when ViewModel state changes', async () => {
    const wrapper = mount(EnvironmentalMonitoring, {
      props: { greenhouseId: 'gh-1' },
    });

    // Initial state
    stateSubject.next({
      readings: [],
      status: 'normal',
      lastUpdated: null,
      isLoading: false,
      error: null,
    });

    await wrapper.vm.$nextTick();
    expect(wrapper.findAll('.sensor-card')).toHaveLength(0);

    // New reading arrives
    stateSubject.next({
      readings: [{ sensorId: 's1', type: 'temperature', value: 22.5, unit: '°C' }],
      status: 'normal',
      lastUpdated: new Date(),
      isLoading: false,
      error: null,
    });

    await wrapper.vm.$nextTick();
    expect(wrapper.findAll('.sensor-card')).toHaveLength(1);
  });
});
```

Notice what we're testing: **binding correctness**. Does the component display the right content when the ViewModel's state changes? We're not testing business logic—that lives in ViewModels and has its own test suite. We're verifying the component reacts properly to state changes.

## Migration Strategy

If you've built a React application and need to port it to Vue (or vice versa), here's a pragmatic migration approach:

**Phase 1: Extract ViewModels (If Not Already Separated)**

If your business logic is embedded in React components, extract it into framework-agnostic ViewModels first. This is the hardest part, but you'd need to do it for any migration anyway.

**Phase 2: Build the Vue Adapter**

Implement `useViewModel` and `useObservable`. Test these adapters in isolation before porting actual features.

**Phase 3: Port Components Incrementally**

Start with the simplest components—purely presentational ones with minimal state. Build confidence in your adapter layer. Then tackle stateful components, forms, and complex interactions.

**Phase 4: Run Both in Parallel**

For large applications, consider running React and Vue side-by-side during migration. Use microfrontends or iframe boundaries to compose the two frameworks. Gradually migrate features as capacity allows.

**Phase 5: Consolidate**

Once all features are ported and tested, remove the old framework. Your ViewModels, domain services, and business logic remain untouched throughout.

## When Vue's Reactivity Feels Different

Vue developers coming from React sometimes struggle with Vue's implicit reactivity. In React, you explicitly call `setState`. In Vue, you just mutate a ref and the UI updates automatically. This feels magical, but it can also feel unpredictable.

Our architecture sidesteps this entirely. ViewModels publish state through observables. Whether the consuming framework uses explicit state updates or proxy-based reactivity doesn't matter. The ViewModel's contract is simple: "Here's an observable. Subscribe to it. When I emit new state, you'll get it."

This is why our architecture works seamlessly across frameworks. We're not fighting Vue's reactivity model or React's reconciliation. We're providing a stable, predictable interface that both frameworks can consume naturally.

## The Real Cost of Framework Independence

Let's be honest: framework-agnostic architecture isn't free. You're introducing an abstraction layer—ViewModels, RxJS, dependency injection. There's a learning curve. Your team needs to understand observables and reactive programming.

But consider the alternative: tightly coupling business logic to your framework. You're betting your application's longevity on React, Vue, or Angular remaining the best choice for your team indefinitely. That's a risky bet.

Framework independence gives you options. When your team decides React isn't serving them anymore, you're not facing a rewrite. When a new framework gains traction and offers compelling benefits, you can experiment without risking your entire codebase. When you need to support multiple platforms—web, mobile, desktop—you're not duplicating business logic for each.

The cost is upfront: learning MVVM, RxJS, and architectural patterns. The benefit compounds over time: flexibility, testability, and confidence in your architecture's longevity.

## Summary

We've now proven that MVVM delivers on its promise of framework independence. We built real features—environmental monitoring, greenhouse management, alert configuration—in both React and Vue using identical business logic. The only framework-specific code was the adapter layer: roughly 40 lines of glue between RxJS observables and Vue's reactivity.

This is the architectural payoff. When you separate concerns properly—when you keep ViewModels framework-agnostic and domain logic pure—you earn the ability to port your application to any view layer with minimal friction. You're not locked into React, Vue, or Angular. You're building for the long term.

In the next chapter, we'll tackle the comprehensive GreenWatch case study, demonstrating how all these patterns—MVVM, DDD, reactive state management, framework independence—compose into a complete, production-ready application. We'll address cross-cutting concerns like authentication, error handling, and real-time synchronization. We'll show how the architecture scales beyond single features to full applications.
