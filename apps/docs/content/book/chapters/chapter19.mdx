---
id: 'the-scalable-monolith-modular-architecture-patterns'
title: The Scalable Monolith - Modular Architecture Patterns
section: Enterprise Scale
---

# The Scalable Monolith: Modular Architecture Patterns

# Chapter 19: The Scalable Monolith

_"Microservices without the microproblems."_

We've spent eighteen chapters building framework-agnostic ViewModels, implementing domain-driven design, and establishing clean boundaries between our application layers. Now we need to talk about how to scale this architecture—not just in terms of performance, but in terms of **team size, feature velocity, and cognitive load**.

The frontend community has an odd relationship with monoliths. We've watched backend teams fragment perfectly functional systems into dozens of microservices, struggle with distributed transactions and network latency, then quietly consolidate back into what they now call "modular monoliths." Meanwhile, we've been busy making the same mistakes with microfrontends.

Here's what we've learned: **the problem was never the monolith**. The problem was poorly structured monoliths that let developers ignore boundaries, skip abstractions, and tangle everything together. When you enforce proper boundaries, a monolith becomes your most powerful architecture.

This chapter shows you how to build a **scalable monolith** using modern tooling—monorepos that enforce boundaries, linters that prevent violations, and build systems that make the whole thing fast. We'll explore patterns that let your team grow from three to thirty developers without fragmenting your codebase into unmaintainable pieces.

## 19.1 Why Monoliths Scale (And Microfrontends Often Don't)

Before we dive into tooling, let's establish why you should default to a monolith for most frontend applications.

### The Microfrontend Promise vs. Reality

The microfrontend pitch sounds compelling: "Split your frontend into independently deployable pieces, just like microservices! Different teams can own different parts, use different frameworks, deploy independently!"

In practice, here's what happens:

```typescript
// ❌ The microfrontend nightmare
// Team A's code (React 17, deployed Tuesday)
window.__SHARED_STATE__ = {
  user: currentUser,
  theme: 'dark',
};

// Team B's code (Vue 3, deployed Thursday)
const user = window.__SHARED_STATE__?.user;
// Breaks on Thursday because Team A renamed 'user' to 'currentUser'

// Team C's code (Angular 14, deployed Friday)
// Loads a completely different version of RxJS
// Now you have 847KB of duplicate dependencies
```

**What went wrong?**

1. **You can't share types** across runtime boundaries. TypeScript compilation happens per-fragment.
2. **You can't enforce contracts** at compile time. Breaking changes become runtime errors.
3. **You duplicate dependencies** massively. Each fragment bundles its own React/Vue/RxJS.
4. **Testing integration** becomes a deployment problem, not a test suite problem.
5. **Debugging** requires correlating logs across multiple deployments and network boundaries.

These aren't edge cases—they're fundamental issues with distributed frontends. You've taken all the problems of distributed systems (network failures, eventual consistency, version skew) and brought them into the browser.

### What Makes a Monolith Scalable?

A scalable monolith has one key property: **enforced boundaries without distribution**.

```typescript
// ✅ Scalable monolith approach
// Everything compiles together, shares types, but respects boundaries

// packages/device-management/src/domain/Device.ts
export class Device {
  constructor(
    public readonly id: DeviceId,
    public readonly greenhouseId: GreenhouseId,
    private status: DeviceStatus,
  ) {}
}

// packages/environmental-monitoring/src/application/MonitoringService.ts
// This CAN import Device because we've explicitly allowed it
import { Device } from '@greenwatch/device-management';

// packages/environmental-monitoring/src/infrastructure/DeviceRepository.ts
// This CANNOT import from device-management internals
// ESLint + Sheriff will fail the build if you try
import { DeviceRepository } from '@greenwatch/device-management/internals'; // ❌ Build fails
```

**This gives you:**

1. **Compile-time safety**: TypeScript catches breaking changes before deployment
2. **Single deployment**: One build, one artifact, no network boundaries to debug
3. **Shared code**: No dependency duplication. One version of React, one RxJS
4. **Gradual extraction**: If you _really_ need to extract a service later, you already have clear boundaries
5. **Fast feedback**: Run the entire test suite in seconds, not after deployment

The scalable monolith isn't about avoiding boundaries—it's about **enforcing boundaries without the operational complexity of distribution**.

## 19.2 Monorepo Fundamentals

A monorepo isn't just "multiple packages in one repo." It's a structured way to manage dependencies, enforce boundaries, and share tooling across your entire application.

### Structure: Packages vs. Apps

Your monorepo should distinguish between **packages** (shared libraries) and **apps** (deployable artifacts):

```
greenwatch/
├── apps/
│   ├── web/                    # Main React/Vue web app
│   ├── mobile/                 # React Native mobile app
│   ├── admin-portal/           # Separate admin interface
│   └── monitoring-dashboard/   # Real-time monitoring view
│
├── packages/
│   ├── domain/
│   │   ├── device-management/
│   │   ├── environmental-monitoring/
│   │   ├── alerts/
│   │   └── analytics/
│   │
│   ├── application/
│   │   ├── device-viewmodels/
│   │   ├── monitoring-viewmodels/
│   │   └── alert-viewmodels/
│   │
│   ├── infrastructure/
│   │   ├── http-client/
│   │   ├── websocket-client/
│   │   └── local-storage/
│   │
│   └── shared/
│       ├── types/              # Shared TypeScript types
│       ├── testing/            # Test utilities
│       └── ui-primitives/      # Framework-agnostic UI utilities
│
├── tools/
│   ├── eslint-config/
│   ├── typescript-config/
│   └── sheriff-config/
│
└── package.json
```

**Key principles:**

1. **Apps consume, packages provide**: Apps never export anything. Packages never render UI (except ui-primitives).
2. **Domain packages are bounded contexts**: Each package under `domain/` represents a bounded context from our DDD model.
3. **Application packages are ViewModels**: These expose framework-agnostic ViewModels that apps bind to.
4. **Infrastructure is adapter-based**: These implement interfaces defined by domain/application packages.

### Dependency Graph Rules

Not all dependencies are equal. Your monorepo structure should encode **architectural layers**:

```typescript
// ✅ Allowed dependencies (acyclic, downward flow)
apps/web
  → packages/application/device-viewmodels
    → packages/domain/device-management
      → packages/shared/types

// ❌ Forbidden dependencies (would create cycles or violate layers)
packages/domain/device-management
  → packages/application/device-viewmodels  // Domain can't depend on application

packages/application/device-viewmodels
  → apps/web  // Application can't depend on specific apps

packages/domain/environmental-monitoring
  → packages/infrastructure/http-client  // Domain can't depend on infrastructure details
```

We'll enforce these rules with tooling in section 19.3.

### Workspace Configuration

Modern package managers (npm, yarn, pnpm) support workspaces natively. Here's a `package.json` configuration:

```json
{
  "name": "greenwatch",
  "private": true,
  "workspaces": ["apps/*", "packages/*/*", "packages/shared/*", "tools/*"],
  "scripts": {
    "build": "turbo run build",
    "test": "turbo run test",
    "lint": "turbo run lint",
    "type-check": "turbo run type-check"
  },
  "devDependencies": {
    "turbo": "^2.0.0",
    "@sheriff/cli": "^0.10.0",
    "typescript": "^5.3.0"
  }
}
```

**Each package** has its own `package.json`:

```json
// packages/domain/device-management/package.json
{
  "name": "@greenwatch/device-management",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "jest",
    "lint": "eslint src/"
  },
  "dependencies": {
    "@greenwatch/types": "workspace:*",
    "rxjs": "^7.8.0"
  },
  "devDependencies": {
    "typescript": "^5.3.0",
    "jest": "^29.0.0"
  }
}
```

**Notice `workspace:*`**: This tells the package manager "use the local workspace version, not npm registry." When you publish (if you ever do), it'll resolve to actual version numbers.

## 19.3 Enforcing Boundaries with Sheriff and ESLint

Structure alone doesn't prevent violations. You need automated enforcement. That's where **Sheriff** comes in.

### What Sheriff Does

[Sheriff](https://github.com/softarc-consulting/sheriff) is a tool that enforces dependency rules in TypeScript monorepos. Think of it as ESLint for architecture.

You define rules like "domain packages can't import from infrastructure packages," and Sheriff fails your build if someone violates them. Unlike runtime checks, this happens at **compile time**.

### Configuration

Create a `sheriff.config.ts` at the repo root:

```typescript
// sheriff.config.ts
import { SheriffConfig } from '@sheriff/types';

export const config: SheriffConfig = {
  version: 1,

  // Define tags for each layer
  tagging: {
    'packages/domain/<pkg>': ['domain', 'domain:<pkg>'],
    'packages/application/<pkg>': ['application', 'application:<pkg>'],
    'packages/infrastructure/<pkg>': ['infrastructure', 'infrastructure:<pkg>'],
    'packages/shared/<pkg>': ['shared', 'shared:<pkg>'],
    'apps/<app>': ['app', 'app:<app>'],
  },

  // Define dependency rules
  depRules: {
    // Root rule: Define layered architecture
    root: [
      // Apps can depend on anything (they're the top layer)
      'app -> *',

      // Application layer can depend on domain and shared
      'application -> domain',
      'application -> shared',

      // Domain can only depend on shared (no application, no infrastructure)
      'domain -> shared',
      'domain -> domain', // Domain packages can depend on other domains

      // Infrastructure can depend on domain and shared
      'infrastructure -> domain',
      'infrastructure -> shared',

      // Shared can only depend on other shared packages
      'shared -> shared',
    ],

    // Specific bounded context rules
    'domain:environmental-monitoring': [
      // Environmental monitoring can depend on device management
      'same -> domain:device-management',

      // But NOT on alerts (different bounded context)
      'same -x domain:alerts',
    ],

    // Prevent apps from depending on each other
    'app:web': ['same -x app:*'],
    'app:mobile': ['same -x app:*'],
  },
};
```

**Breaking this down:**

1. **Tagging**: Each directory gets tags (`domain`, `application:<pkg>`, etc.)
2. **Root rules**: Define general layer constraints (domain → shared, but not domain → infrastructure)
3. **Specific rules**: Add context-specific constraints (environmental-monitoring → device-management is allowed)
4. **Negation**: `same -x domain:alerts` means "this package CANNOT depend on the alerts domain"

### Integration with Build

Add Sheriff to your CI pipeline:

```json
// package.json
{
  "scripts": {
    "sheriff": "sheriff verify",
    "build": "npm run sheriff && turbo run build"
  }
}
```

Now **every build** verifies your architecture. If a developer tries this:

```typescript
// packages/domain/device-management/src/Device.ts
import { HttpClient } from '@greenwatch/infrastructure/http-client'; // ❌
```

The build **fails immediately** with:

```
Error: Dependency rule violation
  packages/domain/device-management cannot depend on packages/infrastructure/http-client

  Rule: domain -> shared, domain
  Violated by: domain:device-management -> infrastructure:http-client

  Domain layer must not depend on infrastructure.
  Use dependency injection to inject infrastructure at runtime.
```

**This is architectural enforcement at compile time.** No code review required—the machine catches it.

### Complementing with ESLint

Sheriff handles package-level rules. ESLint handles module-level rules within packages:

```javascript
// .eslintrc.js
module.exports = {
  root: true,

  overrides: [
    {
      // Rules for domain packages
      files: ['packages/domain/*/src/**/*.ts'],
      rules: {
        // No direct imports from infrastructure
        'no-restricted-imports': [
          'error',
          {
            patterns: ['**/infrastructure/**'],
            message: 'Domain layer cannot import infrastructure. Use dependency injection.',
          },
        ],

        // No framework imports in domain
        'no-restricted-imports': [
          'error',
          {
            patterns: ['react', 'vue', '@angular/**'],
            message: 'Domain must be framework-agnostic.',
          },
        ],
      },
    },

    {
      // Rules for ViewModels
      files: ['packages/application/*/src/**/*ViewModel.ts'],
      rules: {
        // ViewModels must not import UI frameworks
        'no-restricted-imports': [
          'error',
          {
            patterns: ['react', 'vue', '@angular/**'],
            message: 'ViewModels must be framework-agnostic. Return observables.',
          },
        ],
      },
    },
  ],
};
```

**Sheriff + ESLint** gives you defense-in-depth: package-level boundaries enforced by Sheriff, module-level boundaries enforced by ESLint.

## 19.4 Build Performance with Turborepo and Nx

Monorepos get slow as they grow. If every change requires rebuilding 50 packages, your feedback loop dies. Build tools like **Turborepo** and **Nx** solve this with **caching** and **task orchestration**.

### Turborepo: Simple and Fast

Turborepo focuses on one thing: **never build the same thing twice**.

```json
// turbo.json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      // Build depends on dependencies being built first
      "dependsOn": ["^build"],

      // Cache based on source files and dependencies
      "inputs": ["src/**", "package.json", "tsconfig.json"],

      // Save build outputs to cache
      "outputs": ["dist/**", ".next/**"]
    },

    "test": {
      // Tests depend on the package being built
      "dependsOn": ["build"],

      // Cache based on source and test files
      "inputs": ["src/**", "tests/**", "package.json"],

      // No outputs (tests don't produce artifacts)
      "outputs": []
    },

    "lint": {
      // Linting can run independently
      "inputs": ["src/**", ".eslintrc.js"],
      "outputs": []
    },

    "type-check": {
      "dependsOn": ["^build"], // Needs dependencies' types
      "inputs": ["src/**", "tsconfig.json"],
      "outputs": []
    }
  }
}
```

**How it works:**

1. You change `packages/domain/device-management/src/Device.ts`
2. Turbo detects the change via file hashing
3. It rebuilds `device-management` (cache miss)
4. It rebuilds `application/device-viewmodels` (depends on device-management)
5. It **skips** rebuilding `domain/alerts` (no changes, cache hit)
6. It rebuilds `apps/web` (depends on device-viewmodels)

**On CI**, Turborepo can use **remote caching**:

```json
// turbo.json
{
  "remoteCache": {
    "enabled": true,
    "signature": true // Verify cache integrity
  }
}
```

Now when CI runs, it checks a remote cache (Vercel, AWS S3, custom) for previous build artifacts. If commit `abc123` was already built on another developer's machine, CI just downloads the cached outputs. **Builds that took 10 minutes now take 30 seconds.**

### Nx: More Features, More Configuration

Nx offers similar caching plus **code generation**, **dependency graph visualization**, and **affected testing**.

```json
// nx.json
{
  "tasksRunnerOptions": {
    "default": {
      "runner": "nx/tasks-runners/default",
      "options": {
        "cacheableOperations": ["build", "test", "lint"],
        "parallel": 3 // Run 3 tasks in parallel
      }
    }
  },

  "targetDefaults": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["production", "^production"],
      "outputs": ["{projectRoot}/dist"]
    }
  }
}
```

**Key Nx features:**

1. **Affected commands**: `nx affected:test` only runs tests for projects impacted by your changes
2. **Dependency graph**: `nx graph` visualizes your package dependencies
3. **Generators**: `nx generate @nx/react:library` scaffolds new packages with templates
4. **Module boundary rules**: Built-in enforcement (alternative to Sheriff)

### Which Should You Use?

**Use Turborepo if:**

- You want simplicity and speed out of the box
- You're comfortable with existing tooling (just need caching)
- Your monorepo structure is stable

**Use Nx if:**

- You need code generation and scaffolding
- You want built-in enforcement of module boundaries
- You want detailed dependency analysis and visualization
- You're building a large enterprise monorepo (100+ packages)

For most projects, **start with Turborepo**. Its minimal configuration and excellent caching are enough. Add Nx later if you need its advanced features.

## 19.5 Domain-Driven Design in the Monorepo

We've discussed DDD extensively in earlier chapters. Here's how it maps to monorepo structure.

### Bounded Contexts as Packages

Each bounded context becomes a **domain package**:

```
packages/domain/
├── device-management/
│   ├── src/
│   │   ├── entities/
│   │   │   ├── Device.ts
│   │   │   ├── Sensor.ts
│   │   │   └── DeviceStatus.ts
│   │   ├── value-objects/
│   │   │   ├── DeviceId.ts
│   │   │   └── SensorReading.ts
│   │   ├── aggregates/
│   │   │   └── DeviceAggregate.ts
│   │   ├── repositories/
│   │   │   └── IDeviceRepository.ts  (interface only)
│   │   ├── services/
│   │   │   └── DeviceCalibrationService.ts
│   │   └── events/
│   │       ├── DeviceRegistered.ts
│   │       └── DeviceStatusChanged.ts
│   ├── tests/
│   └── package.json
│
└── environmental-monitoring/
    ├── src/
    │   ├── entities/
    │   │   ├── Greenhouse.ts
    │   │   └── EnvironmentalReading.ts
    │   ├── value-objects/
    │   │   ├── Temperature.ts
    │   │   └── Humidity.ts
    │   ├── services/
    │   │   └── OptimalRangeService.ts
    │   └── events/
    │       └── ThresholdExceeded.ts
    └── package.json
```

**Each package has:**

1. **Clear boundaries**: Can only depend on other domain packages explicitly allowed by Sheriff
2. **Published interface**: Exports entities, value objects, events, and repository interfaces
3. **Hidden internals**: Implementation details stay internal (not exported)

### Anti-Corruption Layer Pattern

When one bounded context needs data from another, use an **Anti-Corruption Layer** (ACL):

```typescript
// packages/domain/environmental-monitoring/src/acl/DeviceACL.ts
import { Device, DeviceId } from '@greenwatch/device-management';
import { MonitoringDevice } from '../entities/MonitoringDevice';

/**
 * Anti-Corruption Layer: Translates Device (from device-management context)
 * into MonitoringDevice (environmental-monitoring's internal model).
 *
 * Why? Environmental monitoring doesn't care about calibration history,
 * firmware versions, or installation dates. It only needs sensor capabilities
 * and current operational status.
 */
export class DeviceACL {
  static toMonitoringDevice(device: Device): MonitoringDevice {
    return new MonitoringDevice(
      device.id,
      device.sensorTypes, // Only extract what we need
      device.isOperational(), // Hide device-management's complex status model
    );
  }

  static toDeviceId(monitoringDeviceId: string): DeviceId {
    return DeviceId.fromString(monitoringDeviceId);
  }
}

// Usage in environmental-monitoring
export class EnvironmentalMonitoringService {
  constructor(
    private deviceRepo: IDeviceRepository, // From device-management
    private readingRepo: IReadingRepository,
  ) {}

  async recordReading(deviceId: string, reading: SensorReading): Promise<void> {
    // Translate to device-management's ID format
    const device = await this.deviceRepo.findById(DeviceACL.toDeviceId(deviceId));

    if (!device) throw new Error('Device not found');

    // Translate to our internal model
    const monitoringDevice = DeviceACL.toMonitoringDevice(device);

    // Now work with our own entities
    if (!monitoringDevice.canRecord(reading.type)) {
      throw new Error('Device cannot record this sensor type');
    }

    await this.readingRepo.save(reading);
  }
}
```

**The ACL prevents:**

1. **Tight coupling**: Environmental monitoring doesn't depend on device-management's internal structure
2. **Breaking changes**: Device-management can refactor its `Device` entity without breaking environmental-monitoring
3. **Context leakage**: Concepts like "firmware version" don't leak into environmental monitoring

### Shared Kernel

Some concepts genuinely belong to **multiple contexts**. Put these in a **shared kernel**:

```typescript
// packages/shared/types/src/core/EntityId.ts
export abstract class EntityId {
  protected constructor(public readonly value: string) {
    if (!value || value.trim() === '') {
      throw new Error('Entity ID cannot be empty');
    }
  }

  equals(other: EntityId): boolean {
    return this.value === other.value;
  }

  toString(): string {
    return this.value;
  }
}

// packages/domain/device-management/src/value-objects/DeviceId.ts
import { EntityId } from '@greenwatch/types/core';

export class DeviceId extends EntityId {
  private constructor(value: string) {
    super(value);
  }

  static create(): DeviceId {
    return new DeviceId(crypto.randomUUID());
  }

  static fromString(value: string): DeviceId {
    return new DeviceId(value);
  }
}
```

**Shared kernel should contain:**

- **Value object base classes** (like `EntityId`)
- **Common types** (like `Result<T, E>` for error handling)
- **Framework-agnostic utilities** (date formatting, validation helpers)
- **Domain events infrastructure** (event bus interfaces)

**Shared kernel should NOT contain:**

- Business logic (that belongs in domain packages)
- Infrastructure concerns (HTTP clients, database adapters)
- Anything framework-specific (React hooks, Vue composables)

## 19.6 Testing Strategy for Monorepos

Testing a monolith is simpler than testing distributed systems, but you still need a strategy for **speed** and **isolation**.

### The Testing Pyramid in Monorepos

```
              /\
             /  \
            / E2E \          ← Few, expensive, slow
           /--------\
          /          \
         / Integration \     ← Some, moderate cost
        /--------------\
       /                \
      /   Unit Tests     \   ← Many, cheap, fast
     /--------------------\
```

**In a monorepo:**

1. **Unit tests** run per-package (fast, cached by Turbo)
2. **Integration tests** run across packages (moderate speed)
3. **E2E tests** run against the full app (slow, CI-only)

### Unit Testing: Per-Package Isolation

Each package has its own test suite:

```typescript
// packages/domain/device-management/tests/Device.test.ts
import { Device, DeviceId, DeviceStatus } from '../src';

describe('Device', () => {
  it('should transition from offline to online', () => {
    const device = Device.create(DeviceId.create(), 'Sensor-001', DeviceStatus.Offline);

    device.markOnline();

    expect(device.status).toBe(DeviceStatus.Online);
  });

  it('should emit DeviceStatusChanged event on transition', () => {
    const device = Device.create(DeviceId.create(), 'Sensor-001', DeviceStatus.Offline);

    device.markOnline();

    const events = device.pullDomainEvents();
    expect(events).toHaveLength(1);
    expect(events[0]).toBeInstanceOf(DeviceStatusChanged);
  });
});
```

**Run with Turbo:**

```bash
turbo run test --filter=@greenwatch/device-management
```

Turbo caches the result. If you haven't changed `device-management` or its dependencies, the test result is pulled from cache (takes ~50ms instead of ~2s).

### Integration Testing: Cross-Package Scenarios

Integration tests verify that packages work together:

```typescript
// packages/application/monitoring-viewmodels/tests/integration/GreenviewViewModel.integration.test.ts
import { GreenviewViewModel } from '../../src/GreenviewViewModel';
import { InMemoryDeviceRepository } from '@greenwatch/device-management/testing';
import { InMemoryReadingRepository } from '@greenwatch/environmental-monitoring/testing';
import { Device, DeviceId, DeviceStatus } from '@greenwatch/device-management';

describe('GreenviewViewModel Integration', () => {
  it('should display readings from active devices', async () => {
    // Arrange: Set up repositories with test data
    const deviceRepo = new InMemoryDeviceRepository();
    const readingRepo = new InMemoryReadingRepository();

    const deviceId = DeviceId.create();
    const device = Device.create(deviceId, 'Test-Sensor', DeviceStatus.Online);
    await deviceRepo.save(device);

    const reading = SensorReading.create(deviceId, Temperature.celsius(23.5));
    await readingRepo.save(reading);

    // Act: Create ViewModel and load data
    const viewModel = new GreenviewViewModel(deviceRepo, readingRepo);
    await viewModel.loadGreenhouse('greenhouse-1');

    // Assert: ViewModel exposes correct state
    const state = await firstValueFrom(viewModel.state$);
    expect(state.devices).toHaveLength(1);
    expect(state.devices[0].latestReading.temperature).toBe(23.5);
  });
});
```

**Key points:**

1. Uses **test doubles from each package** (`InMemoryDeviceRepository`)
2. Tests **cross-package contracts** (ViewModel + Domain + Repositories)
3. Still **fast** (no network, no database, no UI rendering)

### E2E Testing: Full Application Flow

E2E tests run against the deployed app (or local dev server):

```typescript
// apps/web/e2e/monitoring.spec.ts
import { test, expect } from '@playwright/test';

test('displays real-time sensor readings', async ({ page }) => {
  await page.goto('/greenhouses/test-greenhouse-1');

  // Wait for WebSocket connection and initial data load
  await expect(page.locator('[data-testid="sensor-grid"]')).toBeVisible();

  // Verify initial reading
  const tempReading = page.locator('[data-testid="temperature-display"]');
  await expect(tempReading).toContainText('23.5°C');

  // Simulate new reading via WebSocket (test harness injects this)
  await page.evaluate(() => {
    window.__TEST_WS__.send({
      type: 'READING_UPDATE',
      deviceId: 'device-1',
      temperature: 24.2,
    });
  });

  // Verify UI updates reactively
  await expect(tempReading).toContainText('24.2°C', { timeout: 2000 });
});
```

**Run E2E sparingly:**

```json
// package.json
{
  "scripts": {
    "test:e2e": "playwright test",
    "test:e2e:ci": "playwright test --workers=3"
  }
}
```

E2E tests run **only in CI** or before releases. They're too slow for local development.

### Test Organization Best Practices

1. **Colocate tests with source**: Each package has a `tests/` directory
2. **Export test utilities**: Packages export test doubles under a `/testing` export path
3. **Run tests in parallel**: Use Turbo's `--concurrency` flag
4. **Cache aggressively**: Configure Turbo to cache test results
5. **Split test types**: Run unit tests on every commit, integration tests on PR, E2E on merge

```json
// turbo.json
{
  "pipeline": {
    "test:unit": {
      "inputs": ["src/**", "tests/**"],
      "outputs": ["coverage/**"]
    },
    "test:integration": {
      "dependsOn": ["^build"],
      "inputs": ["src/**", "tests/**"]
    },
    "test:e2e": {
      "dependsOn": ["build"],
      "cache": false // E2E shouldn't be cached (external dependencies)
    }
  }
}
```

## 19.7 Deployment Strategies

A monorepo monolith deploys as **one artifact**, but that doesn't mean you can't optimize the deployment.

### Single Build, Multiple Deployment Targets

You might deploy different **apps** from the same monorepo to different environments:

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install dependencies
        run: npm ci

      - name: Build all packages
        run: npx turbo run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts
          path: |
            apps/*/dist
            apps/*/.next

  deploy-web:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v3

      - name: Deploy to Vercel
        run: vercel deploy --prod --cwd apps/web

  deploy-admin:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v3

      - name: Deploy to internal server
        run: rsync -avz apps/admin-portal/dist/ admin-server:/var/www/
```

**Key benefits:**

1. **One build** ensures all apps use the same package versions
2. **Parallel deploys** speed up the process
3. **Shared cache** means unchanged apps skip rebuilding

### Incremental Deployment with Feature Flags

You don't need microfrontends to deploy features incrementally. Use **feature flags**:

```typescript
// packages/shared/feature-flags/src/FeatureFlagService.ts
export class FeatureFlagService {
  constructor(private flags: Map<string, boolean>) {}

  isEnabled(flag: string): boolean {
    return this.flags.get(flag) ?? false;
  }
}

// apps/web/src/main.tsx
const featureFlags = new FeatureFlagService(
  new Map([
    ['new-analytics-dashboard', import.meta.env.VITE_FF_NEW_ANALYTICS === 'true'],
    ['real-time-alerts', import.meta.env.VITE_FF_REALTIME_ALERTS === 'true'],
  ]),
);

// Usage in ViewModels
export class DashboardViewModel {
  constructor(
    private featureFlags: FeatureFlagService,
    private analyticsService: AnalyticsService,
  ) {}

  get shouldShowNewDashboard$(): Observable<boolean> {
    return of(this.featureFlags.isEnabled('new-analytics-dashboard'));
  }
}
```

**Deploy to production with flags off**, then **enable incrementally**:

```bash
# Deploy with new code, flag disabled
VITE_FF_NEW_ANALYTICS=false npm run build && npm run deploy

# Enable for 10% of users via CDN config
curl -X POST https://cdn.example.com/config \
  -d '{"feature": "new-analytics-dashboard", "rollout": 0.1}'

# Monitor metrics, then increase rollout
curl -X POST https://cdn.example.com/config \
  -d '{"feature": "new-analytics-dashboard", "rollout": 1.0}'
```

This gives you **controlled rollout** without fragmenting your codebase.

### Build Optimization: Code Splitting

Modern bundlers (Vite, Webpack) support **automatic code splitting**:

```typescript
// apps/web/src/routes.tsx
import { lazy } from 'react';

const DashboardPage = lazy(() => import('./pages/DashboardPage'));
const AnalyticsPage = lazy(() => import('./pages/AnalyticsPage'));
const SettingsPage = lazy(() => import('./pages/SettingsPage'));

export const routes = [
  { path: '/', component: DashboardPage },
  { path: '/analytics', component: AnalyticsPage },
  { path: '/settings', component: SettingsPage },
];
```

Vite automatically splits each page into a separate chunk. User visiting `/` doesn't download `/analytics` code.

**For shared packages**, use **barrel exports** carefully:

```typescript
// ❌ Bad: Importing from barrel pulls in everything
import { DeviceViewModel } from '@greenwatch/device-viewmodels';
// This imports ALL ViewModels, not just DeviceViewModel

// ✅ Good: Import from specific files
import { DeviceViewModel } from '@greenwatch/device-viewmodels/DeviceViewModel';
// Bundler can tree-shake unused code
```

Configure your package exports:

```json
// packages/application/device-viewmodels/package.json
{
  "name": "@greenwatch/device-viewmodels",
  "exports": {
    ".": "./dist/index.js",
    "./DeviceViewModel": "./dist/DeviceViewModel.js",
    "./DeviceListViewModel": "./dist/DeviceListViewModel.js"
  }
}
```

Now imports are explicit, and bundlers can optimize better.

## 19.8 Bulletproof Patterns for All Frameworks

The patterns in [Bulletproof React](https://github.com/alan2207/bulletproof-react) aren't React-specific—they're good frontend architecture that translates to Vue, Angular, and Svelte. Let's extract the framework-agnostic principles.

### Feature-Sliced Architecture

Bulletproof React organizes code by **feature**, not by technical type:

```
apps/web/src/
├── features/
│   ├── device-management/
│   │   ├── components/
│   │   │   ├── DeviceList.tsx
│   │   │   └── DeviceCard.tsx
│   │   ├── hooks/
│   │   │   └── useDeviceViewModel.ts  (React adapter)
│   │   └── index.ts
│   │
│   ├── environmental-monitoring/
│   │   ├── components/
│   │   │   ├── SensorReadingChart.tsx
│   │   │   └── ThresholdAlert.tsx
│   │   ├── hooks/
│   │   │   └── useMonitoringViewModel.ts
│   │   └── index.ts
│   │
│   └── analytics/
│       ├── components/
│       ├── hooks/
│       └── index.ts
│
├── components/  (Shared UI components)
│   ├── Button/
│   ├── Card/
│   └── DataTable/
│
└── lib/  (Framework-specific utilities)
    ├── useObservable.ts
    └── providers.tsx
```

**Why this works:**

1. **Features are self-contained**: Everything related to device management is in one place
2. **Clear boundaries**: Features don't import from each other (use shared ViewModels instead)
3. **Easy navigation**: Developers don't hunt through `components/`, `containers/`, `actions/`, etc.

This pattern works **identically in Vue**:

```
apps/web/src/
├── features/
│   ├── device-management/
│   │   ├── components/
│   │   │   ├── DeviceList.vue
│   │   │   └── DeviceCard.vue
│   │   ├── composables/
│   │   │   └── useDeviceViewModel.ts  (Vue adapter)
│   │   └── index.ts
```

Or **Svelte**:

```
apps/web/src/
├── features/
│   ├── device-management/
│   │   ├── components/
│   │   │   ├── DeviceList.svelte
│   │   │   └── DeviceCard.svelte
│   │   ├── stores/
│   │   │   └── deviceViewModel.ts  (Svelte adapter)
│   │   └── index.ts
```

The **structure is the same**. Only the framework adapters (`hooks/`, `composables/`, `stores/`) change.

### API Layer Separation

Bulletproof React separates API concerns from component concerns:

```typescript
// apps/web/src/lib/api-client.ts
export class ApiClient {
  constructor(private baseUrl: string) {}

  async get<T>(path: string): Promise<T> {
    const response = await fetch(`${this.baseUrl}${path}`);
    if (!response.ok) throw new Error('Network error');
    return response.json();
  }

  async post<T>(path: string, data: unknown): Promise<T> {
    const response = await fetch(`${this.baseUrl}${path}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (!response.ok) throw new Error('Network error');
    return response.json();
  }
}

// features/device-management/api/deviceApi.ts
import { ApiClient } from '@/lib/api-client';
import { Device } from '@greenwatch/device-management';

export class DeviceApi {
  constructor(private client: ApiClient) {}

  async getDevices(greenhouseId: string): Promise<Device[]> {
    const response = await this.client.get<DeviceDTO[]>(`/greenhouses/${greenhouseId}/devices`);
    return response.map((dto) => Device.fromDTO(dto));
  }

  async updateDevice(device: Device): Promise<void> {
    await this.client.post(`/devices/${device.id}`, device.toDTO());
  }
}
```

**This lets you:**

1. **Mock the API layer** in tests without mocking `fetch`
2. **Swap implementations** (REST → GraphQL) without touching ViewModels
3. **Add retry logic** or caching in one place

The pattern is **identical in Vue, Angular, or Svelte**—just swap out the DI mechanism.

### Error Boundaries and Fallbacks

Bulletproof React wraps features in error boundaries:

```typescript
// React version
import { ErrorBoundary } from 'react-error-boundary';

function App() {
  return (
    <ErrorBoundary fallback={<ErrorFallback />}>
      <DeviceManagementFeature />
    </ErrorBoundary>
  );
}

// Vue version (using vue-error-boundary or custom)
<template>
  <ErrorBoundary>
    <DeviceManagementFeature />
    <template #fallback>
      <ErrorFallback />
    </template>
  </ErrorBoundary>
</template>
```

**The principle**: Features fail independently. An error in analytics doesn't crash device management.

This pairs beautifully with **ViewModels that expose error state**:

```typescript
export class DeviceListViewModel {
  readonly state$ = this.stateSubject.asObservable();

  private stateSubject = new BehaviorSubject<DeviceListState>({
    devices: [],
    loading: false,
    error: null,  // ViewModel exposes errors
  });

  async loadDevices(): Promise<void> {
    this.stateSubject.next({ ...this.stateSubject.value, loading: true });

    try {
      const devices = await this.deviceRepo.getAll();
      this.stateSubject.next({ devices, loading: false, error: null });
    } catch (error) {
      this.stateSubject.next({
        ...this.stateSubject.value,
        loading: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  }
}

// React component
function DeviceList() {
  const { devices, loading, error } = useDeviceViewModel();

  if (error) return <ErrorDisplay message={error} />;
  if (loading) return <Spinner />;

  return <div>{devices.map(d => <DeviceCard key={d.id} device={d} />)}</div>;
}
```

**Framework-agnostic error handling** in the ViewModel, **framework-specific rendering** in the component.

### Configuration and Environment Variables

Bulletproof React centralizes configuration:

```typescript
// apps/web/src/config.ts
export const config = {
  apiUrl: import.meta.env.VITE_API_URL || 'http://localhost:3000',
  wsUrl: import.meta.env.VITE_WS_URL || 'ws://localhost:3000',
  enableAnalytics: import.meta.env.VITE_ENABLE_ANALYTICS === 'true',
  environment: import.meta.env.MODE,
} as const;

// Type-safe access
const apiUrl: string = config.apiUrl;
```

**Inject config into ViewModels via DI:**

```typescript
export class DashboardViewModel {
  constructor(
    private analyticsService: AnalyticsService,
    private config: AppConfig, // Injected, not imported
  ) {}

  trackEvent(event: string): void {
    if (this.config.enableAnalytics) {
      this.analyticsService.track(event);
    }
  }
}
```

Now you can **test with different configs** without changing environment variables.

## 19.9 Real-World Examples: Open Source Monorepos

Let's look at how successful projects structure their monorepos.

### Cal.com (Scheduling Platform)

[Cal.com](https://github.com/calcom/cal.com) is an open-source Calendly alternative built as a monorepo.

**Structure:**

```
cal.com/
├── apps/
│   ├── web/            # Next.js app
│   ├── api/            # tRPC API
│   └── swagger/        # API docs
│
├── packages/
│   ├── prisma/         # Database schema
│   ├── trpc/           # tRPC routers
│   ├── ui/             # Shared UI components
│   ├── lib/            # Shared utilities
│   ├── emails/         # Email templates
│   └── features/       # Feature packages (bookings, teams, etc.)
│
└── turbo.json
```

**Key insights:**

1. **Features as packages**: `packages/features/bookings` contains ALL booking logic (API routes, UI, types)
2. **Shared primitives**: `packages/ui` has framework-agnostic components
3. **Turbo caching**: Build times stay under 2 minutes despite 20+ packages

### Vercel's Turborepo Example

[Turborepo examples](https://github.com/vercel/turbo/tree/main/examples) show best practices:

```
examples/kitchen-sink/
├── apps/
│   ├── docs/           # Documentation site
│   ├── web/            # Main app
│   └── admin/          # Admin dashboard
│
├── packages/
│   ├── ui/             # React component library
│   ├── config/         # ESLint + TypeScript configs
│   ├── logger/         # Shared logging
│   └── database/       # Prisma client
│
└── turbo.json
```

**Pattern**: Apps are **thin wrappers** around packages. Most logic lives in packages.

### Nx's E-commerce Demo

[Nx's demo app](https://github.com/nrwl/nx-examples) shows DDD in a monorepo:

```
nx-shop/
├── apps/
│   └── shop/
│
├── libs/
│   ├── products/
│   │   ├── domain/         # Product entities and logic
│   │   ├── data-access/    # Repository implementations
│   │   └── feature-list/   # Product list feature
│   │
│   ├── cart/
│   │   ├── domain/
│   │   ├── data-access/
│   │   └── feature-cart/
│   │
│   └── shared/
│       ├── ui/
│       └── utils/
```

**Notice the layers**: `domain/` (entities), `data-access/` (repositories), `feature-*/` (UI).

This maps directly to our GreenWatch structure.

## 19.10 Migration Path: From Monolith to Modular Monolith

If you're stuck with a legacy codebase, here's how to migrate incrementally.

### Step 1: Introduce Boundaries Without Moving Files

Before splitting into packages, **enforce boundaries in place**:

```javascript
// .eslintrc.js
module.exports = {
  rules: {
    'no-restricted-imports': [
      'error',
      {
        patterns: [
          {
            group: ['**/device-management/**'],
            message: 'Import from @domain/device-management instead',
          },
        ],
      },
    ],
  },
};
```

This **fails builds** when someone violates boundaries, even though code is still in one directory.

### Step 2: Extract Domain Logic

Move business logic out of components into **plain TypeScript classes**:

```typescript
// Before (tangled)
function DeviceListComponent() {
  const [devices, setDevices] = useState<Device[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    fetch('/api/devices')
      .then(res => res.json())
      .then(data => setDevices(data));
  }, []);

  const handleCalibrate = (deviceId: string) => {
    fetch(`/api/devices/${deviceId}/calibrate`, { method: 'POST' })
      .then(() => alert('Calibrated!'));
  };

  return <div>{devices.map(d => <DeviceCard device={d} />)}</div>;
}

// After (separated)
// src/domain/DeviceService.ts
export class DeviceService {
  constructor(private api: ApiClient) {}

  async getDevices(): Promise<Device[]> {
    return this.api.get('/devices');
  }

  async calibrate(deviceId: DeviceId): Promise<void> {
    await this.api.post(`/devices/${deviceId}/calibrate`);
  }
}

// src/application/DeviceListViewModel.ts
export class DeviceListViewModel {
  readonly devices$ = this.devicesSubject.asObservable();

  constructor(private service: DeviceService) {}

  async load(): Promise<void> {
    const devices = await this.service.getDevices();
    this.devicesSubject.next(devices);
  }

  async calibrate(deviceId: DeviceId): Promise<void> {
    await this.service.calibrate(deviceId);
    await this.load();  // Refresh list
  }
}

// src/components/DeviceListComponent.tsx
function DeviceListComponent() {
  const { devices } = useDeviceViewModel();

  return <div>{devices.map(d => <DeviceCard device={d} />)}</div>;
}
```

Now you can **test DeviceService and ViewModel** without React. Move them to packages later.

### Step 3: Move to Packages Incrementally

Create the monorepo structure, then **move one domain at a time**:

```bash
# Week 1: Set up monorepo, move device-management
mkdir -p packages/domain/device-management/src
git mv src/domain/device-management/* packages/domain/device-management/src/

# Week 2: Move environmental-monitoring
mkdir -p packages/domain/environmental-monitoring/src
git mv src/domain/environmental-monitoring/* packages/domain/environmental-monitoring/src/

# Week 3: Extract ViewModels
mkdir -p packages/application/device-viewmodels/src
# ... and so on
```

**Use git history** to track which code moved where. Don't try to migrate everything at once.

### Step 4: Enforce with Tooling

Once packages exist, **add Sheriff**:

```bash
npm install --save-dev @sheriff/cli
npx sheriff init
```

This generates a config. **Start with loose rules**, then tighten:

```typescript
// Week 1: Just prevent cycles
export const config: SheriffConfig = {
  depRules: {
    root: ['* -> *'], // Allow everything for now
  },
};

// Week 4: Enforce layers
export const config: SheriffConfig = {
  depRules: {
    root: [
      'domain -> shared', // Domain can't depend on application
      'application -> domain', // Application can depend on domain
    ],
  },
};

// Week 8: Full enforcement with exceptions documented
export const config: SheriffConfig = {
  depRules: {
    root: ['domain -> shared', 'application -> domain', 'infrastructure -> domain'],
    // Document why this exception exists
    'domain:alerts': [
      'same -> domain:device-management', // Alerts need device context
    ],
  },
};
```

**Gradual adoption** prevents disruption.

## 19.11 When to Actually Split into Microfrontends

Sometimes you **do** need microfrontends. Here's when:

### Legitimate Reasons

1. **Independent deployment cycles**: Team A deploys every hour, Team B deploys once a month, and they genuinely can't coordinate
2. **Different tech stacks for good reasons**: Legacy Angular admin panel + new React customer app, and rewriting the admin panel isn't worth it
3. **Scale beyond one build**: Build times exceed 30 minutes even with Turbo caching, and you've exhausted optimization options
4. **Regulatory boundaries**: Different parts of the app have different compliance requirements (PCI, HIPAA), and auditors require physical separation

### Illegitimate Reasons (Don't Do This)

1. "Team autonomy" – **Fix your process, not your architecture**
2. "Different frameworks" – **This is a failure of architecture, not a microfrontend use case**
3. "Microservices on the backend" – **Backend architecture doesn't dictate frontend architecture**
4. "Faster builds" – **Try Turbo/Nx first**

### If You Must: Module Federation

[Webpack Module Federation](https://webpack.js.org/concepts/module-federation/) or [Vite Federation](https://github.com/originjs/vite-plugin-federation) let you load code dynamically:

```typescript
// apps/host/vite.config.ts
import federation from '@originjs/vite-plugin-federation';

export default defineConfig({
  plugins: [
    federation({
      name: 'host',
      remotes: {
        deviceManagement: 'http://localhost:5001/assets/remoteEntry.js',
        analytics: 'http://localhost:5002/assets/remoteEntry.js',
      },
      shared: ['react', 'react-dom', 'rxjs'], // Shared dependencies
    }),
  ],
});

// apps/device-management/vite.config.ts
export default defineConfig({
  plugins: [
    federation({
      name: 'deviceManagement',
      filename: 'remoteEntry.js',
      exposes: {
        './DeviceList': './src/components/DeviceList',
      },
      shared: ['react', 'react-dom', 'rxjs'],
    }),
  ],
});
```

**Usage:**

```typescript
// Host app dynamically loads remote
const DeviceList = lazy(() => import('deviceManagement/DeviceList'));

function App() {
  return (
    <Suspense fallback={<Spinner />}>
      <DeviceList />
    </Suspense>
  );
}
```

**But remember**: You've now introduced **network latency**, **version skew**, and **runtime errors**. Only do this if the benefits outweigh these costs.

## 19.12 Key Takeaways

1. **Monoliths scale when boundaries are enforced**. Sheriff + ESLint give you compile-time guarantees.
2. **Turborepo and Nx make monorepos fast**. Caching means you never rebuild unchanged code.
3. **Feature-sliced architecture works across frameworks**. The structure is the same; only adapters change.
4. **DDD maps naturally to packages**. Each bounded context becomes a package with clear exports.
5. **Testing is faster in monoliths**. No network boundaries means tests run in milliseconds.
6. **Deployment is simpler**. One artifact, one build, one cache.
7. **Microfrontends are a last resort**. Exhaust architectural options first.

The scalable monolith isn't a compromise—it's the **optimal architecture** for most teams. You get boundaries without distribution, team independence without fragmentation, and architectural enforcement without runtime overhead.

In the next chapter, we'll explore how **microfrontends** actually work (for the rare cases where you need them), and how to maintain the MVVM patterns we've established even across distributed frontend boundaries.

---

**Next Steps:**

1. **Set up a monorepo** with Turborepo or Nx
2. **Install Sheriff** and define initial boundary rules
3. **Organize by feature**, not by technical type
4. **Extract ViewModels** from components
5. **Enforce testing pyramid**: Many unit tests, some integration tests, few E2E tests
6. **Deploy as one artifact**, but use feature flags for incremental rollout

The tools exist. The patterns work. Now it's time to build your scalable monolith.
