---
id: "implementing-the-view-layer-react-edition"
title: Implementing the View Layer – React Edition
section: Framework-Agnostic Core
---

# Chapter 7: Implementing the View Layer – React Edition

We've built our framework-agnostic core. Now it's time to connect it to the real world. This is where theory meets practice, where your carefully crafted ViewModels finally talk to actual UI components.

Here's the thing: **the View layer is the only part of your application that's allowed to be framework-specific**. Everything else—your domain logic, your state management, your business rules—lives in that pristine, testable core we've been building. The View's job is singular: render what the ViewModel tells it to render, and forward user interactions back to the ViewModel. That's it.

In this chapter, we'll implement GreenWatch's View layer using React. We'll start with the fundamental patterns that make this integration work, then build progressively toward a complete, production-ready implementation. By the end, you'll understand not just _how_ to connect React to your ViewModels, but _why_ these patterns create applications that are easier to maintain, test, and reason about.

## The View Layer Contract

Before we write any React code, let's establish what we expect from our View layer. Think of this as a contract between your framework-agnostic core and the UI framework you've chosen.

**The View layer must:**

1. **Subscribe to ViewModel state changes** and re-render when state updates
2. **Forward user interactions** to ViewModel command handlers
3. **Remain completely stateless** regarding business logic—all logic lives in the ViewModel
4. **Handle only presentation concerns**—loading states, error displays, conditional rendering
5. **Never directly manipulate domain objects or perform business operations**

This contract is crucial. It's what allows us to swap React for Vue or Angular without touching our core logic. It's what makes testing straightforward because we can test ViewModels without rendering anything. It's what makes maintenance easier because each layer has clear, limited responsibilities.

Let's see what this looks like in practice.

## The Basic Pattern: Connecting React to RxJS

React doesn't natively understand RxJS observables. React's mental model is "props and state change, component re-renders." RxJS's mental model is "streams emit values over time, observers react." We need to bridge these two worlds.

Here's the fundamental pattern we'll use throughout this chapter:

```typescript
import { useEffect, useState } from "react";
import { Observable } from "rxjs";

export function useObservable<T>(
  observable$: Observable<T>,
  initialValue: T
): T {
  const [value, setValue] = useState<T>(initialValue);

  useEffect(() => {
    const subscription = observable$.subscribe(setValue);
    return () => subscription.unsubscribe();
  }, [observable$]);

  return value;
}
```

This custom hook does exactly what we need: it subscribes to an observable when the component mounts, updates React state whenever the observable emits, and cleans up the subscription when the component unmounts. It's simple, but it's the foundation of our entire View layer.

**Why this pattern works:** React handles the rendering lifecycle, RxJS handles the state changes. They each do what they're good at, and we've built a minimal, predictable bridge between them. We're not fighting either framework's design—we're respecting both.

Let's apply this to a real component.

## Building the GreenhouseCard Component

GreenWatch displays multiple greenhouses, each with their current environmental status. The `GreenhouseCard` component shows a single greenhouse's data: temperature, humidity, soil moisture, and any active alerts.

Here's our ViewModel interface (from Chapter 5):

```typescript
// src/presentation/greenhouses/greenhouse-list.viewmodel.ts
export interface GreenhouseCardViewModel {
  readonly state$: Observable<{
    greenhouse: Greenhouse;
    metrics: EnvironmentalMetrics;
    hasAlerts: boolean;
    isLoading: boolean;
  }>;

  readonly commands: {
    viewDetails: () => void;
    acknowledgeAlerts: () => void;
  };
}
```

Now let's build the React component that consumes it:

```typescript
// src/presentation/views/react/components/GreenhouseCard.tsx
import React from 'react';
import { GreenhouseCardViewModel } from '@presentation/greenhouses';
import { useObservable } from '@presentation/views/react/hooks';

interface GreenhouseCardProps {
  viewModel: GreenhouseCardViewModel;
}

export const GreenhouseCard: React.FC<GreenhouseCardProps> = ({ viewModel }) => {
  const state = useObservable(viewModel.state$, {
    greenhouse: null,
    metrics: null,
    hasAlerts: false,
    isLoading: true
  });

  if (state.isLoading) {
    return <LoadingCard />;
  }

  if (!state.greenhouse || !state.metrics) {
    return <ErrorCard message="Unable to load greenhouse data" />;
  }

  const { greenhouse, metrics, hasAlerts } = state;

  return (
    <div className="greenhouse-card">
      <header className="greenhouse-card__header">
        <h3>{greenhouse.name}</h3>
        {hasAlerts && <AlertBadge count={greenhouse.activeAlerts.length} />}
      </header>

      <section className="greenhouse-card__metrics">
        <MetricDisplay
          label="Temperature"
          value={metrics.temperature}
          unit="°C"
          status={getMetricStatus(metrics.temperature, greenhouse.config.temperatureRange)}
        />
        <MetricDisplay
          label="Humidity"
          value={metrics.humidity}
          unit="%"
          status={getMetricStatus(metrics.humidity, greenhouse.config.humidityRange)}
        />
        <MetricDisplay
          label="Soil Moisture"
          value={metrics.soilMoisture}
          unit="%"
          status={getMetricStatus(metrics.soilMoisture, greenhouse.config.moistureRange)}
        />
      </section>

      <footer className="greenhouse-card__actions">
        <button
          onClick={viewModel.commands.viewDetails}
          className="btn btn--primary"
        >
          View Details
        </button>
        {hasAlerts && (
          <button
            onClick={viewModel.commands.acknowledgeAlerts}
            className="btn btn--secondary"
          >
            Acknowledge Alerts
          </button>
        )}
      </footer>
    </div>
  );
};
```

**What's happening here?** The component receives a ViewModel as a prop—this is dependency injection at the component level. It uses our `useObservable` hook to subscribe to the ViewModel's state stream. When state changes, React re-renders. When the user clicks a button, we call the appropriate command on the ViewModel. The component doesn't know or care _how_ those commands work—that's the ViewModel's responsibility.

Notice what's **not** in this component:

- No business logic
- No state management beyond React's rendering concerns
- No direct API calls
- No domain object manipulation
- No complex calculations

This component is pure presentation. It displays what it's told to display and forwards user actions back to the ViewModel. That's the contract in action.

## Handling Asynchronous Operations

Real applications don't just display static data—they load data from servers, submit forms, and perform operations that take time. Let's see how our pattern handles async operations while maintaining separation of concerns.

Consider the greenhouse configuration form. Users need to update temperature thresholds, humidity ranges, and other parameters. Here's the ViewModel:

```typescript
// src/presentation/greenhouses/greenhouse-config.viewmodel.ts
export interface GreenhouseConfigViewModel {
  readonly state$: Observable<{
    config: GreenhouseConfiguration;
    isDirty: boolean;
    isSaving: boolean;
    validationErrors: Record<string, string>;
    saveError: string | null;
  }>;

  readonly commands: {
    updateTemperatureRange: (min: number, max: number) => void;
    updateHumidityRange: (min: number, max: number) => void;
    updateMoistureRange: (min: number, max: number) => void;
    save: () => Promise<void>;
    reset: () => void;
  };
}
```

The ViewModel tracks whether we're currently saving, whether the form has unsaved changes, and any validation errors. The View just needs to reflect this state:

```typescript
// src/presentation/views/react/components/GreenhouseConfigForm.tsx
export const GreenhouseConfigForm: React.FC<{
  viewModel: GreenhouseConfigViewModel;
}> = ({ viewModel }) => {
  const state = useObservable(viewModel.state$, {
    config: null,
    isDirty: false,
    isSaving: false,
    validationErrors: {},
    saveError: null
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await viewModel.commands.save();
      // ViewModel will update state$ to reflect success
    } catch (error) {
      // ViewModel handles error state, we just re-render
    }
  };

  if (!state.config) {
    return <LoadingForm />;
  }

  return (
    <form onSubmit={handleSubmit} className="config-form">
      {state.saveError && (
        <ErrorMessage message={state.saveError} />
      )}

      <fieldset disabled={state.isSaving}>
        <legend>Temperature Range</legend>
        <RangeInput
          label="Minimum Temperature"
          value={state.config.temperatureRange.min}
          onChange={(value) => viewModel.commands.updateTemperatureRange(
            value,
            state.config.temperatureRange.max
          )}
          error={state.validationErrors.temperatureMin}
          unit="°C"
        />
        <RangeInput
          label="Maximum Temperature"
          value={state.config.temperatureRange.max}
          onChange={(value) => viewModel.commands.updateTemperatureRange(
            state.config.temperatureRange.min,
            value
          )}
          error={state.validationErrors.temperatureMax}
          unit="°C"
        />
      </fieldset>

      {/* Similar fieldsets for humidity and moisture */}

      <div className="form-actions">
        <button
          type="button"
          onClick={viewModel.commands.reset}
          disabled={!state.isDirty || state.isSaving}
          className="btn btn--secondary"
        >
          Reset
        </button>
        <button
          type="submit"
          disabled={!state.isDirty || state.isSaving}
          className="btn btn--primary"
        >
          {state.isSaving ? 'Saving...' : 'Save Configuration'}
        </button>
      </div>
    </form>
  );
};
```

**The key insight:** The component doesn't manage the async operation—it just displays the current state of that operation. When `save()` is called, the ViewModel updates `isSaving` to `true`, performs the operation, then updates the state again with the result. The component re-renders at each state change because it's subscribed to `state$`.

This pattern eliminates entire categories of bugs. You can't forget to set loading states because the ViewModel controls them. You can't have race conditions in the UI because all state changes flow through a single stream. You can't display stale data because the component always reflects the current observable value.

## Composing Complex Views

Real applications don't consist of isolated components—they're composed of many components working together, each with its own ViewModel. Let's look at how to structure a complete page.

The Greenhouse Detail view shows comprehensive information about a single greenhouse: current metrics, historical data, device status, and active alerts. This requires coordinating multiple ViewModels:

```typescript
// src/presentation/greenhouses/greenhouse-detail.viewmodel.ts
export interface GreenhouseDetailViewModel {
  readonly header: GreenhouseHeaderViewModel;
  readonly metrics: EnvironmentalMetricsViewModel;
  readonly history: MetricsHistoryViewModel;
  readonly devices: DeviceStatusViewModel;
  readonly alerts: AlertListViewModel;

  readonly state$: Observable<{
    isLoading: boolean;
    error: string | null;
  }>;
}
```

Each child ViewModel handles its own domain area, and the parent coordinates them. Here's the React implementation:

```typescript
// src/presentation/views/react/pages/GreenhouseDetailPage.tsx
export const GreenhouseDetailPage: React.FC<{
  viewModel: GreenhouseDetailViewModel;
}> = ({ viewModel }) => {
  const state = useObservable(viewModel.state$, {
    isLoading: true,
    error: null
  });

  if (state.isLoading) {
    return <LoadingPage />;
  }

  if (state.error) {
    return <ErrorPage message={state.error} />;
  }

  return (
    <div className="greenhouse-detail">
      <GreenhouseHeader viewModel={viewModel.header} />

      <div className="greenhouse-detail__grid">
        <section className="metrics-section">
          <h2>Current Conditions</h2>
          <EnvironmentalMetrics viewModel={viewModel.metrics} />
        </section>

        <section className="history-section">
          <h2>24-Hour History</h2>
          <MetricsHistory viewModel={viewModel.history} />
        </section>

        <section className="devices-section">
          <h2>Connected Devices</h2>
          <DeviceStatus viewModel={viewModel.devices} />
        </section>

        <section className="alerts-section">
          <h2>Active Alerts</h2>
          <AlertList viewModel={viewModel.alerts} />
        </section>
      </div>
    </div>
  );
};
```

**This is compositional architecture in practice.** Each section has its own ViewModel that handles its own domain concerns. The page component just arranges them spatially. If we need to add a new section (say, an irrigation schedule), we add a new ViewModel to the coordinator and a new component to the page. No existing code changes.

More importantly, we can test each ViewModel independently. We can test the `MetricsHistoryViewModel` without caring about alerts. We can test the `AlertListViewModel` without rendering any charts. The separation of concerns isn't theoretical—it has concrete benefits for testing, maintenance, and team collaboration.

## Optimizing Re-renders with Memoization

React re-renders components when their props change. Since we're passing ViewModels as props, we need to ensure we're not creating unnecessary re-renders. Here's where React's memoization features help us.

```typescript
// src/presentation/views/react/components/EnvironmentalMetrics.tsx
export const EnvironmentalMetrics: React.FC<{
  viewModel: EnvironmentalMetricsViewModel;
}> = React.memo(({ viewModel }) => {
  const state = useObservable(viewModel.state$, {
    current: null,
    trend: null,
    isLoading: true
  });

  if (state.isLoading || !state.current) {
    return <MetricsSkeleton />;
  }

  return (
    <div className="environmental-metrics">
      <MetricCard
        icon="thermometer"
        label="Temperature"
        value={state.current.temperature}
        unit="°C"
        trend={state.trend?.temperature}
      />
      <MetricCard
        icon="droplet"
        label="Humidity"
        value={state.current.humidity}
        unit="%"
        trend={state.trend?.humidity}
      />
      <MetricCard
        icon="droplets"
        label="Soil Moisture"
        value={state.current.soilMoisture}
        unit="%"
        trend={state.trend?.soilMoisture}
      />
    </div>
  );
});

EnvironmentalMetrics.displayName = 'EnvironmentalMetrics';
```

By wrapping our component with `React.memo`, we tell React to skip re-rendering if the ViewModel reference hasn't changed. Since we typically create ViewModels once at the page level and pass them down, this prevents unnecessary re-renders in child components.

**A word of caution:** Don't memoize everything. Memoization has its own performance cost. Use it for components that:

1. Receive complex ViewModels with many observables
2. Render frequently due to parent re-renders
3. Perform expensive rendering operations

For simple components that render quickly, the memoization overhead isn't worth it.

## Handling Navigation and Routing

ViewModels shouldn't know about React Router (or any other routing library). But they do need to trigger navigation—when you save a greenhouse configuration, you should navigate back to the list. How do we handle this while maintaining our architectural boundaries?

**The answer: navigation is an external dependency, just like API clients.** We inject it into our ViewModels through an abstraction:

```typescript
// src/presentation/services/navigation.service.ts
export interface NavigationService {
  navigateTo(route: string, params?: Record<string, unknown>): void;
  navigateBack(): void;
  getCurrentRoute(): string;
}

// src/presentation/views/react/services/react-navigation.service.ts
import { useNavigate, useLocation } from "react-router-dom";

export class ReactNavigationService implements NavigationService {
  constructor(
    private navigate: ReturnType<typeof useNavigate>,
    private location: ReturnType<typeof useLocation>
  ) {}

  navigateTo(route: string, params?: Record<string, unknown>): void {
    this.navigate(route, { state: params });
  }

  navigateBack(): void {
    this.navigate(-1);
  }

  getCurrentRoute(): string {
    return this.location.pathname;
  }
}
```

Now our ViewModels can navigate without knowing anything about React Router:

```typescript
// src/presentation/greenhouses/greenhouse-config.viewmodel.impl.ts
export class GreenhouseConfigViewModelImpl
  implements GreenhouseConfigViewModel
{
  constructor(
    private greenhouseId: string,
    private configService: GreenhouseConfigService,
    private navigationService: NavigationService
  ) {
    this.initializeState();
  }

  readonly commands = {
    save: async () => {
      this.stateSubject.next({ ...this.currentState, isSaving: true });

      try {
        await this.configService.saveConfiguration(
          this.greenhouseId,
          this.currentState.config
        );

        this.navigationService.navigateBack();
      } catch (error) {
        this.stateSubject.next({
          ...this.currentState,
          isSaving: false,
          saveError: "Failed to save configuration",
        });
      }
    },
  };
}
```

At the page level, we wire this up using React Router's hooks:

```typescript
// src/presentation/views/react/pages/GreenhouseConfigPage.tsx
export const GreenhouseConfigPage: React.FC = () => {
  const { greenhouseId } = useParams<{ greenhouseId: string }>();
  const navigate = useNavigate();
  const location = useLocation();

  const viewModel = useMemo(() => {
    const navigationService = new ReactNavigationService(navigate, location);
    const configService = container.resolve<GreenhouseConfigService>('GreenhouseConfigService');

    return new GreenhouseConfigViewModelImpl(
      greenhouseId!,
      configService,
      navigationService
    );
  }, [greenhouseId, navigate, location]);

  return <GreenhouseConfigForm viewModel={viewModel} />;
};
```

**Why this matters:** If we decide to switch from React Router to TanStack Router, we only change the implementation of `NavigationService`. The ViewModels don't change. The components don't change. Our tests don't change. That's the power of abstraction at architectural boundaries.

## Error Boundaries and Graceful Degradation

Even with perfect architecture, things fail. Network requests time out. APIs return unexpected data. Devices disconnect. A robust View layer handles these failures gracefully.

React's Error Boundaries catch rendering errors, but they don't catch errors in async code or event handlers. Since our ViewModels handle async operations, we need a strategy for surfacing those errors to the UI.

**We use two complementary approaches:**

1. **State-based error handling for expected failures:** Network timeouts, validation errors, business rule violations. These go into the ViewModel state and the component renders them.

2. **Error boundaries for unexpected failures:** Null reference exceptions, unhandled promise rejections, catastrophic failures. These are caught by React Error Boundaries and shown as fallback UI.

Here's a reusable error boundary for our pages:

```typescript
// src/presentation/views/react/components/ErrorBoundary.tsx
interface ErrorBoundaryProps {
  fallback: React.ComponentType<{ error: Error; reset: () => void }>;
  children: React.ReactNode;
}

interface ErrorBoundaryState {
  error: Error | null;
}

export class ErrorBoundary extends React.Component
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    // Log to error tracking service (e.g., Sentry)
    console.error('Caught by ErrorBoundary:', error, errorInfo);
  }

  reset = (): void => {
    this.setState({ error: null });
  };

  render(): React.ReactNode {
    if (this.state.error) {
      const Fallback = this.props.fallback;
      return <Fallback error={this.state.error} reset={this.reset} />;
    }

    return this.props.children;
  }
}

// Usage in app structure
export const App: React.FC = () => {
  return (
    <ErrorBoundary fallback={GlobalErrorFallback}>
      <Router>
        <Routes>
          <Route path="/greenhouses" element={
            <ErrorBoundary fallback={PageErrorFallback}>
              <GreenhouseListPage />
            </ErrorBoundary>
          } />
          {/* Other routes */}
        </Routes>
      </Router>
    </ErrorBoundary>
  );
};
```

For expected errors, the ViewModel manages them as state:

```typescript
// Inside GreenhouseListViewModel implementation
private async loadGreenhouses(): Promise<void> {
  this.stateSubject.next({
    ...this.currentState,
    isLoading: true,
    error: null
  });

  try {
    const greenhouses = await this.greenhouseService.getAll();
    this.stateSubject.next({
      greenhouses,
      isLoading: false,
      error: null
    });
  } catch (error) {
    this.stateSubject.next({
      ...this.currentState,
      isLoading: false,
      error: 'Unable to load greenhouses. Please check your connection and try again.'
    });
  }
}
```

The component renders the error state normally:

```typescript
export const GreenhouseListPage: React.FC<{
  viewModel: GreenhouseListViewModel;
}> = ({ viewModel }) => {
  const state = useObservable(viewModel.state$, {
    greenhouses: [],
    isLoading: true,
    error: null
  });

  if (state.error) {
    return (
      <ErrorState
        message={state.error}
        action={{
          label: 'Retry',
          onClick: () => viewModel.commands.refresh()
        }}
      />
    );
  }

  // Normal rendering...
};
```

This dual approach gives us the best of both worlds: graceful handling of expected failures with clear user feedback, and a safety net for unexpected failures that prevents the entire app from crashing.

## Testing the View Layer

Here's where our architectural investment pays off. Testing React components connected to ViewModels is straightforward because we can create test doubles for the ViewModels.

```typescript
// src/presentation/views/react/components/__tests__/GreenhouseCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { BehaviorSubject } from 'rxjs';
import { GreenhouseCard } from '../GreenhouseCard';
import type { GreenhouseCardViewModel } from '@presentation/greenhouses';

describe('GreenhouseCard', () => {
  it('displays greenhouse metrics when loaded', () => {
    const stateSubject = new BehaviorSubject({
      greenhouse: {
        id: 'gh-1',
        name: 'Greenhouse Alpha',
        activeAlerts: []
      },
      metrics: {
        temperature: 22.5,
        humidity: 65,
        soilMoisture: 40
      },
      hasAlerts: false,
      isLoading: false
    });

    const viewModel: GreenhouseCardViewModel = {
      state$: stateSubject.asObservable(),
      commands: {
        viewDetails: jest.fn(),
        acknowledgeAlerts: jest.fn()
      }
    };

    render(<GreenhouseCard viewModel={viewModel} />);

    expect(screen.getByText('Greenhouse Alpha')).toBeInTheDocument();
    expect(screen.getByText('22.5°C')).toBeInTheDocument();
    expect(screen.getByText('65%')).toBeInTheDocument();
  });

  it('calls viewDetails command when button clicked', () => {
    const viewDetailsCommand = jest.fn();
    const stateSubject = new BehaviorSubject({
      greenhouse: { id: 'gh-1', name: 'Test', activeAlerts: [] },
      metrics: { temperature: 20, humidity: 60, soilMoisture: 35 },
      hasAlerts: false,
      isLoading: false
    });

    const viewModel: GreenhouseCardViewModel = {
      state$: stateSubject.asObservable(),
      commands: {
        viewDetails: viewDetailsCommand,
        acknowledgeAlerts: jest.fn()
      }
    };

    render(<GreenhouseCard viewModel={viewModel} />);

    fireEvent.click(screen.getByText('View Details'));

    expect(viewDetailsCommand).toHaveBeenCalledTimes(1);
  });

  it('re-renders when state changes', () => {
    const stateSubject = new BehaviorSubject({
      greenhouse: { id: 'gh-1', name: 'Test', activeAlerts: [] },
      metrics: { temperature: 20, humidity: 60, soilMoisture: 35 },
      hasAlerts: false,
      isLoading: false
    });

    const viewModel: GreenhouseCardViewModel = {
      state$: stateSubject.asObservable(),
      commands: {
        viewDetails: jest.fn(),
        acknowledgeAlerts: jest.fn()
      }
    };

    const { rerender } = render(<GreenhouseCard viewModel={viewModel} />);
    expect(screen.getByText('20°C')).toBeInTheDocument();

    // Update the state
    stateSubject.next({
      ...stateSubject.value,
      metrics: { temperature: 25, humidity: 60, soilMoisture: 35 }
    });

    rerender(<GreenhouseCard viewModel={viewModel} />);
    expect(screen.getByText('25°C')).toBeInTheDocument();
  });
});
```

**Notice what we're not doing:** We're not mocking RxJS. We're not mocking React hooks. We're using real `BehaviorSubject` instances and testing the actual subscription behavior. The only thing we're controlling is the ViewModel—and we're controlling it through its public interface.

This is fast, reliable testing. No brittle mocks. No complex setup. Just create a ViewModel test double, render the component, verify the output.

## Performance Considerations

React + RxJS is performant when done correctly, but there are some patterns to avoid:

**Don't: Create observables in render:**

```typescript
// ❌ BAD: Creates new observable on every render
const MetricsDisplay: React.FC = () => {
  const metrics$ = getMetricsStream(); // New observable every render!
  const metrics = useObservable(metrics$, null);
  // ...
};
```

**Do: Receive observables as props or create them with useMemo:**

```typescript
// ✅ GOOD: Observable is stable across renders
const MetricsDisplay: React.FC<{ viewModel: MetricsViewModel }> = ({
  viewModel,
}) => {
  const metrics = useObservable(viewModel.metrics$, null);
  // ...
};

// ✅ ALSO GOOD: Observable is memoized
const MetricsDisplay: React.FC<{ greenhouseId: string }> = ({
  greenhouseId,
}) => {
  const metrics$ = useMemo(
    () => getMetricsStream(greenhouseId),
    [greenhouseId]
  );
  const metrics = useObservable(metrics$, null);
  // ...
};
```

**Don't: Use observables for every tiny piece of state:**

```typescript
// ❌ BAD: Observable overkill for UI-only state
const SearchInput: React.FC = () => {
  const [inputValue$] = useState(() => new BehaviorSubject(''));
  const value = useObservable(inputValue$, '');

  return (
    <input
      value={value}
      onChange={(e) => inputValue$.next(e.target.value)}
    />
  );
};
```

**Do: Use React state for purely presentational concerns:**

```typescript
// ✅ GOOD: Plain React state for UI concerns
const SearchInput: React.FC<{ onSearch: (term: string) => void }> = ({ onSearch }) => {
  const [value, setValue] = useState('');

  return (
    <input
      value={value}
      onChange={(e) => setValue(e.target.value)}
      onBlur={() => onSearch(value)}
    />
  );
};
```

**The rule of thumb:** Use observables for state that comes from your ViewModels. Use React state for purely UI concerns like accordion open/closed state, form input values (before submission), hover states, and other presentational details.

## What We've Built

We've implemented a complete View layer that connects React to our framework-agnostic core. We've established clear patterns for:

- Subscribing to ViewModel state and triggering re-renders
- Forwarding user interactions to ViewModel commands
- Composing complex views from multiple ViewModels
- Handling async operations and error states
- Managing navigation while respecting architectural boundaries
- Testing components in isolation

The components we've built don't contain business logic. They don't directly call APIs. They don't manipulate domain objects. They do exactly one thing: translate ViewModel state into visual elements and translate user interactions into ViewModel commands.

This is what the View layer should be—a thin, declarative shell around your core logic. It's framework-specific by necessity, but it's so simple and predictable that changing frameworks becomes a realistic option rather than a project-killing endeavor.

In the next chapter, we'll implement the exact same application using Vue. You'll see how the ViewModels don't change at all—only the View layer changes. That's the promise of framework-agnostic architecture: invest in your core logic once, swap out the UI as needed.

But before we move on, make sure you understand the patterns here. Build a few components. Wire them up to real ViewModels. Get comfortable with the `useObservable` hook and the ViewModel-as-props pattern. These aren't theoretical constructs—they're practical tools you'll use in every component you build from here forward.
