# Chapter 13: Vue Implementation — Proving Framework Independence

When we built the React implementation of GreenWatch in Chapter 11, we made a deliberate architectural bet: that our ViewModels, domain logic, and state management would work unchanged across different frameworks. Now it's time to prove it.

This chapter isn't about learning Vue. If you're reading this book, you likely already know at least one modern framework—whether that's React, Vue, or Angular. What matters here is demonstrating that the architectural principles we've established actually deliver on their promise of framework independence.

We'll implement the same GreenWatch greenhouse monitoring features we built in React, but this time using Vue 3's Composition API. You'll see that our `GreenhouseViewModel`, our domain services, and our entire business logic layer remain completely untouched. Only the View layer changes—and that's exactly the point.

## The Real Value of Framework Independence

Before we dive into code, let's be clear about why this matters.

Framework independence isn't about being able to rewrite your entire application in a different framework on a whim. That's not a realistic business scenario, and it's not what we're optimizing for. The real value shows up in three practical situations:

**First, it protects you from framework obsolescence.** Remember AngularJS? Backbone? If you built your business logic directly into those frameworks, you threw it away and started over when they became obsolete. With our architecture, when the next framework shift happens—and it will—you'll port your View layer while keeping your tested, battle-hardened business logic intact.

**Second, it enables genuine code reuse across platforms.** Your web application and your mobile application need the same business rules, validation logic, and state management. With framework-agnostic ViewModels, you can share that logic between React web, React Native mobile, and even Electron desktop applications. You're not just sharing utilities—you're sharing the _intelligent_ parts of your application.

**Third, it makes your codebase more maintainable right now.** When business logic lives in ViewModels rather than components, developers don't need to understand framework-specific patterns to modify that logic. A developer who knows TypeScript and RxJS can work on your ViewModels regardless of whether they know React, Vue, or Angular.

Let's prove all three benefits by building the same application twice.

## What We're Building (Again)

We'll implement the same three core features from Chapter 11:

1. **Real-time greenhouse monitoring** displaying temperature, humidity, and soil moisture with visual indicators for critical thresholds
2. **Historical trends visualization** showing how environmental parameters change over time
3. **Alert management** displaying active warnings when parameters exceed safe ranges

The domain logic, validation rules, and business behavior remain identical. We're not simplifying anything for Vue or adding Vue-specific features. This is a true apples-to-apples comparison.

## The ViewModel: Already Done

Here's something remarkable. We don't need to write this:

```typescript
// ❌ We DON'T need to create a Vue-specific ViewModel
export class VueGreenhouseViewModel {
  // No Vue-specific implementation needed
}
```

Why? Because we already have `GreenhouseViewModel`. Let's look at it again, paying attention to what makes it framework-agnostic:

```typescript
// ✅ This ViewModel works in React, Vue, Angular—anything
export class GreenhouseViewModel {
  // Public observables for View consumption
  readonly currentReadings$: Observable<EnvironmentalReading>;
  readonly historicalData$: Observable<HistoricalDataPoint[]>;
  readonly activeAlerts$: Observable<Alert[]>;
  readonly isLoading$: Observable<boolean>;

  // Private subjects for internal state management
  private readonly readingsSubject = new BehaviorSubject<EnvironmentalReading | null>(null);
  private readonly historySubject = new BehaviorSubject<HistoricalDataPoint[]>([]);
  private readonly alertsSubject = new BehaviorSubject<Alert[]>([]);
  private readonly loadingSubject = new BehaviorSubject<boolean>(false);

  constructor(
    private readonly monitoringService: GreenhouseMonitoringService,
    private readonly alertService: AlertService,
    private readonly greenhouseId: string,
  ) {
    this.currentReadings$ = this.readingsSubject
      .asObservable()
      .pipe(filter((reading): reading is EnvironmentalReading => reading !== null));

    this.historicalData$ = this.historySubject.asObservable();
    this.activeAlerts$ = this.alertsSubject.asObservable();
    this.isLoading$ = this.loadingSubject.asObservable();
  }

  initialize(): void {
    this.loadingSubject.next(true);

    // Subscribe to real-time readings
    this.monitoringService
      .streamReadings(this.greenhouseId)
      .pipe(
        tap(() => this.loadingSubject.next(false)),
        catchError((error) => {
          console.error('Failed to stream readings:', error);
          this.loadingSubject.next(false);
          return EMPTY;
        }),
      )
      .subscribe((reading) => this.readingsSubject.next(reading));

    // Load historical data
    this.loadHistoricalData();

    // Subscribe to alerts
    this.alertService.streamAlerts(this.greenhouseId).subscribe((alerts) => this.alertsSubject.next(alerts));
  }

  private loadHistoricalData(): void {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setHours(startDate.getHours() - 24);

    this.monitoringService
      .getHistoricalData(this.greenhouseId, startDate, endDate)
      .subscribe((data) => this.historySubject.next(data));
  }

  acknowledgeAlert(alertId: string): void {
    this.alertService.acknowledgeAlert(alertId).subscribe({
      next: () => {
        const currentAlerts = this.alertsSubject.value;
        this.alertsSubject.next(currentAlerts.filter((alert) => alert.id !== alertId));
      },
      error: (error) => {
        console.error('Failed to acknowledge alert:', error);
      },
    });
  }

  dispose(): void {
    this.readingsSubject.complete();
    this.historySubject.complete();
    this.alertsSubject.complete();
    this.loadingSubject.complete();
  }
}
```

Notice what's _not_ here:

- No React hooks
- No Vue refs or reactivity
- No Angular decorators
- No framework-specific lifecycle methods
- No JSX or template syntax

This is pure TypeScript. The ViewModel exposes its state through **RxJS observables**, and any framework that can subscribe to observables can use it. That's the entire trick.

## Bridging RxJS to Vue Reactivity

Vue 3's Composition API is built on a different reactivity system than RxJS. Vue uses **proxies** to track dependencies and trigger updates, while RxJS uses **observables** for reactive streams. We need a bridge.

Here's our solution—a composable that converts RxJS observables into Vue refs:

```typescript
// src/presentation/vue/composables/useObservable.ts
import { ref, onUnmounted, Ref } from 'vue';
import { Observable } from 'rxjs';

export function useObservable<T>(observable: Observable<T>, initialValue: T): Ref<T> {
  const value = ref<T>(initialValue) as Ref<T>;

  const subscription = observable.subscribe({
    next: (newValue) => {
      value.value = newValue;
    },
    error: (error) => {
      console.error('Observable error:', error);
    },
  });

  onUnmounted(() => {
    subscription.unsubscribe();
  });

  return value;
}
```

This is elegantly simple. We create a Vue `ref` with an initial value, subscribe to the observable, and update the ref whenever the observable emits. When the component unmounts, we clean up the subscription.

This pattern is important because it shows how architectural boundaries work in practice. We're not mixing concerns—the ViewModel doesn't know about Vue refs, and Vue components don't directly manipulate RxJS subjects. The composable is a clean adapter between two reactivity systems.

## Building the Vue Component

Now we can build our Vue component. It'll look different from React's JSX, but the architectural pattern is identical: the component subscribes to ViewModel state and invokes ViewModel methods for user actions.

```typescript
// src/presentation/vue/components/GreenhouseMonitor.vue
<script setup lang="ts">
import { onMounted, onUnmounted, computed } from 'vue';
import { GreenhouseViewModel } from '@/application/viewmodels/GreenhouseViewModel';
import { useObservable } from '@/presentation/vue/composables/useObservable';
import AlertList from './AlertList.vue';
import EnvironmentalDisplay from './EnvironmentalDisplay.vue';
import HistoricalChart from './HistoricalChart.vue';

interface Props {
  viewModel: GreenhouseViewModel;
}

const props = defineProps<Props>();

// Convert ViewModel observables to Vue refs
const currentReadings = useObservable(
  props.viewModel.currentReadings$,
  null
);

const historicalData = useObservable(
  props.viewModel.historicalData$,
  []
);

const activeAlerts = useObservable(
  props.viewModel.activeAlerts$,
  []
);

const isLoading = useObservable(
  props.viewModel.isLoading$,
  true
);

// Computed properties for derived state
const hasAlerts = computed(() => activeAlerts.value.length > 0);

const criticalAlerts = computed(() =>
  activeAlerts.value.filter(alert => alert.severity === 'critical')
);

// Lifecycle management
onMounted(() => {
  props.viewModel.initialize();
});

onUnmounted(() => {
  props.viewModel.dispose();
});

// Event handlers
const handleAlertAcknowledge = (alertId: string) => {
  props.viewModel.acknowledgeAlert(alertId);
};
</script>

<template>
  <div class="greenhouse-monitor">
    <div v-if="isLoading" class="loading-state">
      <div class="spinner" />
      <p>Loading greenhouse data...</p>
    </div>

    <template v-else>
      <div class="monitor-header">
        <h1>Greenhouse Monitor</h1>
        <div v-if="hasAlerts" class="alert-badge">
          {{ criticalAlerts.length }} Critical Alerts
        </div>
      </div>

      <div class="monitor-content">
        <EnvironmentalDisplay
          v-if="currentReadings"
          :temperature="currentReadings.temperature"
          :humidity="currentReadings.humidity"
          :soilMoisture="currentReadings.soilMoisture"
          :timestamp="currentReadings.timestamp"
        />

        <HistoricalChart
          :data="historicalData"
          :loading="isLoading"
        />

        <AlertList
          v-if="hasAlerts"
          :alerts="activeAlerts"
          @acknowledge="handleAlertAcknowledge"
        />
      </div>
    </template>
  </div>
</template>

<style scoped>
.greenhouse-monitor {
  padding: 2rem;
  max-width: 1200px;
  margin: 0 auto;
}

.loading-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
}

.spinner {
  width: 48px;
  height: 48px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.monitor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
}

.alert-badge {
  padding: 0.5rem 1rem;
  background-color: #e74c3c;
  color: white;
  border-radius: 4px;
  font-weight: 600;
}

.monitor-content {
  display: grid;
  gap: 2rem;
}
</style>
```

Compare this to the React implementation from Chapter 11. The structure is remarkably similar:

1. **We receive the ViewModel via props** (not through context or dependency injection—keeping it simple)
2. **We convert observables to framework-native reactive primitives** (refs in Vue, state in React)
3. **We initialize the ViewModel on mount and dispose on unmount**
4. **We create event handlers that call ViewModel methods**
5. **We render child components with data from the ViewModel**

The template syntax differs from JSX, but the architectural flow is identical. That's what framework independence looks like—different syntax, same structure.

## Building Child Components

Let's implement one of the child components to show the pattern continues all the way down:

```typescript
// src/presentation/vue/components/EnvironmentalDisplay.vue
<script setup lang="ts">
import { computed } from 'vue';

interface Props {
  temperature: number;
  humidity: number;
  soilMoisture: number;
  timestamp: Date;
}

const props = defineProps<Props>();

// Business logic for threshold evaluation
// (In a real app, this might come from the ViewModel)
const getTemperatureStatus = computed(() => {
  if (props.temperature < 15 || props.temperature > 30) {
    return { status: 'critical', color: '#e74c3c' };
  }
  if (props.temperature < 18 || props.temperature > 27) {
    return { status: 'warning', color: '#f39c12' };
  }
  return { status: 'normal', color: '#27ae60' };
});

const getHumidityStatus = computed(() => {
  if (props.humidity < 40 || props.humidity > 80) {
    return { status: 'critical', color: '#e74c3c' };
  }
  if (props.humidity < 50 || props.humidity > 70) {
    return { status: 'warning', color: '#f39c12' };
  }
  return { status: 'normal', color: '#27ae60' };
});

const getSoilMoistureStatus = computed(() => {
  if (props.soilMoisture < 30 || props.soilMoisture > 80) {
    return { status: 'critical', color: '#e74c3c' };
  }
  if (props.soilMoisture < 40 || props.soilMoisture > 70) {
    return { status: 'warning', color: '#f39c12' };
  }
  return { status: 'normal', color: '#27ae60' };
});

const formattedTime = computed(() => {
  return props.timestamp.toLocaleTimeString();
});
</script>

<template>
  <div class="environmental-display">
    <h2>Current Conditions</h2>
    <p class="timestamp">Last updated: {{ formattedTime }}</p>

    <div class="readings-grid">
      <div class="reading-card">
        <div class="reading-header">
          <h3>Temperature</h3>
          <span
            class="status-indicator"
            :style="{ backgroundColor: getTemperatureStatus.color }"
          />
        </div>
        <div class="reading-value">
          {{ temperature.toFixed(1) }}°C
        </div>
        <div class="reading-status">
          {{ getTemperatureStatus.status }}
        </div>
      </div>

      <div class="reading-card">
        <div class="reading-header">
          <h3>Humidity</h3>
          <span
            class="status-indicator"
            :style="{ backgroundColor: getHumidityStatus.color }"
          />
        </div>
        <div class="reading-value">
          {{ humidity.toFixed(1) }}%
        </div>
        <div class="reading-status">
          {{ getHumidityStatus.status }}
        </div>
      </div>

      <div class="reading-card">
        <div class="reading-header">
          <h3>Soil Moisture</h3>
          <span
            class="status-indicator"
            :style="{ backgroundColor: getSoilMoistureStatus.color }"
          />
        </div>
        <div class="reading-value">
          {{ soilMoisture.toFixed(1) }}%
        </div>
        <div class="reading-status">
          {{ getSoilMoistureStatus.status }}
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.environmental-display {
  background: white;
  border-radius: 8px;
  padding: 1.5rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.timestamp {
  color: #7f8c8d;
  font-size: 0.9rem;
  margin-bottom: 1rem;
}

.readings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
}

.reading-card {
  border: 1px solid #ecf0f1;
  border-radius: 4px;
  padding: 1rem;
}

.reading-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
}

.reading-header h3 {
  margin: 0;
  font-size: 1rem;
  color: #2c3e50;
}

.status-indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

.reading-value {
  font-size: 2rem;
  font-weight: 600;
  color: #2c3e50;
  margin: 0.5rem 0;
}

.reading-status {
  font-size: 0.875rem;
  color: #7f8c8d;
  text-transform: capitalize;
}
</style>
```

Notice something here: we've put threshold evaluation logic in the component. Is this wrong? Not necessarily—it depends on your requirements.

If threshold logic is pure presentation (displaying different colors), keeping it in the component is fine. If it's business logic that affects behavior beyond display (triggering alerts, logging events), it belongs in the ViewModel or domain layer.

This is a judgment call you'll make based on your application's needs. The architecture doesn't dogmatically enforce where every piece of logic lives—it gives you the tools to make informed decisions about boundaries.

## Dependency Injection in Vue

We need to provide the ViewModel to our component. In React, we used Context. In Vue, we've got several options. Let's use Vue's `provide/inject` API:

```typescript
// src/presentation/vue/main.ts
import { createApp } from 'vue';
import App from './App.vue';
import { GreenhouseViewModel } from '@/application/viewmodels/GreenhouseViewModel';
import { GreenhouseMonitoringService } from '@/domain/services/GreenhouseMonitoringService';
import { AlertService } from '@/domain/services/AlertService';

const app = createApp(App);

// Create service instances
// (In production, you'd use a proper DI container)
const monitoringService = new GreenhouseMonitoringService();
/* inject HTTP client or API gateway */

const alertService = new AlertService();
/* inject dependencies */

// Create ViewModel instance
const greenhouseViewModel = new GreenhouseViewModel(
  monitoringService,
  alertService,
  'greenhouse-001', // In real app, this would be dynamic
);

// Provide ViewModel to entire app
app.provide('greenhouseViewModel', greenhouseViewModel);

app.mount('#app');
```

Then inject it in components:

```typescript
// src/presentation/vue/components/GreenhouseMonitor.vue
<script setup lang="ts">
import { inject } from 'vue';
import { GreenhouseViewModel } from '@/application/viewmodels/GreenhouseViewModel';

const viewModel = inject<GreenhouseViewModel>('greenhouseViewModel');

if (!viewModel) {
  throw new Error('GreenhouseViewModel not provided');
}

// Rest of component code...
</script>
```

This pattern mirrors React's Context API conceptually, though the syntax differs. Both solve the same problem: passing dependencies through the component tree without prop drilling.

## Testing Vue Components

Here's where framework independence pays immediate dividends. Our ViewModel tests remain unchanged—we don't need to rewrite them for Vue. We only need to test the Vue-specific integration layer.

```typescript
// src/presentation/vue/components/__tests__/GreenhouseMonitor.spec.ts
import { mount } from '@vue/test-utils';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { BehaviorSubject } from 'rxjs';
import GreenhouseMonitor from '../GreenhouseMonitor.vue';
import { GreenhouseViewModel } from '@/application/viewmodels/GreenhouseViewModel';
import type { EnvironmentalReading, Alert } from '@/domain/types';

describe('GreenhouseMonitor', () => {
  let mockViewModel: jest.Mocked<GreenhouseViewModel>;
  let readingsSubject: BehaviorSubject<EnvironmentalReading | null>;
  let alertsSubject: BehaviorSubject<Alert[]>;
  let loadingSubject: BehaviorSubject<boolean>;

  beforeEach(() => {
    // Create test subjects
    readingsSubject = new BehaviorSubject<EnvironmentalReading | null>(null);
    alertsSubject = new BehaviorSubject<Alert[]>([]);
    loadingSubject = new BehaviorSubject<boolean>(true);

    // Create mock ViewModel
    mockViewModel = {
      currentReadings$: readingsSubject.asObservable(),
      activeAlerts$: alertsSubject.asObservable(),
      isLoading$: loadingSubject.asObservable(),
      historicalData$: new BehaviorSubject([]).asObservable(),
      initialize: vi.fn(),
      dispose: vi.fn(),
      acknowledgeAlert: vi.fn(),
    } as any;
  });

  it('renders loading state initially', () => {
    const wrapper = mount(GreenhouseMonitor, {
      props: { viewModel: mockViewModel },
    });

    expect(wrapper.find('.loading-state').exists()).toBe(true);
    expect(wrapper.text()).toContain('Loading greenhouse data');
  });

  it('initializes ViewModel on mount', () => {
    mount(GreenhouseMonitor, {
      props: { viewModel: mockViewModel },
    });

    expect(mockViewModel.initialize).toHaveBeenCalled();
  });

  it('disposes ViewModel on unmount', () => {
    const wrapper = mount(GreenhouseMonitor, {
      props: { viewModel: mockViewModel },
    });

    wrapper.unmount();

    expect(mockViewModel.dispose).toHaveBeenCalled();
  });

  it('displays environmental readings when loaded', async () => {
    loadingSubject.next(false);
    readingsSubject.next({
      temperature: 22.5,
      humidity: 65.0,
      soilMoisture: 55.0,
      timestamp: new Date('2024-01-15T10:30:00Z'),
    });

    const wrapper = mount(GreenhouseMonitor, {
      props: { viewModel: mockViewModel },
    });

    await wrapper.vm.$nextTick();

    expect(wrapper.find('.environmental-display').exists()).toBe(true);
  });

  it('displays alert badge when alerts exist', async () => {
    loadingSubject.next(false);
    alertsSubject.next([
      {
        id: 'alert-1',
        severity: 'critical',
        message: 'Temperature too high',
        timestamp: new Date(),
      },
    ]);

    const wrapper = mount(GreenhouseMonitor, {
      props: { viewModel: mockViewModel },
    });

    await wrapper.vm.$nextTick();

    expect(wrapper.find('.alert-badge').exists()).toBe(true);
    expect(wrapper.text()).toContain('1 Critical Alerts');
  });

  it('calls acknowledgeAlert when alert is acknowledged', async () => {
    loadingSubject.next(false);
    alertsSubject.next([
      {
        id: 'alert-1',
        severity: 'warning',
        message: 'Humidity low',
        timestamp: new Date(),
      },
    ]);

    const wrapper = mount(GreenhouseMonitor, {
      props: { viewModel: mockViewModel },
    });

    await wrapper.vm.$nextTick();

    // Find and click acknowledge button in AlertList
    const alertList = wrapper.findComponent({ name: 'AlertList' });
    alertList.vm.$emit('acknowledge', 'alert-1');

    expect(mockViewModel.acknowledgeAlert).toHaveBeenCalledWith('alert-1');
  });
});
```

This test structure should look familiar—it's nearly identical to our React tests from Chapter 12. We're testing the same behaviors:

- Component initialization and cleanup
- Observable-to-reactive-primitive conversion
- Event handler wiring
- Conditional rendering based on state

The syntax differs (Vue Test Utils vs React Testing Library), but the testing strategy is identical. That's because we're testing the same architectural pattern.

## What We've Proven

By implementing GreenWatch in both React and Vue, we've demonstrated several critical points:

**The ViewModel is genuinely framework-agnostic.** We didn't modify a single line of `GreenhouseViewModel` code. The same TypeScript class works perfectly in both frameworks because it depends only on RxJS observables, not framework-specific primitives.

**The domain layer is completely isolated.** Our `GreenhouseMonitoringService` and `AlertService` don't know or care which framework is consuming them. They expose domain operations through RxJS streams, and any framework can subscribe to those streams.

**The View layer is the only thing that changes.** React and Vue have different syntax, different reactivity systems, and different component models. That's fine—we expect the View layer to be framework-specific. What matters is that it's a thin adapter over framework-agnostic business logic.

**Testing remains consistent.** We test ViewModels the same way regardless of framework. We test components with framework-specific tools, but we're testing the same integration concerns: observable subscription, lifecycle management, and event handling.

**Team knowledge transfers.** A developer who understands the MVVM pattern in React can immediately understand it in Vue. The frameworks differ, but the architecture is the same. That's a huge win for maintainability and onboarding.

## The Bridge Pattern

The `useObservable` composable we built is an example of the **Bridge pattern**. We're connecting two incompatible interfaces—RxJS observables and Vue refs—without modifying either side.

This is important because it means we can adapt our architecture to any framework. Need to support Angular? Write a bridge that converts observables to Angular signals. Need to support Svelte? Write a bridge that converts observables to Svelte stores. The ViewModel never changes.

Here's what that pattern looks like generically:

```typescript
// ✅ Generic bridge pattern for any reactive system
interface ReactiveAdapter<TSource, TTarget> {
  convert(source: TSource, initialValue: any): TTarget;
  cleanup?(): void;
}

// Vue implementation
class VueReactiveAdapter implements ReactiveAdapter<Observable<any>, Ref<any>> {
  convert<T>(observable: Observable<T>, initialValue: T): Ref<T> {
    const value = ref<T>(initialValue) as Ref<T>;

    const subscription = observable.subscribe({
      next: (newValue) => (value.value = newValue),
      error: (error) => console.error('Observable error:', error),
    });

    onUnmounted(() => subscription.unsubscribe());

    return value;
  }
}

// React implementation
class ReactReactiveAdapter implements ReactiveAdapter<Observable<any>, any> {
  convert<T>(observable: Observable<T>, initialValue: T): T {
    const [value, setValue] = useState<T>(initialValue);

    useEffect(() => {
      const subscription = observable.subscribe({
        next: setValue,
        error: (error) => console.error('Observable error:', error),
      });

      return () => subscription.unsubscribe();
    }, [observable]);

    return value;
  }
}
```

This abstraction shows that the pattern we're using isn't specific to React or Vue—it's a general solution for connecting observables to any reactive UI framework.

## Performance Considerations

One concern developers raise about framework-agnostic architecture is performance. Does the extra abstraction layer—the ViewModel sitting between components and domain logic—introduce meaningful overhead?

In practice, no. The performance characteristics are excellent because:

**RxJS observables are highly optimized.** The library has been battle-tested in production applications at Google and elsewhere for years. Observable subscriptions have minimal overhead.

**We're not creating extra renders.** When the ViewModel emits a new value, the framework's reactive system handles it exactly as it would handle any other state change. There's no double-rendering or unnecessary updates.

**The architecture actually improves performance** by enabling better optimization strategies. Because ViewModels manage state centrally, we can implement debouncing, throttling, and caching at the ViewModel level, benefiting all Views that consume that ViewModel.

Here's an example of ViewModel-level optimization:

```typescript
// ✅ Optimize expensive operations at the ViewModel level
export class GreenhouseViewModel {
  readonly currentReadings$: Observable<EnvironmentalReading>;

  constructor(private readonly monitoringService: GreenhouseMonitoringService) {
    this.currentReadings$ = this.monitoringService.streamReadings(this.greenhouseId).pipe(
      // Throttle updates to once per second
      // This optimization benefits ALL views consuming this ViewModel
      throttleTime(1000),

      // Only emit when values actually change
      distinctUntilChanged(
        (prev, curr) =>
          prev.temperature === curr.temperature &&
          prev.humidity === curr.humidity &&
          prev.soilMoisture === curr.soilMoisture,
      ),

      // Share the subscription across multiple consumers
      shareReplay(1),
    );
  }
}
```

These optimizations happen once, in the ViewModel, and benefit every component in every framework that consumes this ViewModel. That's more maintainable than optimizing each component individually.

## Common Pitfalls

Let's address some mistakes developers make when implementing this pattern in Vue:

**Pitfall 1: Creating Vue-specific ViewModels**

```typescript
// ❌ Don't create framework-specific ViewModels
export class VueGreenhouseViewModel {
  temperature = ref(0);
  humidity = ref(0);

  // This defeats the entire purpose of framework independence
}
```

If you're creating separate ViewModels for each framework, you've misunderstood the architecture. The ViewModel should be framework-agnostic. Use adapters to bridge the gap, don't rewrite the ViewModel.

**Pitfall 2: Mixing reactive systems**

```typescript
// ❌ Don't mix RxJS and Vue reactivity in the ViewModel
export class GreenhouseViewModel {
  readonly temperature$ = new BehaviorSubject(0);
  readonly humidity = ref(0); // Wrong! Vue-specific primitive in ViewModel

  // This makes the ViewModel Vue-dependent
}
```

Keep the ViewModel purely RxJS-based. Use adapters in the View layer to convert to Vue refs.

**Pitfall 3: Forgetting cleanup**

```typescript
// ❌ Don't forget to unsubscribe from observables
<script setup>
const temperature = ref(0);

// This subscription will leak memory
props.viewModel.currentReadings$.subscribe(reading => {
  temperature.value = reading.temperature;
});
// No cleanup! The subscription never ends.
</script>
```

Always clean up subscriptions when components unmount. That's why we built `useObservable`—it handles cleanup automatically.

**Pitfall 4: Putting business logic in computed properties**

```typescript
// ❌ Don't put complex business logic in Vue computed properties
<script setup>
const isIrrigationNeeded = computed(() => {
  // Complex calculation involving multiple business rules
  const soilThreshold = getSoilThresholdForSeasonAndPlantType();
  const recentRainfall = calculateRecentRainfall();
  const weatherForecast = getWeatherForecast();

  return soilMoisture.value < soilThreshold &&
         recentRainfall < 10 &&
         !weatherForecast.willRain;
});
</script>
```

This logic belongs in the ViewModel or domain layer, where it can be properly tested and reused across frameworks. Computed properties should be simple derivations of ViewModel state, not complex business logic.

## When to Use Vue Over React

This book isn't advocating for one framework over another. Both React and Vue are excellent tools. The choice between them should be based on your team's preferences and project requirements, not architectural constraints.

However, there are situations where Vue's design makes certain patterns more natural:

**Vue excels at progressive enhancement.** If you're adding interactivity to an existing server-rendered application, Vue's template syntax integrates more smoothly with traditional HTML than React's JSX.

**Vue's reactivity system is more intuitive for developers new to reactive programming.** React's unidirectional data flow requires understanding when and why components re-render. Vue's reactivity is more transparent—you change a ref, the UI updates.

**Vue's Composition API is arguably cleaner for composing behavior.** The composable pattern feels more natural than React's hook composition for complex logic reuse.

But here's the key insight: with MVVM architecture, you're not locked into that decision. If you start with Vue and later decide React better serves your needs, or vice versa, you're only rewriting the View layer. Your business logic, your tests, your domain model—all of that stays intact.

That's the real value we're building here.

## Moving Forward

We've now implemented GreenWatch in both React and Vue, proving that our architecture delivers on its promise of framework independence. The same ViewModel, the same domain services, the same business logic—working perfectly in two different frameworks.

In the next chapter, we'll complete the framework trilogy by implementing GreenWatch in Angular. You'll see that Angular's dependency injection system and decorators create a different developer experience, but the underlying architecture remains identical.

Then, in Part 4, we'll tackle the full GreenWatch case study, expanding beyond simple monitoring to include irrigation control, multi-greenhouse management, user authentication, and real-time collaboration. We'll see how the architectural patterns we've established scale to production-level complexity.

But before we move on, take a moment to appreciate what we've built. We have a single codebase—one ViewModel, one set of domain services, one set of tests—that works across multiple frameworks. That's not just architecturally elegant. It's practically powerful.
