---
id: "dependency-injection-and-service-architecture"
title: Vue Implementation — Proving Framework Independence
section: Framework-Agnostic Core
---

# Chapter 9: Vue Implementation — Proving Framework Independence

We've spent the last chapter implementing our GreenWatch greenhouse monitoring system in React. Now it's time to prove our architecture's framework-agnostic promise. If we've done this right, moving to Vue should feel less like a rewrite and more like swapping out a presentation layer while keeping our entire business logic intact.

This isn't just an academic exercise. In the real world, frameworks fall in and out of favor. Teams inherit codebases built with different technologies. Organizations acquire companies using competing stacks. If your architecture locks you into a single framework, you're not building software—you're building technical debt.

Let's validate our approach by implementing the same GreenWatch features in Vue, reusing every line of domain logic we wrote in Chapter 8.

## The Framework-Agnostic Promise

Before we dive into Vue-specific patterns, let's be explicit about what we're claiming. When we say our ViewModels are framework-agnostic, we mean:

**✅ The same ViewModel class works in React, Vue, and Angular**

```typescript
// This EXACT class will be used in all three frameworks
export class GreenhouseMonitorViewModel {
  private readonly _temperatureSubject =
    new BehaviorSubject<Temperature | null>(null);
  private readonly _humiditySubject = new BehaviorSubject<Humidity | null>(
    null
  );
  private readonly _subscriptions = new Subscription();

  readonly temperature$ = this._temperatureSubject.asObservable();
  readonly humidity$ = this._humiditySubject.asObservable();

  constructor(
    private readonly sensorService: ISensorDataService,
    private readonly greenhouseId: string
  ) {}

  initialize(): void {
    // Business logic here - no framework code
  }

  dispose(): void {
    this._subscriptions.unsubscribe();
  }
}
```

**✅ Our domain services remain completely untouched**

```typescript
// Zero changes needed for Vue
export class SensorDataService implements ISensorDataService {
  streamSensorData(deviceId: string): Observable<SensorReading> {
    return this.webSocketService.connect(`/sensors/${deviceId}`).pipe(
      map((data) => this.mapToSensorReading(data)),
      catchError((error) => this.handleStreamError(error))
    );
  }
}
```

**✅ Our entire domain layer moves without modification**

The `GreenhouseAggregate`, `Device` entity, `Temperature` and `Humidity` value objects, domain events—none of this changes. We're not abstracting away differences between frameworks. We're proving that when you separate concerns properly, framework choice becomes a detail.

This isn't magic. It's the result of disciplined layering. Our ViewModels expose state through RxJS observables, which every modern framework can consume. Our domain logic doesn't know what a component is. Our services are injected, not imported statically.

Let's see this principle in action.

## Vue's Composition API: A Natural Fit for MVVM

Vue 3's Composition API feels like it was designed with MVVM in mind. Unlike Vue 2's Options API, which encouraged mixing concerns inside component definitions, the Composition API gives us the primitives we need for clean separation.

Here's how Vue's reactive system maps to our ViewModel pattern:

```typescript
// Vue composable that wraps our ViewModel
import { ref, onMounted, onUnmounted, Ref } from "vue";
import { Subscription } from "rxjs";

export function useGreenhouseMonitor(viewModel: GreenhouseMonitorViewModel): {
  temperature: Ref<Temperature | null>;
  humidity: Ref<Humidity | null>;
  isLoading: Ref<boolean>;
} {
  // Vue reactive refs - NOT ViewModel state
  const temperature = ref<Temperature | null>(null);
  const humidity = ref<Temperature | null>(null);
  const isLoading = ref(true);

  const subscription = new Subscription();

  onMounted(() => {
    viewModel.initialize();

    // Subscribe to ViewModel observables, update Vue refs
    subscription.add(
      viewModel.temperature$.subscribe((temp) => {
        temperature.value = temp;
      })
    );

    subscription.add(
      viewModel.humidity$.subscribe((hum) => {
        humidity.value = hum;
      })
    );

    subscription.add(
      viewModel.isLoading$.subscribe((loading) => {
        isLoading.value = loading;
      })
    );
  });

  onUnmounted(() => {
    subscription.unsubscribe();
    viewModel.dispose();
  });

  return {
    temperature,
    humidity,
    isLoading,
  };
}
```

What's happening here? We're creating a **composable**—Vue's reusable logic pattern—that bridges between our ViewModel's observable streams and Vue's reactivity system. The ViewModel doesn't know it's being used by Vue. The Vue component doesn't know where the data comes from beyond "this composable provides it."

This is the seam between layers. The ViewModel publishes state changes through observables. The composable translates those observables into Vue refs. The component consumes refs through Vue's template syntax.

Let's compare this to what we did in React:

**React approach:**

```typescript
function useGreenhouseMonitor(viewModel: GreenhouseMonitorViewModel) {
  const [temperature, setTemperature] = useState<Temperature | null>(null);
  const [humidity, setHumidity] = useState<Humidity | null>(null);

  useEffect(() => {
    viewModel.initialize();

    const subscription = new Subscription();
    subscription.add(viewModel.temperature$.subscribe(setTemperature));
    // ...

    return () => {
      subscription.unsubscribe();
      viewModel.dispose();
    };
  }, [viewModel]);

  return { temperature, humidity };
}
```

**Vue approach:**

```typescript
export function useGreenhouseMonitor(viewModel: GreenhouseMonitorViewModel) {
  const temperature = ref<Temperature | null>(null);
  const humidity = ref<Humidity | null>(null);

  onMounted(() => {
    viewModel.initialize();
    subscription.add(
      viewModel.temperature$.subscribe((temp) => {
        temperature.value = temp;
      })
    );
    // ...
  });

  onUnmounted(() => {
    subscription.unsubscribe();
    viewModel.dispose();
  });

  return { temperature, humidity };
}
```

Notice the structural similarity? Both versions:

1. Initialize the ViewModel in their mounting lifecycle
2. Subscribe to observable streams
3. Update framework-specific reactive state
4. Clean up subscriptions on unmount
5. Return state to the component

The only differences are framework-specific APIs (`useState` vs `ref`, `useEffect` vs `onMounted/onUnmounted`). The pattern—the **shape** of the integration—is identical. This consistency isn't accidental. It emerges from proper architectural separation.

## Implementing the Greenhouse Monitor Component in Vue

Now let's build the actual Vue component that uses our composable. We'll implement the same environmental monitoring view we built in React, proving that our ViewModel handles all the complexity while the view remains thin.

```vue
<!-- GreenhouseMonitor.vue -->
<template>
  <div class="greenhouse-monitor">
    <div v-if="isLoading" class="loading-state">
      <LoadingSpinner />
      <p>Connecting to sensors...</p>
    </div>

    <div v-else-if="error" class="error-state">
      <ErrorIcon />
      <p>{{ error.message }}</p>
      <button @click="handleRetry">Retry Connection</button>
    </div>

    <div v-else class="monitoring-grid">
      <!-- Temperature Card -->
      <div class="metric-card" :class="temperatureStatusClass">
        <div class="metric-header">
          <ThermometerIcon />
          <h3>Temperature</h3>
        </div>
        <div class="metric-value">
          {{ formatTemperature(temperature) }}
        </div>
        <div v-if="temperatureStatus" class="metric-status">
          {{ temperatureStatus }}
        </div>
      </div>

      <!-- Humidity Card -->
      <div class="metric-card" :class="humidityStatusClass">
        <div class="metric-header">
          <DropletIcon />
          <h3>Humidity</h3>
        </div>
        <div class="metric-value">
          {{ formatHumidity(humidity) }}
        </div>
        <div v-if="humidityStatus" class="metric-status">
          {{ humidityStatus }}
        </div>
      </div>

      <!-- Soil Moisture Card -->
      <div class="metric-card" :class="soilMoistureStatusClass">
        <div class="metric-header">
          <SeedlingIcon />
          <h3>Soil Moisture</h3>
        </div>
        <div class="metric-value">
          {{ formatSoilMoisture(soilMoisture) }}
        </div>
        <div v-if="soilMoistureStatus" class="metric-status">
          {{ soilMoistureStatus }}
        </div>
      </div>

      <!-- Light Level Card -->
      <div class="metric-card">
        <div class="metric-header">
          <SunIcon />
          <h3>Light Level</h3>
        </div>
        <div class="metric-value">
          {{ formatLightLevel(lightLevel) }}
        </div>
      </div>
    </div>

    <!-- Recent Alerts -->
    <div v-if="recentAlerts.length > 0" class="alerts-section">
      <h3>Recent Alerts</h3>
      <div class="alerts-list">
        <div
          v-for="alert in recentAlerts"
          :key="alert.id"
          class="alert-item"
          :class="`alert-${alert.severity}`"
        >
          <AlertIcon :severity="alert.severity" />
          <div class="alert-content">
            <p class="alert-message">{{ alert.message }}</p>
            <time class="alert-time">{{
              formatTimestamp(alert.timestamp)
            }}</time>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from "vue";
import { useGreenhouseMonitor } from "@/composables/useGreenhouseMonitor";
import { GreenhouseMonitorViewModel } from "@/viewmodels/GreenhouseMonitorViewModel";
import { inject } from "vue";

// Dependency injection - we'll cover this in detail shortly
const viewModel = inject<GreenhouseMonitorViewModel>(
  "greenhouseMonitorViewModel"
)!;

// Use our composable to connect to the ViewModel
const {
  temperature,
  humidity,
  soilMoisture,
  lightLevel,
  recentAlerts,
  isLoading,
  error,
} = useGreenhouseMonitor(viewModel);

// Computed properties for derived state
const temperatureStatusClass = computed(() => {
  if (!temperature.value) return "";
  if (temperature.value.isAboveThreshold(30)) return "status-danger";
  if (temperature.value.isAboveThreshold(25)) return "status-warning";
  return "status-normal";
});

const temperatureStatus = computed(() => {
  if (!temperature.value) return null;
  if (temperature.value.isAboveThreshold(30)) return "Too Hot";
  if (temperature.value.isAboveThreshold(25)) return "Warm";
  if (temperature.value.isBelowThreshold(15)) return "Cold";
  return "Optimal";
});

const humidityStatusClass = computed(() => {
  if (!humidity.value) return "";
  if (humidity.value.isAboveThreshold(80)) return "status-danger";
  if (humidity.value.isAboveThreshold(70)) return "status-warning";
  if (humidity.value.isBelowThreshold(40)) return "status-warning";
  return "status-normal";
});

const humidityStatus = computed(() => {
  if (!humidity.value) return null;
  if (humidity.value.isAboveThreshold(80)) return "Too Humid";
  if (humidity.value.isAboveThreshold(70)) return "High";
  if (humidity.value.isBelowThreshold(40)) return "Low";
  return "Optimal";
});

const soilMoistureStatusClass = computed(() => {
  if (!soilMoisture.value) return "";
  if (soilMoisture.value.isBelowThreshold(30)) return "status-danger";
  if (soilMoisture.value.isBelowThreshold(45)) return "status-warning";
  return "status-normal";
});

const soilMoistureStatus = computed(() => {
  if (!soilMoisture.value) return null;
  if (soilMoisture.value.isBelowThreshold(30))
    return "Critical - Irrigation Needed";
  if (soilMoisture.value.isBelowThreshold(45)) return "Low";
  if (soilMoisture.value.isAboveThreshold(75)) return "Saturated";
  return "Optimal";
});

// Presentation logic - formatting for display
function formatTemperature(temp: Temperature | null): string {
  if (!temp) return "--";
  return `${temp.celsius.toFixed(1)}°C`;
}

function formatHumidity(hum: Humidity | null): string {
  if (!hum) return "--";
  return `${hum.percentage.toFixed(0)}%`;
}

function formatSoilMoisture(moisture: SoilMoisture | null): string {
  if (!moisture) return "--";
  return `${moisture.percentage.toFixed(0)}%`;
}

function formatLightLevel(light: LightLevel | null): string {
  if (!light) return "--";
  return `${light.lux.toFixed(0)} lux`;
}

function formatTimestamp(timestamp: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - timestamp.getTime();
  const diffMins = Math.floor(diffMs / 60000);

  if (diffMins < 1) return "Just now";
  if (diffMins < 60) return `${diffMins}m ago`;

  const diffHours = Math.floor(diffMins / 60);
  if (diffHours < 24) return `${diffHours}h ago`;

  return timestamp.toLocaleDateString();
}

function handleRetry(): void {
  viewModel.retryConnection();
}
</script>

<style scoped>
.greenhouse-monitor {
  padding: 24px;
  max-width: 1200px;
  margin: 0 auto;
}

.loading-state,
.error-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  gap: 16px;
}

.monitoring-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 24px;
  margin-bottom: 32px;
}

.metric-card {
  background: white;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: box-shadow 0.2s;
}

.metric-card:hover {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}

.metric-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}

.metric-value {
  font-size: 2.5rem;
  font-weight: 600;
  color: #1a1a1a;
  margin-bottom: 8px;
}

.metric-status {
  font-size: 0.875rem;
  font-weight: 500;
  padding: 4px 12px;
  border-radius: 16px;
  display: inline-block;
}

.status-normal {
  border-left: 4px solid #10b981;
}

.status-normal .metric-status {
  background: #d1fae5;
  color: #065f46;
}

.status-warning {
  border-left: 4px solid #f59e0b;
}

.status-warning .metric-status {
  background: #fef3c7;
  color: #92400e;
}

.status-danger {
  border-left: 4px solid #ef4444;
}

.status-danger .metric-status {
  background: #fee2e2;
  color: #991b1b;
}

.alerts-section {
  background: white;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.alerts-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 16px;
}

.alert-item {
  display: flex;
  gap: 12px;
  padding: 16px;
  border-radius: 8px;
  border-left: 4px solid;
}

.alert-warning {
  background: #fffbeb;
  border-left-color: #f59e0b;
}

.alert-critical {
  background: #fef2f2;
  border-left-color: #ef4444;
}

.alert-content {
  flex: 1;
}

.alert-message {
  font-weight: 500;
  margin-bottom: 4px;
}

.alert-time {
  font-size: 0.875rem;
  color: #6b7280;
}
</style>
```

Look at what this component **doesn't** contain:

- No WebSocket connection logic
- No state management beyond Vue reactivity
- No business rules about what temperature is "too hot"
- No retry logic for failed connections
- No data transformation from sensor readings

All of that lives in the ViewModel. The component's responsibilities are purely presentational:

1. Arrange UI elements
2. Format values for display
3. Apply visual styling based on state
4. Handle user interactions by delegating to the ViewModel

This is exactly what we want. The component is easy to reason about, easy to style, and easy to replace if design requirements change. When we need to update the temperature threshold logic, we modify the `Temperature` value object, not this component.

## Vue's Dependency Injection: Providing ViewModels

You noticed the `inject` call in our component. Vue has a built-in dependency injection system that's perfect for providing ViewModels to component trees. Let's wire this up properly.

In React, we used Context to provide dependencies. Vue's `provide/inject` serves the same architectural purpose with slightly different syntax:

```typescript
// main.ts - Application bootstrap
import { createApp } from "vue";
import App from "./App.vue";
import { bootstrapContainer } from "./infrastructure/di/container";

const app = createApp(App);

// Bootstrap our DI container (same container we'd use for React or Angular)
const container = bootstrapContainer();

// Provide dependencies at the app level
app.provide(
  "sensorDataService",
  container.get<ISensorDataService>("ISensorDataService")
);
app.provide(
  "irrigationService",
  container.get<IIrrigationService>("IIrrigationService")
);
app.provide("alertService", container.get<IAlertService>("IAlertService"));

app.mount("#app");
```

Now, for components that need ViewModels, we create them with injected dependencies:

```vue
<!-- GreenhouseMonitor.vue setup -->
<script setup lang="ts">
import { inject, onBeforeUnmount } from "vue";
import { GreenhouseMonitorViewModel } from "@/viewmodels/GreenhouseMonitorViewModel";
import type { ISensorDataService } from "@/domain/services/ISensorDataService";

// Inject service dependencies
const sensorDataService = inject<ISensorDataService>("sensorDataService")!;

// Component receives greenhouseId as a prop
const props = defineProps<{
  greenhouseId: string;
}>();

// Create ViewModel instance with injected dependencies
const viewModel = new GreenhouseMonitorViewModel(
  sensorDataService,
  props.greenhouseId
);

// Use our composable
const { temperature, humidity, isLoading, error } =
  useGreenhouseMonitor(viewModel);

// Clean up when component unmounts
onBeforeUnmount(() => {
  viewModel.dispose();
});
</script>
```

This pattern gives us several benefits:

**Testability:** We can provide mock services when testing components, just like we did in React.

**Flexibility:** Different parts of the app can use different service implementations (e.g., mock data in development, real API in production).

**Explicitness:** Dependencies are declared at the top of the component, making it obvious what external services are needed.

For larger applications, you might create a dedicated composable for ViewModel creation:

```typescript
// composables/useViewModel.ts
import { inject, onBeforeUnmount } from "vue";
import type { ISensorDataService } from "@/domain/services/ISensorDataService";

export function useGreenhouseMonitorViewModel(greenhouseId: string) {
  const sensorDataService = inject<ISensorDataService>("sensorDataService")!;

  const viewModel = new GreenhouseMonitorViewModel(
    sensorDataService,
    greenhouseId
  );

  onBeforeUnmount(() => {
    viewModel.dispose();
  });

  return viewModel;
}
```

Then your component becomes even simpler:

```vue
<script setup lang="ts">
import { useGreenhouseMonitorViewModel } from "@/composables/useGreenhouseMonitorViewModel";
import { useGreenhouseMonitor } from "@/composables/useGreenhouseMonitor";

const props = defineProps<{ greenhouseId: string }>();

const viewModel = useGreenhouseMonitorViewModel(props.greenhouseId);
const state = useGreenhouseMonitor(viewModel);
</script>
```

The component no longer needs to know about service injection or ViewModel lifecycle—that's handled by composables. This is composition at work, and it's why Vue's Composition API aligns so naturally with MVVM.

## Handling Forms: Irrigation Control in Vue

Environmental monitoring is half the story. Now let's implement the irrigation control form we built in React, proving that our `IrrigationControlViewModel` works identically in Vue.

Remember, this ViewModel handles:

- Form validation (duration must be positive, schedule must be valid)
- Domain rule enforcement (can't irrigate during certain conditions)
- API communication through the irrigation service
- Error handling and loading states

None of that changes. Here's the Vue component:

```vue
<!-- IrrigationControl.vue -->
<template>
  <div class="irrigation-control">
    <div class="control-header">
      <h2>Irrigation Control</h2>
      <div
        v-if="systemStatus"
        class="system-status"
        :class="`status-${systemStatus.state}`"
      >
        <StatusIcon :state="systemStatus.state" />
        <span>{{ systemStatus.message }}</span>
      </div>
    </div>

    <form @submit.prevent="handleSubmit" class="control-form">
      <!-- Manual Irrigation Section -->
      <div class="form-section">
        <h3>Manual Irrigation</h3>

        <div class="form-group">
          <label for="duration">Duration (minutes)</label>
          <input
            id="duration"
            type="number"
            :value="duration"
            @input="handleDurationChange"
            :disabled="isSubmitting"
            min="1"
            max="120"
            class="form-input"
            :class="{ 'input-error': durationError }"
          />
          <span v-if="durationError" class="error-message">
            {{ durationError }}
          </span>
        </div>

        <div class="form-group">
          <label for="zone">Irrigation Zone</label>
          <select
            id="zone"
            :value="selectedZone"
            @change="handleZoneChange"
            :disabled="isSubmitting"
            class="form-select"
          >
            <option value="">Select a zone...</option>
            <option
              v-for="zone in availableZones"
              :key="zone.id"
              :value="zone.id"
            >
              {{ zone.name }} ({{ zone.plantType }})
            </option>
          </select>
          <span v-if="zoneError" class="error-message">
            {{ zoneError }}
          </span>
        </div>

        <div class="environmental-check">
          <div v-if="currentConditions" class="conditions-summary">
            <div class="condition-item">
              <ThermometerIcon />
              <span>{{ currentConditions.temperature }}°C</span>
            </div>
            <div class="condition-item">
              <DropletIcon />
              <span>{{ currentConditions.humidity }}%</span>
            </div>
            <div class="condition-item">
              <SunIcon />
              <span>{{ currentConditions.lightLevel }} lux</span>
            </div>
          </div>

          <div v-if="irrigationWarning" class="warning-banner">
            <AlertTriangleIcon />
            <p>{{ irrigationWarning }}</p>
          </div>
        </div>

        <button
          type="submit"
          :disabled="!canSubmit"
          class="submit-button"
          :class="{ 'button-loading': isSubmitting }"
        >
          <LoadingSpinner v-if="isSubmitting" />
          <span v-else>Start Irrigation</span>
        </button>

        <div v-if="submitError" class="error-banner">
          <AlertIcon />
          <p>{{ submitError }}</p>
        </div>

        <div v-if="submitSuccess" class="success-banner">
          <CheckIcon />
          <p>{{ submitSuccess }}</p>
        </div>
      </div>

      <!-- Scheduled Irrigation Section -->
      <div class="form-section">
        <h3>Scheduled Irrigation</h3>

        <div class="schedule-list">
          <div
            v-for="schedule in activeSchedules"
            :key="schedule.id"
            class="schedule-item"
          >
            <div class="schedule-info">
              <strong>{{ schedule.zoneName }}</strong>
              <span class="schedule-time">
                {{ formatScheduleTime(schedule.time) }} -
                {{ schedule.duration }}min
              </span>
              <span
                v-if="schedule.frequency !== 'once'"
                class="schedule-frequency"
              >
                Repeats {{ schedule.frequency }}
              </span>
            </div>
            <button
              type="button"
              @click="handleCancelSchedule(schedule.id)"
              class="cancel-button"
              :disabled="isSubmitting"
            >
              Cancel
            </button>
          </div>
        </div>

        <button
          type="button"
          @click="handleAddSchedule"
          class="add-schedule-button"
        >
          <PlusIcon />
          Add Schedule
        </button>
      </div>
    </form>
  </div>
</template>

<script setup lang="ts">
import { inject } from "vue";
import { useIrrigationControl } from "@/composables/useIrrigationControl";
import { IrrigationControlViewModel } from "@/viewmodels/IrrigationControlViewModel";

const props = defineProps<{
  greenhouseId: string;
}>();

// Inject the ViewModel (provided at a higher level)
const viewModel = inject<IrrigationControlViewModel>(
  "irrigationControlViewModel"
)!;

// Use our composable to bridge ViewModel observables to Vue refs
const {
  duration,
  selectedZone,
  availableZones,
  durationError,
  zoneError,
  isSubmitting,
  canSubmit,
  currentConditions,
  irrigationWarning,
  submitError,
  submitSuccess,
  systemStatus,
  activeSchedules,
} = useIrrigationControl(viewModel);

// Event handlers - delegate to ViewModel
function handleDurationChange(event: Event): void {
  const input = event.target as HTMLInputElement;
  viewModel.setDuration(parseInt(input.value, 10));
}

function handleZoneChange(event: Event): void {
  const select = event.target as HTMLSelectElement;
  viewModel.setZone(select.value);
}

function handleSubmit(): void {
  viewModel.submitManualIrrigation();
}

function handleCancelSchedule(scheduleId: string): void {
  viewModel.cancelSchedule(scheduleId);
}

function handleAddSchedule(): void {
  // Open schedule creation modal (state managed by ViewModel)
  viewModel.openScheduleModal();
}

function formatScheduleTime(time: string): string {
  // Format time string for display
  return new Date(`2000-01-01T${time}`).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    hour12: true,
  });
}
</script>

<style scoped>
/* Styles omitted for brevity - same visual design as React version */
</style>
```

And here's the composable that connects this component to the ViewModel:

```typescript
// composables/useIrrigationControl.ts
import { ref, onMounted, onUnmounted, Ref } from "vue";
import { Subscription } from "rxjs";
import type { IrrigationControlViewModel } from "@/viewmodels/IrrigationControlViewModel";
import type {
  IrrigationZone,
  EnvironmentalConditions,
  SystemStatus,
  IrrigationSchedule,
} from "@/domain/models";

export function useIrrigationControl(viewModel: IrrigationControlViewModel) {
  // Form state
  const duration = ref<number>(30);
  const selectedZone = ref<string>("");
  const availableZones = ref<IrrigationZone[]>([]);

  // Validation state
  const durationError = ref<string | null>(null);
  const zoneError = ref<string | null>(null);

  // Submission state
  const isSubmitting = ref(false);
  const canSubmit = ref(false);
  const submitError = ref<string | null>(null);
  const submitSuccess = ref<string | null>(null);

  // Environmental state
  const currentConditions = ref<EnvironmentalConditions | null>(null);
  const irrigationWarning = ref<string | null>(null);

  // System state
  const systemStatus = ref<SystemStatus | null>(null);
  const activeSchedules = ref<IrrigationSchedule[]>([]);

  const subscription = new Subscription();

  onMounted(() => {
    viewModel.initialize();

    // Subscribe to all ViewModel observables
    subscription.add(
      viewModel.duration$.subscribe((val) => {
        duration.value = val;
      })
    );

    subscription.add(
      viewModel.selectedZone$.subscribe((val) => {
        selectedZone.value = val;
      })
    );

    subscription.add(
      viewModel.availableZones$.subscribe((zones) => {
        availableZones.value = zones;
      })
    );

    subscription.add(
      viewModel.durationError$.subscribe((error) => {
        durationError.value = error;
      })
    );

    subscription.add(
      viewModel.zoneError$.subscribe((error) => {
        zoneError.value = error;
      })
    );

    subscription.add(
      viewModel.isSubmitting$.subscribe((val) => {
        isSubmitting.value = val;
      })
    );

    subscription.add(
      viewModel.canSubmit$.subscribe((val) => {
        canSubmit.value = val;
      })
    );

    subscription.add(
      viewModel.submitError$.subscribe((error) => {
        submitError.value = error;
      })
    );

    subscription.add(
      viewModel.submitSuccess$.subscribe((msg) => {
        submitSuccess.value = msg;
      })
    );

    subscription.add(
      viewModel.currentConditions$.subscribe((conditions) => {
        currentConditions.value = conditions;
      })
    );

    subscription.add(
      viewModel.irrigationWarning$.subscribe((warning) => {
        irrigationWarning.value = warning;
      })
    );

    subscription.add(
      viewModel.systemStatus$.subscribe((status) => {
        systemStatus.value = status;
      })
    );

    subscription.add(
      viewModel.activeSchedules$.subscribe((schedules) => {
        activeSchedules.value = schedules;
      })
    );
  });

  onUnmounted(() => {
    subscription.unsubscribe();
    viewModel.dispose();
  });

  return {
    duration,
    selectedZone,
    availableZones,
    durationError,
    zoneError,
    isSubmitting,
    canSubmit,
    submitError,
    submitSuccess,
    currentConditions,
    irrigationWarning,
    systemStatus,
    activeSchedules,
  };
}
```

Compare this implementation to the React version from Chapter 8. The structure is virtually identical:

**React:**

```typescript
function useIrrigationControl(viewModel: IrrigationControlViewModel) {
  const [duration, setDuration] = useState<number>(30);
  const [selectedZone, setSelectedZone] = useState<string>("");
  // ... more state

  useEffect(() => {
    viewModel.initialize();
    const subscription = new Subscription();
    subscription.add(viewModel.duration$.subscribe(setDuration));
    // ... more subscriptions
    return () => {
      subscription.unsubscribe();
      viewModel.dispose();
    };
  }, [viewModel]);

  return { duration, selectedZone /* ... */ };
}
```

**Vue:**

```typescript
export function useIrrigationControl(viewModel: IrrigationControlViewModel) {
  const duration = ref<number>(30);
  const selectedZone = ref<string>("");
  // ... more refs

  onMounted(() => {
    viewModel.initialize();
    subscription.add(
      viewModel.duration$.subscribe((val) => {
        duration.value = val;
      })
    );
    // ... more subscriptions
  });

  onUnmounted(() => {
    subscription.unsubscribe();
    viewModel.dispose();
  });

  return { duration, selectedZone /* ... */ };
}
```

We haven't changed a single line of business logic. The form validation rules, the environmental safety checks, the scheduling logic—all of that lives in `IrrigationControlViewModel`, completely unaware that it's being used by Vue instead of React.

This is the payoff for disciplined architecture. When frameworks change or when you need to support multiple platforms, you're not rewriting your application. You're adapting a thin presentation layer while your tested, validated business logic remains stable.

## Vue Reactivity Deep Dive: Refs, Reactive, and Observable Subscriptions

Vue's reactivity system is powerful, but it can create subtle issues when bridging to RxJS observables. Let's make sure we're using it correctly.

### Understanding Vue Refs vs Reactive Objects

Vue offers two primary reactivity primitives: `ref()` and `reactive()`. Understanding when to use each is crucial for clean ViewModel integration.

**Use `ref()` for primitive values and when you need reassignment:**

```typescript
// ✅ Good - ref for primitives
const temperature = ref<number | null>(null);
const isLoading = ref<boolean>(true);
const errorMessage = ref<string | null>(null);

// Later, update by reassigning .value
temperature.value = 24.5;
isLoading.value = false;
```

**Use `reactive()` for objects you'll mutate in place:**

```typescript
// ✅ Good - reactive for complex objects you'll mutate
const formData = reactive({
  duration: 30,
  zone: "",
  scheduledTime: null as Date | null,
});

// Later, mutate properties directly
formData.duration = 45;
formData.zone = "zone-north";
```

For ViewModel integration, **refs are typically the better choice** because:

1. **Explicit reactivity boundary:** The `.value` syntax makes it clear you're dealing with reactive state
2. **Better TypeScript support:** Refs work more predictably with TypeScript inference
3. **Reassignment semantics:** RxJS observables emit new values, which maps naturally to `ref.value = newValue`

Here's why `reactive()` can cause problems with observable subscriptions:

```typescript
// ❌ Problematic - losing reactivity
const state = reactive({
  temperature: null as Temperature | null,
  humidity: null as Humidity | null,
});

viewModel.temperature$.subscribe((temp) => {
  // This assignment breaks reactivity!
  state.temperature = temp;
});

// Better approach - use refs
const temperature = ref<Temperature | null>(null);
const humidity = ref<Humidity | null>(null);

viewModel.temperature$.subscribe((temp) => {
  temperature.value = temp; // Reactivity preserved
});
```

When you assign to a reactive object property, Vue's reactivity tracking can miss the change if the property wasn't initially reactive. Refs avoid this issue by making the reactivity boundary explicit.

### Handling Computed State from Observables

Often, your ViewModel exposes derived state through observables. Vue's `computed()` works naturally with refs:

```typescript
// ViewModel exposes validation state
viewModel.isFormValid$ = combineLatest([
  viewModel.duration$,
  viewModel.selectedZone$,
  viewModel.durationError$,
  viewModel.zoneError$,
]).pipe(
  map(
    ([duration, zone, durationErr, zoneErr]) =>
      duration > 0 && zone !== "" && !durationErr && !zoneErr
  )
);

// In your composable, subscribe to the derived observable
const isFormValid = ref(false);

subscription.add(
  viewModel.isFormValid$.subscribe((valid) => {
    isFormValid.value = valid;
  })
);

// Now you can use Vue's computed for view-specific derivations
const submitButtonText = computed(() => {
  if (isSubmitting.value) return "Irrigating...";
  if (!isFormValid.value) return "Complete Form";
  return "Start Irrigation";
});
```

This pattern maintains clear separation:

- **ViewModel computes domain-related derived state** (is the form valid per business rules?)
- **Vue computed handles presentation-specific derived state** (what text should the button show?)

Don't try to replace ViewModel observables with Vue computed properties. The ViewModel needs to remain framework-agnostic, which means it can't depend on Vue's reactivity system.

### Memory Management: When to Unsubscribe

Every RxJS subscription allocates memory. Vue components get destroyed and recreated frequently (navigation, conditional rendering, etc.). If you don't unsubscribe, you'll leak memory.

Here's the correct cleanup pattern:

```typescript
export function useGreenhouseMonitor(viewModel: GreenhouseMonitorViewModel) {
  const temperature = ref<Temperature | null>(null);
  const subscription = new Subscription(); // Single subscription container

  onMounted(() => {
    viewModel.initialize();

    // Add all subscriptions to the container
    subscription.add(
      viewModel.temperature$.subscribe((temp) => {
        temperature.value = temp;
      })
    );

    subscription.add(
      viewModel.humidity$.subscribe((hum) => {
        humidity.value = hum;
      })
    );
  });

  onUnmounted(() => {
    // Unsubscribe from ALL observables at once
    subscription.unsubscribe();

    // Clean up ViewModel resources
    viewModel.dispose();
  });

  return { temperature, humidity };
}
```

The `Subscription` container pattern is critical. Each call to `subscription.add()` registers a new observable subscription. When you call `subscription.unsubscribe()`, all registered subscriptions terminate simultaneously. This prevents memory leaks and ensures clean component unmounting.

**Common mistake:**

```typescript
// ❌ Don't do this - no cleanup
onMounted(() => {
  viewModel.temperature$.subscribe((temp) => {
    temperature.value = temp;
  });
});

// No onUnmounted = memory leak
```

Without cleanup, the observable subscription continues even after the component unmounts. The subscription holds a reference to the component's scope (the `temperature` ref), preventing garbage collection. In a long-running application, this accumulates into significant memory leaks.

## Testing Vue Components with ViewModels

Testing Vue components that use ViewModels follows the same principles we established for React: test the component's view logic independently from business logic.

Here's how we test the `GreenhouseMonitor` component using Vue Test Utils:

```typescript
// GreenhouseMonitor.spec.ts
import { describe, it, expect, beforeEach, vi } from "vitest";
import { mount, VueWrapper } from "@vue/test-utils";
import { BehaviorSubject } from "rxjs";
import GreenhouseMonitor from "@/components/GreenhouseMonitor.vue";
import { GreenhouseMonitorViewModel } from "@/viewmodels/GreenhouseMonitorViewModel";
import {
  Temperature,
  Humidity,
  SoilMoisture,
  LightLevel,
} from "@/domain/value-objects";

describe("GreenhouseMonitor Component", () => {
  let wrapper: VueWrapper;
  let mockViewModel: GreenhouseMonitorViewModel;

  // Test doubles - behavior subjects we control
  let temperatureSubject: BehaviorSubject<Temperature | null>;
  let humiditySubject: BehaviorSubject<Humidity | null>;
  let soilMoistureSubject: BehaviorSubject<SoilMoisture | null>;
  let isLoadingSubject: BehaviorSubject<boolean>;

  beforeEach(() => {
    // Create behavior subjects for each observable
    temperatureSubject = new BehaviorSubject<Temperature | null>(null);
    humiditySubject = new BehaviorSubject<Humidity | null>(null);
    soilMoistureSubject = new BehaviorSubject<SoilMoisture | null>(null);
    isLoadingSubject = new BehaviorSubject<boolean>(true);

    // Create mock ViewModel with our controlled observables
    mockViewModel = {
      temperature$: temperatureSubject.asObservable(),
      humidity$: humiditySubject.asObservable(),
      soilMoisture$: soilMoistureSubject.asObservable(),
      isLoading$: isLoadingSubject.asObservable(),
      initialize: vi.fn(),
      dispose: vi.fn(),
    } as unknown as GreenhouseMonitorViewModel;

    // Mount component with mock ViewModel
    wrapper = mount(GreenhouseMonitor, {
      global: {
        provide: {
          greenhouseMonitorViewModel: mockViewModel,
        },
      },
    });
  });

  it("shows loading state initially", () => {
    expect(wrapper.find(".loading-state").exists()).toBe(true);
    expect(wrapper.find(".monitoring-grid").exists()).toBe(false);
  });

  it("displays temperature when loaded", async () => {
    // Emit loading complete
    isLoadingSubject.next(false);

    // Emit temperature data
    const temp = Temperature.fromCelsius(24.5);
    temperatureSubject.next(temp);

    // Wait for Vue to update DOM
    await wrapper.vm.$nextTick();

    const tempCard = wrapper.find(".metric-card").element;
    expect(tempCard.textContent).toContain("24.5°C");
  });

  it("applies correct status class for high temperature", async () => {
    isLoadingSubject.next(false);

    const highTemp = Temperature.fromCelsius(32);
    temperatureSubject.next(highTemp);

    await wrapper.vm.$nextTick();

    const tempCard = wrapper.findAll(".metric-card")[0];
    expect(tempCard.classes()).toContain("status-danger");
    expect(tempCard.text()).toContain("Too Hot");
  });

  it("applies correct status class for optimal temperature", async () => {
    isLoadingSubject.next(false);

    const optimalTemp = Temperature.fromCelsius(22);
    temperatureSubject.next(optimalTemp);

    await wrapper.vm.$nextTick();

    const tempCard = wrapper.findAll(".metric-card")[0];
    expect(tempCard.classes()).toContain("status-normal");
    expect(tempCard.text()).toContain("Optimal");
  });

  it("formats humidity correctly", async () => {
    isLoadingSubject.next(false);

    const humidity = Humidity.fromPercentage(65.7);
    humiditySubject.next(humidity);

    await wrapper.vm.$nextTick();

    const humidityCard = wrapper.findAll(".metric-card")[1];
    expect(humidityCard.text()).toContain("66%"); // Rounded
  });

  it("shows warning status for low soil moisture", async () => {
    isLoadingSubject.next(false);

    const lowMoisture = SoilMoisture.fromPercentage(40);
    soilMoistureSubject.next(lowMoisture);

    await wrapper.vm.$nextTick();

    const moistureCard = wrapper.findAll(".metric-card")[2];
    expect(moistureCard.classes()).toContain("status-warning");
    expect(moistureCard.text()).toContain("Low");
  });

  it("shows critical status for very low soil moisture", async () => {
    isLoadingSubject.next(false);

    const criticalMoisture = SoilMoisture.fromPercentage(25);
    soilMoistureSubject.next(criticalMoisture);

    await wrapper.vm.$nextTick();

    const moistureCard = wrapper.findAll(".metric-card")[2];
    expect(moistureCard.classes()).toContain("status-danger");
    expect(moistureCard.text()).toContain("Critical - Irrigation Needed");
  });

  it("initializes ViewModel on mount", () => {
    expect(mockViewModel.initialize).toHaveBeenCalledTimes(1);
  });

  it("disposes ViewModel on unmount", () => {
    wrapper.unmount();
    expect(mockViewModel.dispose).toHaveBeenCalledTimes(1);
  });
});
```

Notice what we're testing:

- **Does the component render the loading state correctly?**
- **Does it display formatted values from the ViewModel?**
- **Does it apply the correct CSS classes based on state?**
- **Does it call ViewModel lifecycle methods at the right times?**

We're **not** testing:

- Whether the ViewModel fetches data correctly (that's a ViewModel test)
- Whether the temperature value object validates thresholds (that's a domain test)
- Whether the sensor service connects to WebSockets (that's an integration test)

The component test focuses purely on view concerns. This is fast (no network calls, no real ViewModels), isolated (behavior subjects let us control all state), and maintainable (changes to business logic don't break view tests).

Testing the form component works similarly:

```typescript
// IrrigationControl.spec.ts
import { describe, it, expect, beforeEach, vi } from "vitest";
import { mount, VueWrapper } from "@vue/test-utils";
import { BehaviorSubject } from "rxjs";
import IrrigationControl from "@/components/IrrigationControl.vue";
import { IrrigationControlViewModel } from "@/viewmodels/IrrigationControlViewModel";

describe("IrrigationControl Component", () => {
  let wrapper: VueWrapper;
  let mockViewModel: IrrigationControlViewModel;
  let durationSubject: BehaviorSubject<number>;
  let durationErrorSubject: BehaviorSubject<string | null>;
  let canSubmitSubject: BehaviorSubject<boolean>;

  beforeEach(() => {
    durationSubject = new BehaviorSubject<number>(30);
    durationErrorSubject = new BehaviorSubject<string | null>(null);
    canSubmitSubject = new BehaviorSubject<boolean>(false);

    mockViewModel = {
      duration$: durationSubject.asObservable(),
      durationError$: durationErrorSubject.asObservable(),
      canSubmit$: canSubmitSubject.asObservable(),
      setDuration: vi.fn(),
      submitManualIrrigation: vi.fn(),
      initialize: vi.fn(),
      dispose: vi.fn(),
    } as unknown as IrrigationControlViewModel;

    wrapper = mount(IrrigationControl, {
      global: {
        provide: {
          irrigationControlViewModel: mockViewModel,
        },
      },
      props: {
        greenhouseId: "gh-001",
      },
    });
  });

  it("displays duration input with current value", () => {
    const input = wrapper.find("#duration").element as HTMLInputElement;
    expect(input.value).toBe("30");
  });

  it("calls ViewModel setDuration when input changes", async () => {
    const input = wrapper.find("#duration");
    await input.setValue("45");

    expect(mockViewModel.setDuration).toHaveBeenCalledWith(45);
  });

  it("shows validation error when duration is invalid", async () => {
    durationErrorSubject.next("Duration must be between 1 and 120 minutes");
    await wrapper.vm.$nextTick();

    const errorMessage = wrapper.find(".error-message");
    expect(errorMessage.exists()).toBe(true);
    expect(errorMessage.text()).toBe(
      "Duration must be between 1 and 120 minutes"
    );
  });

  it("disables submit button when form is invalid", async () => {
    canSubmitSubject.next(false);
    await wrapper.vm.$nextTick();

    const submitButton = wrapper.find(".submit-button")
      .element as HTMLButtonElement;
    expect(submitButton.disabled).toBe(true);
  });

  it("enables submit button when form is valid", async () => {
    canSubmitSubject.next(true);
    await wrapper.vm.$nextTick();

    const submitButton = wrapper.find(".submit-button")
      .element as HTMLButtonElement;
    expect(submitButton.disabled).toBe(false);
  });

  it("calls ViewModel submitManualIrrigation on form submission", async () => {
    canSubmitSubject.next(true);
    await wrapper.vm.$nextTick();

    const form = wrapper.find(".control-form");
    await form.trigger("submit");

    expect(mockViewModel.submitManualIrrigation).toHaveBeenCalledTimes(1);
  });

  it("prevents form submission when enter is pressed", async () => {
    const form = wrapper.find(".control-form");
    await form.trigger("submit");

    // Form should handle submit via @submit.prevent
    expect(mockViewModel.submitManualIrrigation).toHaveBeenCalled();
  });
});
```

Again, we're testing view behavior: Does the form display state correctly? Does it capture user input? Does it delegate to the ViewModel? Does it prevent invalid submissions?

All the business logic—validation rules, API calls, scheduling—remains in the ViewModel where it's tested independently. The component test verifies only that the UI layer connects properly to the ViewModel's observable interface.

## Vue Router Integration: Navigation and ViewModels

Real applications have navigation. Let's look at how routing integrates with our ViewModel architecture in Vue.

Vue Router provides navigation guards—hooks that run before, during, and after route changes. These are perfect for ViewModel lifecycle management:

```typescript
// router/index.ts
import { createRouter, createWebHistory, RouteRecordRaw } from "vue-router";
import { container } from "@/infrastructure/di/container";

const routes: RouteRecordRaw[] = [
  {
    path: "/greenhouses/:id",
    name: "GreenhouseDetail",
    component: () => import("@/views/GreenhouseDetail.vue"),
    // Before entering route, ensure user has access
    beforeEnter: async (to, from, next) => {
      const greenhouseId = to.params.id as string;
      const authService = container.get<IAuthService>("IAuthService");

      const hasAccess = await authService.canAccessGreenhouse(greenhouseId);

      if (!hasAccess) {
        next({ name: "Unauthorized" });
      } else {
        next();
      }
    },
  },
  {
    path: "/greenhouses/:id/irrigation",
    name: "IrrigationControl",
    component: () => import("@/views/IrrigationControl.vue"),
    meta: {
      requiresPermission: "irrigation:control",
    },
  },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// Global navigation guard for permission checking
router.beforeEach(async (to, from, next) => {
  if (to.meta.requiresPermission) {
    const authService = container.get<IAuthService>("IAuthService");
    const hasPermission = await authService.hasPermission(
      to.meta.requiresPermission as string
    );

    if (!hasPermission) {
      next({ name: "Unauthorized" });
      return;
    }
  }

  next();
});

export default router;
```

Now, in your view component, you create ViewModels based on route parameters:

```vue
<!-- views/GreenhouseDetail.vue -->
<script setup lang="ts">
import { inject, computed, onBeforeUnmount } from "vue";
import { useRoute } from "vue-router";
import { GreenhouseMonitorViewModel } from "@/viewmodels/GreenhouseMonitorViewModel";
import type { ISensorDataService } from "@/domain/services/ISensorDataService";

const route = useRoute();
const sensorDataService = inject<ISensorDataService>("sensorDataService")!;

// Create ViewModel based on route parameter
const greenhouseId = computed(() => route.params.id as string);

const viewModel = new GreenhouseMonitorViewModel(
  sensorDataService,
  greenhouseId.value
);

// Initialize and clean up
import { onMounted } from "vue";

onMounted(() => {
  viewModel.initialize();
});

onBeforeUnmount(() => {
  viewModel.dispose();
});
</script>
```

For more complex scenarios where the same ViewModel might be shared across multiple routes, you can use Vue's `provide/inject` at the router-view level:

```vue
<!-- App.vue -->
<script setup lang="ts">
import { provide, watch } from "vue";
import { useRoute } from "vue-router";
import { container } from "@/infrastructure/di/container";

const route = useRoute();

// Watch route changes and provide appropriate ViewModels
watch(
  () => route.params.id,
  (newId) => {
    if (newId && route.name === "GreenhouseDetail") {
      const sensorService =
        container.get<ISensorDataService>("ISensorDataService");
      const viewModel = new GreenhouseMonitorViewModel(
        sensorService,
        newId as string
      );
      provide("greenhouseMonitorViewModel", viewModel);
    }
  },
  { immediate: true }
);
</script>
```

This pattern works particularly well for master-detail views where multiple child components need access to the same ViewModel. You provide it at the router-view level, and all descendants inject it without needing to pass props through intermediate components.

## State Persistence: Syncing ViewModel State with URL

Sometimes you want ViewModel state reflected in the URL—for deep linking, bookmarking, or sharing. Let's see how to sync ViewModel state with query parameters.

Consider our irrigation control form. We might want the selected zone and duration to persist in the URL so users can bookmark specific configurations:

```typescript
// composables/useIrrigationControlWithRouter.ts
import { watch } from "vue";
import { useRouter, useRoute } from "vue-router";
import { useIrrigationControl } from "./useIrrigationControl";
import type { IrrigationControlViewModel } from "@/viewmodels/IrrigationControlViewModel";

export function useIrrigationControlWithRouter(
  viewModel: IrrigationControlViewModel
) {
  const router = useRouter();
  const route = useRoute();

  // Get base composable state
  const state = useIrrigationControl(viewModel);

  // On mount, initialize from URL query params
  if (route.query.zone) {
    viewModel.setZone(route.query.zone as string);
  }

  if (route.query.duration) {
    viewModel.setDuration(parseInt(route.query.duration as string, 10));
  }

  // Watch ViewModel state and sync to URL
  watch(
    () => state.selectedZone.value,
    (newZone) => {
      if (newZone) {
        router.replace({
          query: {
            ...route.query,
            zone: newZone,
          },
        });
      }
    }
  );

  watch(
    () => state.duration.value,
    (newDuration) => {
      router.replace({
        query: {
          ...route.query,
          duration: newDuration.toString(),
        },
      });
    }
  );

  return state;
}
```

Now your component can use this enhanced composable:

```vue
<script setup lang="ts">
import { useIrrigationControlWithRouter } from "@/composables/useIrrigationControlWithRouter";

const viewModel = inject<IrrigationControlViewModel>(
  "irrigationControlViewModel"
)!;

// This version syncs with URL automatically
const state = useIrrigationControlWithRouter(viewModel);
</script>
```

The ViewModel doesn't know anything about routing or URLs. The composable layer handles synchronization between the ViewModel's observable state and the router's query parameters. This keeps concerns separated: the ViewModel manages domain logic, the composable handles framework integration and routing.

For more complex scenarios—like storing filter criteria or pagination state—you'd follow the same pattern: ViewModel exposes observables, composable watches those observables and syncs to URL, component remains unaware of the synchronization mechanism.

## Performance Considerations: Avoiding Unnecessary Re-renders

Vue's reactivity is efficient, but careless observable subscriptions can cause performance problems. Let's look at common pitfalls and solutions.

### Problem: Subscribing to High-Frequency Observables

If your ViewModel streams sensor data at high frequency (e.g., 10 readings per second), directly subscribing without throttling can overwhelm Vue's reactivity:

```typescript
// ❌ Problematic - updates too frequently
viewModel.sensorStream$.subscribe((reading) => {
  currentReading.value = reading; // Re-renders 10 times per second
});
```

**Solution: Throttle or debounce in the composable layer**

```typescript
// ✅ Better - throttle updates to reasonable frequency
import { throttleTime } from "rxjs/operators";

subscription.add(
  viewModel.sensorStream$
    .pipe(throttleTime(1000)) // Update at most once per second
    .subscribe((reading) => {
      currentReading.value = reading;
    })
);
```

The ViewModel still receives all readings (important for analytics or logging), but the view layer only updates once per second. This is a presentation concern—the composable decides the appropriate update frequency for the UI.

### Problem: Derived State Recomputation

If you're deriving multiple pieces of state from the same observable, you might be triggering excess computation:

```typescript
// ❌ Inefficient - subscribes multiple times to same observable
const temperature = ref<Temperature | null>(null);
const isHot = ref(false);
const isCold = ref(false);

viewModel.temperature$.subscribe((temp) => {
  temperature.value = temp;
});

viewModel.temperature$.subscribe((temp) => {
  isHot.value = temp?.isAboveThreshold(30) ?? false;
});

viewModel.temperature$.subscribe((temp) => {
  isCold.value = temp?.isBelowThreshold(15) ?? false;
});
```

**Solution: Single subscription with derived Vue computed properties**

```typescript
// ✅ Efficient - subscribe once, derive in Vue
const temperature = ref<Temperature | null>(null);

viewModel.temperature$.subscribe((temp) => {
  temperature.value = temp;
});

const isHot = computed(() => temperature.value?.isAboveThreshold(30) ?? false);

const isCold = computed(() => temperature.value?.isBelowThreshold(15) ?? false);
```

Vue's computed properties are memoized and only recompute when their dependencies change. This is more efficient than multiple RxJS subscriptions, especially when the derived values are used in templates.

### Problem: Observable Leaks in Nested Components

If you're creating ViewModels inside child components without proper cleanup, you can leak subscriptions:

```vue
<!-- ❌ Problematic nested component -->
<script setup lang="ts">
import { inject } from "vue";

// Creates new ViewModel instance on every render
const sensorService = inject<ISensorDataService>("sensorDataService");
const viewModel = new SensorDetailViewModel(sensorService, props.sensorId);

// Subscriptions are created but never cleaned up
const { reading, status } = useSensorDetail(viewModel);
</script>
```

**Solution: Hoist ViewModel creation to parent, or ensure proper cleanup**

```vue
<!-- ✅ Better - explicit lifecycle management -->
<script setup lang="ts">
import { inject, onBeforeUnmount } from "vue";

const sensorService = inject<ISensorDataService>("sensorDataService");

// Create ViewModel once
const viewModel = new SensorDetailViewModel(sensorService, props.sensorId);

const { reading, status } = useSensorDetail(viewModel);

// Explicit cleanup
onBeforeUnmount(() => {
  viewModel.dispose();
});
</script>
```

Or, better yet, create the ViewModel at a higher level and provide it to descendants:

```vue
<!-- Parent provides ViewModel -->
<script setup lang="ts">
provide("sensorViewModel", viewModel);
</script>

<!-- Child consumes provided ViewModel -->
<script setup lang="ts">
const viewModel = inject<SensorDetailViewModel>("sensorViewModel")!;
const { reading, status } = useSensorDetail(viewModel);
// No cleanup needed - parent handles lifecycle
</script>
```

By centralizing ViewModel lifecycle management, you avoid creating redundant instances and ensure proper cleanup.

## Vue vs React: Side-by-Side Comparison

Let's put the two implementations next to each other and examine what's different and what's identical.

**The ViewModel (identical in both frameworks):**

```typescript
export class GreenhouseMonitorViewModel {
  private readonly _temperatureSubject =
    new BehaviorSubject<Temperature | null>(null);
  private readonly _humiditySubject = new BehaviorSubject<Humidity | null>(
    null
  );
  private readonly _subscriptions = new Subscription();

  readonly temperature$ = this._temperatureSubject.asObservable();
  readonly humidity$ = this._humiditySubject.asObservable();

  constructor(
    private readonly sensorService: ISensorDataService,
    private readonly greenhouseId: string
  ) {}

  initialize(): void {
    this._subscriptions.add(
      this.sensorService.streamSensorData(this.greenhouseId).subscribe({
        next: (reading) => this.handleSensorReading(reading),
        error: (error) => this.handleError(error),
      })
    );
  }

  dispose(): void {
    this._subscriptions.unsubscribe();
  }

  private handleSensorReading(reading: SensorReading): void {
    // Domain logic - framework-agnostic
  }
}
```

**React integration layer:**

```typescript
function useGreenhouseMonitor(viewModel: GreenhouseMonitorViewModel) {
  const [temperature, setTemperature] = useState<Temperature | null>(null);
  const [humidity, setHumidity] = useState<Humidity | null>(null);

  useEffect(() => {
    viewModel.initialize();

    const subscription = new Subscription();
    subscription.add(viewModel.temperature$.subscribe(setTemperature));
    subscription.add(viewModel.humidity$.subscribe(setHumidity));

    return () => {
      subscription.unsubscribe();
      viewModel.dispose();
    };
  }, [viewModel]);

  return { temperature, humidity };
}
```

**Vue integration layer:**

```typescript
export function useGreenhouseMonitor(viewModel: GreenhouseMonitorViewModel) {
  const temperature = ref<Temperature | null>(null);
  const humidity = ref<Humidity | null>(null);
  const subscription = new Subscription();

  onMounted(() => {
    viewModel.initialize();

    subscription.add(
      viewModel.temperature$.subscribe((temp) => {
        temperature.value = temp;
      })
    );

    subscription.add(
      viewModel.humidity$.subscribe((hum) => {
        humidity.value = hum;
      })
    );
  });

  onUnmounted(() => {
    subscription.unsubscribe();
    viewModel.dispose();
  });

  return { temperature, humidity };
}
```

The structural similarities are striking:

1. Both create framework-specific reactive state
2. Both subscribe to ViewModel observables on mount
3. Both update local state when observables emit
4. Both clean up subscriptions on unmount
5. Both return state to the component

The differences are purely syntactic:

- React uses `useState` hooks, Vue uses `ref()`
- React uses `useEffect`, Vue uses `onMounted/onUnmounted`
- React state updates via setter functions, Vue updates via `.value` property
- React cleanup via effect return function, Vue cleanup via separate lifecycle hook

These are framework mechanics, not architectural differences. The **pattern**—the way we structure the integration between ViewModel and view—is identical.

This consistency proves our architecture's framework independence. We're not fighting against React's or Vue's idioms. We're using each framework naturally while maintaining the same underlying architecture.

## Common Pitfalls When Implementing MVVM in Vue

Let's address the mistakes developers commonly make when adopting this architecture in Vue.

### Pitfall 1: Mixing Domain Logic into Composables

```typescript
// ❌ Don't do this - business logic in composable
export function useIrrigationControl(viewModel: IrrigationControlViewModel) {
  const duration = ref(30);

  function setDuration(value: number) {
    // Validation logic doesn't belong here!
    if (value < 1 || value > 120) {
      errorMessage.value = "Duration must be between 1 and 120 minutes";
      return;
    }
    duration.value = value;
    viewModel.setDuration(value);
  }

  return { duration, setDuration };
}
```

This seems convenient, but you've just put business logic (validation rules) into the presentation layer. Now that validation only exists in Vue. If you build a React version, you'll duplicate it. If requirements change (max duration becomes 180 minutes), you have to hunt through composables.

**Correct approach: Domain logic stays in the ViewModel**

```typescript
// ✅ Validation in ViewModel
export class IrrigationControlViewModel {
  setDuration(value: number): void {
    if (value < 1 || value > this.maxDuration) {
      this._durationErrorSubject.next(
        `Duration must be between 1 and ${this.maxDuration} minutes`
      );
      return;
    }
    this._durationErrorSubject.next(null);
    this._durationSubject.next(value);
  }
}

// ✅ Composable just bridges observables
export function useIrrigationControl(viewModel: IrrigationControlViewModel) {
  const duration = ref(30);
  const durationError = ref<string | null>(null);

  subscription.add(
    viewModel.duration$.subscribe((val) => {
      duration.value = val;
    })
  );

  subscription.add(
    viewModel.durationError$.subscribe((error) => {
      durationError.value = error;
    })
  );

  return { duration, durationError };
}
```

The composable is now purely mechanical—subscribe to observables, update refs. All rules live in the ViewModel where they're testable and framework-agnostic.

### Pitfall 2: Reactive Objects Breaking Observable Boundaries

```typescript
// ❌ Problematic - reactive object loses sync with observable
const state = reactive({
  temperature: null as Temperature | null,
  humidity: null as Humidity | null,
});

viewModel.temperature$.subscribe((temp) => {
  // This assignment can break reactivity
  state.temperature = temp;
});
```

Vue's reactive system tracks property access, not assignment. If `temperature` wasn't initially reactive, assigning it won't trigger updates. Even if it was, nested object mutations might not propagate correctly.

**Solution: Use refs for observable data**

```typescript
// ✅ Explicit reactivity with refs
const temperature = ref<Temperature | null>(null);
const humidity = ref<Humidity | null>(null);

viewModel.temperature$.subscribe((temp) => {
  temperature.value = temp; // Reactivity guaranteed
});
```

The `.value` syntax makes the reactivity boundary explicit. Vue tracks access to `.value`, ensuring updates propagate reliably.

### Pitfall 3: Not Disposing ViewModels on Navigation

```typescript
// ❌ Memory leak - ViewModel persists after route change
const viewModel = new GreenhouseMonitorViewModel(
  sensorService,
  route.params.id
);

// No cleanup = subscriptions keep running
```

When you navigate away from a view, the component unmounts but the ViewModel's subscriptions keep running. Over time, you accumulate zombie subscriptions consuming memory and CPU.

**Solution: Always dispose ViewModels in onUnmounted**

```typescript
// ✅ Proper lifecycle management
onBeforeUnmount(() => {
  viewModel.dispose();
});
```

Or, better yet, encapsulate lifecycle in a composable:

```typescript
export function useViewModelLifecycle<
  T extends { initialize(): void; dispose(): void },
>(viewModel: T): T {
  onMounted(() => viewModel.initialize());
  onBeforeUnmount(() => viewModel.dispose());
  return viewModel;
}

// Usage
const viewModel = useViewModelLifecycle(
  new GreenhouseMonitorViewModel(sensorService, greenhouseId)
);
```

This pattern centralizes lifecycle management, making it impossible to forget cleanup.

### Pitfall 4: Overusing Vue Computed for Domain Calculations

```typescript
// ❌ Domain logic in Vue computed
const temperatureStatus = computed(() => {
  if (!temperature.value) return null;

  // These thresholds are business rules, not view concerns
  if (temperature.value.celsius > 30) return "Too Hot";
  if (temperature.value.celsius > 25) return "Warm";
  if (temperature.value.celsius < 15) return "Cold";
  return "Optimal";
});
```

This logic should be in the domain layer, either in the `Temperature` value object or the ViewModel. By putting it in a Vue computed, you've coupled business rules to the framework.

**Solution: Domain logic in domain objects**

```typescript
// ✅ In Temperature value object
export class Temperature {
  getStatus(): "TooHot" | "Warm" | "Cold" | "Optimal" {
    if (this.celsius > 30) return "TooHot";
    if (this.celsius > 25) return "Warm";
    if (this.celsius < 15) return "Cold";
    return "Optimal";
  }
}

// ✅ In component - pure presentation logic
const temperatureStatusText = computed(() => {
  const status = temperature.value?.getStatus();

  switch (status) {
    case "TooHot":
      return "Too Hot";
    case "Warm":
      return "Warm";
    case "Cold":
      return "Cold";
    case "Optimal":
      return "Optimal";
    default:
      return null;
  }
});
```

Now the business rule (what constitutes "too hot") lives in the domain. The Vue computed handles only presentation concerns (mapping domain status to display text). This is testable, reusable, and framework-independent.

## Evolution Strategy: Migrating Existing Vue Apps to MVVM

If you have an existing Vue application built without ViewModels, here's a pragmatic migration strategy.

### Phase 1: Extract Domain Logic (No Framework Changes)

Start by identifying domain logic scattered throughout your components. Create domain services and move business rules out of components:

```vue
<!-- Before: Logic in component -->
<script setup lang="ts">
const temperature = ref(0);
const status = ref("");

async function fetchTemperature() {
  const response = await fetch(`/api/sensors/${sensorId}`);
  const data = await response.json();
  temperature.value = data.temperature;

  // Business logic in component
  if (data.temperature > 30) {
    status.value = "Too Hot";
    // Send alert
    await fetch("/api/alerts", {
      method: "POST",
      body: JSON.stringify({ message: "Temperature critical" }),
    });
  }
}
</script>
```

```typescript
// After: Extract to service
export class SensorDataService {
  async getCurrentTemperature(sensorId: string): Promise<Temperature> {
    const response = await this.httpClient.get(`/sensors/${sensorId}`);
    return Temperature.fromCelsius(response.data.temperature);
  }
}

export class AlertService {
  async sendTemperatureAlert(temperature: Temperature): Promise<void> {
    if (temperature.isAboveThreshold(30)) {
      await this.httpClient.post("/alerts", {
        message: `Temperature critical: ${temperature.celsius}°C`,
      });
    }
  }
}
```

```vue
<!-- Component now uses services -->
<script setup lang="ts">
const sensorService = inject<SensorDataService>("sensorDataService");
const alertService = inject<AlertService>("alertService");

const temperature = ref<Temperature | null>(null);

async function fetchTemperature() {
  temperature.value = await sensorService.getCurrentTemperature(sensorId);
  await alertService.sendTemperatureAlert(temperature.value);
}
</script>
```

You haven't introduced ViewModels yet, but you've separated domain logic from the component. This is valuable on its own and sets the foundation for ViewModels.

### Phase 2: Introduce ViewModels for New Features

When building new features, implement them with ViewModels from the start. Don't refactor existing code yet—prove the pattern works with fresh implementations:

```typescript
// New feature: Irrigation scheduling
export class IrrigationScheduleViewModel {
  private readonly _schedulesSubject = new BehaviorSubject<Schedule[]>([]);
  readonly schedules$ = this._schedulesSubject.asObservable();

  constructor(private readonly irrigationService: IIrrigationService) {}

  async loadSchedules(): Promise<void> {
    const schedules = await this.irrigationService.getSchedules();
    this._schedulesSubject.next(schedules);
  }

  async addSchedule(schedule: Schedule): Promise<void> {
    await this.irrigationService.createSchedule(schedule);
    await this.loadSchedules();
  }
}
```

```vue
<!-- New component uses ViewModel -->
<script setup lang="ts">
const viewModel = inject<IrrigationScheduleViewModel>("scheduleViewModel");
const { schedules } = useIrrigationSchedule(viewModel);
</script>
```

New features get the benefits of clean architecture immediately. Existing features continue working without disruption.

### Phase 3: Refactor High-Value Components

Once you're comfortable with ViewModels, refactor components that would benefit most:

**Candidates for early refactoring:**

- Complex forms with validation
- Real-time data displays
- Components with significant business logic
- Features that might need React/Angular versions

**Not worth refactoring early:**

- Simple presentational components
- Stable, rarely-changed code
- Components with minimal logic

Focus on areas where MVVM provides clear value: better testability, reusability, or maintainability.

### Phase 4: Establish Patterns and Conventions

As you build ViewModels, document patterns your team should follow:

```typescript
// Establish naming conventions
// ✅ Good
export class GreenhouseMonitorViewModel {}
export class IrrigationControlViewModel {}

// ❌ Avoid
export class GreenhouseVM {}
export class IrrigationCtrl {}

// Establish lifecycle patterns
export function useViewModelWithLifecycle<T>(viewModel: T): T {
  // Standard initialization and cleanup
}

// Establish testing patterns
describe("ViewModel", () => {
  let viewModel: SomeViewModel;
  let mockService: MockSomeService;

  beforeEach(() => {
    // Standard setup
  });
});
```

Consistency across your codebase makes the architecture easier to understand and maintain.

## Wrapping Up: Framework Independence Validated

We've now implemented the same GreenWatch features in both React and Vue, reusing our entire business logic layer. The domain services, ViewModels, value objects, and aggregates didn't change. We only adapted the presentation layer to each framework's idioms.

This is the power of disciplined architectural separation. When your business logic lives in framework-agnostic classes exposed through RxJS observables, framework choice becomes a detail. You're not locked into React's ecosystem or Vue's tooling. You can support multiple platforms, migrate between frameworks, or incrementally adopt new technologies without rewriting your application.

In the next chapter, we'll explore how this same architecture works with other view technologies—Angular, Web Components, and even native mobile apps. The pattern remains consistent: ViewModels expose state through observables, views subscribe and update reactively, business logic stays framework-agnostic.

But before we move on, let's be honest about something: not every application needs this level of architectural rigor. If you're building a small internal tool that will only ever use Vue, the overhead of maintaining strict ViewModel separation might not be worth it. Architecture is about trade-offs, and MVVM trades some initial complexity for long-term flexibility.

The question you need to answer: Are you building software that needs to evolve, scale, and potentially outlive its current framework? If yes, the investment in framework-independent architecture pays dividends. If no, simpler patterns might serve you better.

We've built the foundation. Now it's time to see how far we can push it.
